<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Serverless &#8211; LessthanDot</title>
	<atom:link href="/index.php/tag/serverless/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>A Technical Community for IT Professionals</description>
	<lastBuildDate>Sat, 09 Mar 2019 12:50:36 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.1</generator>
	<item>
		<title>Streaming Alerts using AWS Lambda, Kinesis, and DynamoDB</title>
		<link>/index.php/enterprisedev/cloud/streaming-alerts-using-aws-lambda-kinesis-and-dynamodb/</link>
		<comments>/index.php/enterprisedev/cloud/streaming-alerts-using-aws-lambda-kinesis-and-dynamodb/#respond</comments>
		<pubDate>Tue, 23 Jan 2018 18:06:36 +0000</pubDate>
		<dc:creator><![CDATA[Eli Weinstock-Herman (tarwn)]]></dc:creator>
				<category><![CDATA[Cloud]]></category>
		<category><![CDATA[aws]]></category>
		<category><![CDATA[DynamoDB]]></category>
		<category><![CDATA[Kinesis]]></category>
		<category><![CDATA[lambda]]></category>
		<category><![CDATA[node.js]]></category>
		<category><![CDATA[Serverless]]></category>

		<guid isPermaLink="false">/?p=8898</guid>
		<description><![CDATA[Recently I was talking to some friends about alerting on complex streaming data. Between some past event processing work we had done and earlier experience aggregating real-time manufacturing data, I was thinking a lot about projecting and evaluating results as we go versus querying the for results on some frequency. It seemed like a realistic [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Recently I was talking to some friends about alerting on complex streaming data. Between some past event processing work we had done and earlier experience aggregating real-time manufacturing data, I was thinking a lot about projecting and evaluating results as we go versus querying the for results on some frequency. It seemed like a realistic approach and I couldn&#8217;t stop thinking about it, so I decided to prototype the pieces that I was least familiar with. </p>
<p>The idea is based on one that is used frequently in CQRS and I&#8217;m far from the first to have it, professional tools like <a href="https://spark.apache.org/">Apache Spark</a> and <a href="https://aws.amazon.com/kinesis/data-analytics/">Amazon Kinesis Data Analytics</a> support this idea of a continuous query over time, but part of the driver was also the desire to support user-defined rules in a multi-tenant environment and see how that would impact my design thinking as I prototyped.</p>
<div style="border: 1px solid #eeeeee; border-left: 8px solid #eeeeee; margin: .5em 0; padding: 1em;">
<b>Examples:</b></p>
<ul>
<li><a href="https://docs.aws.amazon.com/kinesisanalytics/latest/dev/app-simple-alerts.html">Kinesis Analytics: Stock Prices Changes &gt; 1%</a></li>
<li><a href="https://gallery.cortanaintelligence.com/Tutorial/Using-Azure-Stream-Analytics-for-Real-time-fraud-detection-2">Azure Analytics: Detecting SIM fraud</a></li>
</div>
<p>It pushed me to learn some new (to me) things, so I thought I would share what I did and perhaps some of this will be helpful or interesting to others as well. </p>
<h2>Just Enough Prototyping w/ Lambdas, Kinesis, and DynamoDB</h2>
<p>So I set out to build just enough of a prototype to answer the unknowns, creating a small serverless application that receives a stream of events for 2 clients that each have 5 machines that change state simultaneously (warming up, running, shut down) so I could experiment with rules with different criteria and get a feel for how complex this would be.</p>
<div id="attachment_8900" style="width: 718px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2018/01/AnalyticsOverview.png" alt="Analytics Overview" width="708" height="608" class="size-full wp-image-8900" srcset="/wp-content/uploads/2018/01/AnalyticsOverview.png 708w, /wp-content/uploads/2018/01/AnalyticsOverview-300x258.png 300w" sizes="(max-width: 708px) 100vw, 708px" /><p class="wp-caption-text">Analytics Overview</p></div>
<p>I would use a fake front-end to manage some fake &#8220;machines&#8221; for 2 &#8220;clients&#8221;, that would change state occasionally and publish those events. The fake site would push those events into the beginning of my real prototype, an <a href="https://aws.amazon.com/kinesis/">Amazon Kinesis</a> stream for events. An <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> function, the &#8220;Rule Processor&#8221;, would be triggered by a batch of events on the stream. It would load the appropriate rules out of <A href="https://aws.amazon.com/dynamodb/">DynamoDB</a> for each client, evaluate which rules each event applies to, then combine that with previously cached events from DynamoDB and evaluate whether the rule is satisfied. If so, an alert would be published to the Kinesis Alerts Stream. Further downstream, an &#8220;Alerts Processor&#8221; function would receive those alerts and, in a real system, decide what types of notifications were necessary.</p>
<h2>Rules and DynamoDB Store</h2>
<p>The buckets of data in AWS can be thought of as query results that I am constantly updating for each event that comes in.</p>
<p><strong>Example Event:</strong></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
</pre></td><td class="de1"><pre class="de1"><span class="br0">&#123;</span> 
&nbsp; &nbsp; <span class="st0">&quot;eventType&quot;</span><span class="sy0">:</span> <span class="st0">&quot;machineStatusChange&quot;</span><span class="sy0">,</span> 
&nbsp; &nbsp; <span class="st0">&quot;state&quot;</span><span class="sy0">:</span> <span class="st0">&quot;stopped&quot;</span><span class="sy0">,</span> 
&nbsp; &nbsp; <span class="st0">&quot;clientId&quot;</span><span class="sy0">:</span> <span class="st0">&quot;client-01&quot;</span><span class="sy0">,</span> 
&nbsp; &nbsp; <span class="st0">&quot;machineId&quot;</span><span class="sy0">:</span> <span class="st0">&quot;machine-01&quot;</span>
<span class="br0">&#125;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">{ 
    "eventType": "machineStatusChange", 
    "state": "stopped", 
    "clientId": "client-01", 
    "machineId": "machine-01"
}</pre></div></div>

<p><strong>Example Rule:</strong></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="de1"><pre class="de1"><span class="co1">// alert when all machines enter stopping state</span>
<span class="kw1">new</span> Rule<span class="br0">&#40;</span><span class="br0">&#123;</span>
&nbsp; &nbsp; ruleId<span class="sy0">:</span> <span class="st0">'hardcoded-rule-02'</span><span class="sy0">,</span>
&nbsp; &nbsp; clientId<span class="sy0">:</span> <span class="st0">&quot;client-01&quot;</span><span class="sy0">,</span>
&nbsp; &nbsp; where<span class="sy0">:</span> <span class="br0">&#91;</span><span class="br0">&#123;</span> <span class="st0">'property'</span><span class="sy0">:</span> <span class="st0">'machineId'</span><span class="sy0">,</span> <span class="st0">'equals'</span><span class="sy0">:</span> <span class="st0">'*'</span> <span class="br0">&#125;</span><span class="br0">&#93;</span><span class="sy0">,</span>
&nbsp; &nbsp; partitionBy<span class="sy0">:</span> <span class="br0">&#91;</span><span class="st0">'machineId'</span><span class="br0">&#93;</span><span class="sy0">,</span>
&nbsp; &nbsp; evaluate<span class="sy0">:</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; type<span class="sy0">:</span> <span class="st0">'all'</span><span class="sy0">,</span>
&nbsp; &nbsp; &nbsp; &nbsp; having<span class="sy0">:</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; calc<span class="sy0">:</span> <span class="st0">'latest'</span><span class="sy0">,</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; property<span class="sy0">:</span> <span class="st0">'state'</span><span class="sy0">,</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equals<span class="sy0">:</span> <span class="st0">'stopped'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">// alert when all machines enter stopping state
new Rule({
    ruleId: 'hardcoded-rule-02',
    clientId: "client-01",
    where: [{ 'property': 'machineId', 'equals': '*' }],
    partitionBy: ['machineId'],
    evaluate: {
        type: 'all',
        having: {
            calc: 'latest',
            property: 'state',
            equals: 'stopped'
        }
    }
})</pre></div></div>

<p>I wouldn&#8217;t expect an end user to enter a rule like this and would probably rework the structure if this was intended to be a real system, but it is good enough to let me resolve the bigger unknowns around processing events and partitioning data.</p>
<h2>Implementation</h2>
<p>I used the <a href="https://serverless.com/">serverless</a> platform to define and build these functions, running locally with a combination of <a href="https://github.com/dherault/serverless-offline">serverless-offline</a>, <a href="https://github.com/mhart/kinesalite">kinesalite</a>, <a href="https://github.com/mhart/dynalite">dynalite</a> and some tooling I cooked up to run kinesis functions locally (see <a href="/index.php/enterprisedev/cloud/serverless-http-kinesis-lambdas-with-offline-development/" title="Prior Post: Serverless HTTP + Kinesis Lambdas with Offline Development">Serverless HTTP + Kinesis Lambdas with Offline Development</a>). I also used <a href="https://wallabyjs.com/">wallaby.js</a> heavily to give me fast, inline feedback with unit tests inside larger iterations of manual testing with the <a href="https://expressjs.com/">express</a> front-end I bolted into another HTTP Lambda.</p>
<p>The code can be found here: <a href="https://github.com/tarwn/serverless-eventing-analytics">github: tarwn/serverless-eventing-analytics</a></p>
<p>The core of the system is the &#8220;Rule Processor&#8221;:</p>
<div id="attachment_8901" style="width: 463px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2018/01/RuleProcessor.png" alt="Rule Processor Logic" width="453" height="624" class="size-full wp-image-8901" srcset="/wp-content/uploads/2018/01/RuleProcessor.png 453w, /wp-content/uploads/2018/01/RuleProcessor-218x300.png 218w" sizes="(max-width: 453px) 100vw, 453px" /><p class="wp-caption-text">Rule Processor Logic</p></div>
<p>The Rule Processor is triggered by a batch of events from Kinesis:</p>
<ul>
<li>Extract the event data from the batch</li>
<li>Group them by Client</li>
<li>For Each Client&#8217;s group of events:
<ul>
<li>Load the client&#8217;s rules</li>
<li>Create result buckets for each rule and add applicable events to it</li>
<li>Load past result data from DynamoDB and append local result data</li>
<li>Evaluate rule conditions and output any alerts</li>
</ul>
</li>
<li>Publish the collected alerts to the Alerts Kinesis Stream</li>
</ul>
<p>Each of the &#8220;Event x Rule&#8221; result buckets can be thought of as the results of a query we&#8217;re running continuously as events flow in (which is about the time I realized I was duplicating work a bunch of much smarter folks had put into stream analytics packages above). So if I have 6 rules that care about machine events and 1 event comes in for &#8220;machineStatusChange&#8221; on &#8220;machine-01&#8221;, then I&#8217;ll add that event to all 6 buckets individually (storage is cheap).</p>
<p>The rules are responsible for generating their own unique result name, which by convention is {clientId}/rules/{rule id}/{where clause specific bits}. You can see more in <a href="https://github.com/tarwn/serverless-eventing-analytics/blob/master/functions/ruleProcessor/lib/rule.js">/functions/ruleProcessor/lib/rule.js</a> .</p>
<p>The function code is a slightly messier version of the steps above:</p>
<p>/functions/ruleProcessor/handler.js (<a href="https://github.com/tarwn/serverless-eventing-analytics/blob/master/functions/ruleProcessor/handler.js">github</a>)</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="de1"><pre class="de1">module.<span class="me1">exports</span>.<span class="me1">streamProcessor</span> <span class="sy0">=</span> <span class="br0">&#40;</span>kinesisEvent<span class="sy0">,</span> context<span class="sy0">,</span> callback<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; <span class="kw1">const</span> events <span class="sy0">=</span> helper.<span class="me1">extractEventsFromKinesisEvent</span><span class="br0">&#40;</span>kinesisEvent<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; <span class="kw1">const</span> eventGroups <span class="sy0">=</span> helper.<span class="me1">groupEventsByClient</span><span class="br0">&#40;</span>events<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
&nbsp; &nbsp; Promise.<span class="me1">all</span><span class="br0">&#40;</span>eventGroups.<span class="me1">map</span><span class="br0">&#40;</span><span class="br0">&#40;</span>group<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> evaluateAndStore<span class="br0">&#40;</span>group<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
&nbsp; &nbsp; <span class="co1">// …</span>
&nbsp; &nbsp; .<span class="me1">then</span><span class="br0">&#40;</span><span class="br0">&#40;</span>nestedAlerts<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">var</span> alerts <span class="sy0">=</span> flatten<span class="br0">&#40;</span>nestedAlerts<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">const</span> publishAlerts <span class="sy0">=</span> alerts.<span class="me1">map</span><span class="br0">&#40;</span><span class="br0">&#40;</span>alert<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> publishAlert<span class="br0">&#40;</span>alert<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> Promise.<span class="me1">all</span><span class="br0">&#40;</span>publishAlerts<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; <span class="br0">&#125;</span><span class="br0">&#41;</span>
&nbsp; &nbsp; <span class="co1">// …</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">function</span> evaluateAndStore<span class="br0">&#40;</span>eventGroup<span class="br0">&#41;</span><span class="br0">&#123;</span>
&nbsp; &nbsp; <span class="kw1">const</span> clientRules <span class="sy0">=</span> rules.<span class="kw1">get</span><span class="br0">&#40;</span>eventGroup.<span class="me1">clientId</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; <span class="kw1">const</span> localResults <span class="sy0">=</span> helper.<span class="me1">applyRules</span><span class="br0">&#40;</span>clientRules<span class="sy0">,</span> eventGroup<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
&nbsp; &nbsp; <span class="co1">// open per-rule results to merge with stored results and evaluate for alert</span>
&nbsp; &nbsp; <span class="kw1">return</span> Promise.<span class="me1">all</span><span class="br0">&#40;</span>localResults.<span class="me1">map</span><span class="br0">&#40;</span><span class="br0">&#40;</span>result<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">const</span> appliedRule <span class="sy0">=</span> clientRules.<span class="me1">find</span><span class="br0">&#40;</span><span class="br0">&#40;</span>cr<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> cr.<span class="me1">ruleId</span> <span class="sy0">=</span> result.<span class="me1">ruleId</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> results.<span class="me1">applyLocalResultToStoredResult</span><span class="br0">&#40;</span>result<span class="sy0">,</span> appliedRule<span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .<span class="me1">then</span><span class="br0">&#40;</span><span class="br0">&#40;</span>completeResult<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>appliedRule.<span class="me1">meetsConditionsFor</span><span class="br0">&#40;</span>completeResult<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span>`ALERTED <span class="kw1">for</span> $<span class="br0">&#123;</span>completeResult.<span class="me1">uniqueResultKey</span><span class="br0">&#125;</span>`<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> appliedRule.<span class="me1">getAlertFor</span><span class="br0">&#40;</span>completeResult<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">else</span><span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span>`No alerts <span class="kw1">for</span> $<span class="br0">&#123;</span>completeResult.<span class="me1">uniqueResultKey</span><span class="br0">&#125;</span>`<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="kw2">null</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
&nbsp; &nbsp; .<span class="me1">then</span><span class="br0">&#40;</span><span class="br0">&#40;</span>nestedAlerts<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> flatten<span class="br0">&#40;</span>nestedAlerts<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">module.exports.streamProcessor = (kinesisEvent, context, callback) =&gt; {
    const events = helper.extractEventsFromKinesisEvent(kinesisEvent);
    const eventGroups = helper.groupEventsByClient(events);

    Promise.all(eventGroups.map((group) =&gt; evaluateAndStore(group)))
    // …
    .then((nestedAlerts) =&gt; {
        var alerts = flatten(nestedAlerts);

        const publishAlerts = alerts.map((alert) =&gt; {
            return publishAlert(alert);
        });
        return Promise.all(publishAlerts);
    })
    // …
};

function evaluateAndStore(eventGroup){
    const clientRules = rules.get(eventGroup.clientId);
    const localResults = helper.applyRules(clientRules, eventGroup);

    // open per-rule results to merge with stored results and evaluate for alert
    return Promise.all(localResults.map((result) =&gt; { 
        const appliedRule = clientRules.find((cr) =&gt; cr.ruleId = result.ruleId);
        return results.applyLocalResultToStoredResult(result, appliedRule)
            .then((completeResult) =&gt; {
                if (appliedRule.meetsConditionsFor(completeResult)) { 
                    console.log(`ALERTED for ${completeResult.uniqueResultKey}`);
                    return appliedRule.getAlertFor(completeResult);
                }
                else{
                    console.log(`No alerts for ${completeResult.uniqueResultKey}`);
                    return null;
                }
            });
    }))
    .then((nestedAlerts) =&gt; flatten(nestedAlerts));
}</pre></div></div>

<p>When events start flowing through, we can see data getting loaded and applied for each of those rules. Client-02 alerts when any machine enters a stopped state (as opposed to all machines, like client-01 above), so we can see </p>
<div id="attachment_8902" style="width: 837px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2018/01/RuleProcessorOutput.png" alt="Rule Processor Output" width="827" height="255" class="size-full wp-image-8902" srcset="/wp-content/uploads/2018/01/RuleProcessorOutput.png 827w, /wp-content/uploads/2018/01/RuleProcessorOutput-300x93.png 300w, /wp-content/uploads/2018/01/RuleProcessorOutput-768x237.png 768w" sizes="(max-width: 827px) 100vw, 827px" /><p class="wp-caption-text">Rule Processor Output</p></div>
<p>You can run this yourself by cloning the <a href="https://github.com/tarwn/serverless-eventing-analytics">github repo</a>, running <code>npm run offline</code>, and then opening your browser to <a href="http://localhost:3000/">http://localhost:3000/</a>.</p>
<h2>Next Steps</h2>
<p>This proved out the big question I had, and maybe helped some folks with running Kinesis functions locally (previous post), so I&#8217;m calling it a win. If I were building this for production, the next steps would be to continue making the rules richer, figure out how to age data out of the result set I&#8217;m storing in DynamoDB, and start building an interface that would allow you to create and store a rule on your own. Another big question would be whether I also need some sort of regular event (second? Minute) to re-evaluate rules for data to fall off or for queries that want to rely on the continued state of a value without needing new events to come in and restart it (the machine is still running, still running, still running…). </p>
]]></content:encoded>
			<wfw:commentRss>/index.php/enterprisedev/cloud/streaming-alerts-using-aws-lambda-kinesis-and-dynamodb/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Serverless HTTP + Kinesis Lambdas with Offline Development</title>
		<link>/index.php/enterprisedev/cloud/serverless-http-kinesis-lambdas-with-offline-development/</link>
		<comments>/index.php/enterprisedev/cloud/serverless-http-kinesis-lambdas-with-offline-development/#comments</comments>
		<pubDate>Tue, 16 Jan 2018 14:24:20 +0000</pubDate>
		<dc:creator><![CDATA[Eli Weinstock-Herman (tarwn)]]></dc:creator>
				<category><![CDATA[Cloud]]></category>
		<category><![CDATA[FaaS]]></category>
		<category><![CDATA[Kinesis]]></category>
		<category><![CDATA[lambda]]></category>
		<category><![CDATA[node.js]]></category>
		<category><![CDATA[Serverless]]></category>

		<guid isPermaLink="false">/?p=8865</guid>
		<description><![CDATA[Lately I&#8217;ve been exploring an idea around applying custom, user-defined rules to streams of events. I&#8217;m using a combination of technologies, but the core is a FaaS setup that I can run locally that utilizes the serverless package to deploy AWS Lambda functions that consume events from a Kinesis stream. I prefer the speed of [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Lately I&#8217;ve been exploring an idea around applying custom, user-defined rules to streams of events. I&#8217;m using a combination of technologies, but the core is a <abbr title="Function-as-a-Service">FaaS</abbr> setup that I can run locally that utilizes the <a href="https://serverless.com/">serverless</a> package to deploy <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> functions that consume events from a <a href="https://aws.amazon.com/kinesis/">Kinesis stream</a>. </p>
<p>I prefer the speed of local development feedback cycles. Getting HTTP Functions running locally was easy with serverless-offline, Kinesis was a lot trickier with more false starts. If you&#8217;re trying to get local node.js Lambdas running for HTTP and Kinesis, hopefully this will help.</p>
<h2>Spoilers&#8230;</h2>
<p>By the end of this post, we&#8217;ll have an HTTP endpoint that can accept POSTed events and publish to a Kinesis stream. We&#8217;ll have another function pulling events off that stream and processing them. No infrastructure, no polling code, no webserver configurations, less than 40 lines of code, and a simple cli command to deploy: <code>serverless deploy</code></p>
<div id="attachment_8867" style="width: 666px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2018/01/OfflineHttpAndKinesisOutput.png" alt="cUrl =&gt; HTTP Function =&gt; Kinesis Stream =&gt; Kinesis Function" width="656" height="161" class="size-full wp-image-8867" srcset="/wp-content/uploads/2018/01/OfflineHttpAndKinesisOutput.png 656w, /wp-content/uploads/2018/01/OfflineHttpAndKinesisOutput-300x74.png 300w" sizes="(max-width: 656px) 100vw, 656px" /><p class="wp-caption-text">cUrl => HTTP Function => Kinesis Stream => Kinesis Function</p></div>
<p>That&#8217;s pretty standard FaaS stuff, but I can&#8217;t stand the latency of deploying to test changes, so I&#8217;ll add in some plugins and a little hackery to have all of that running in realtime, locally, with automatic syncing of changes as they&#8217;re made (because I don&#8217;t even like restarting services to try changes).</p>
<div id="attachment_8890" style="width: 699px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2018/01/OfflineHttpAndKinesisOutputUpdated.png" alt="Updated Functions, Running Locally, No Restarts (SUPER!!!)" width="689" height="157" class="size-full wp-image-8890" srcset="/wp-content/uploads/2018/01/OfflineHttpAndKinesisOutputUpdated.png 689w, /wp-content/uploads/2018/01/OfflineHttpAndKinesisOutputUpdated-300x68.png 300w" sizes="(max-width: 689px) 100vw, 689px" /><p class="wp-caption-text">Updated Functions, Running Locally, No Restarts (SUPER!!!)</p></div>
<p>Here comes the details&#8230;</p>
<h2>Laying the Groundwork: An HTTP Function</h2>
<p>First I need some events flowing into a log. I&#8217;m choosing to use an HTTP endpoint to start getting setup for more complex functions and so I don&#8217;t get distracted building something to produce real events.<br />
I&#8217;m using <a href="">serverless</a> to wire up and deploy my functions. Two of the benefits of this is not wiring my deployment to git commits and being able to simulate Lambda and run my function logic locally.</p>
<h3>1. Set Up Serverless + AWS</h3>
<p>First up, I followed the Getting Started directions to get serverless setup with AWS credentials: </p>
<ul>
<li><a href="https://serverless.com/framework/docs/providers/aws/guide/installation/" title="Serverless.com: AWS - Installation">AWS &#8211; Installation</a></li>
<li><a href="https://serverless.com/framework/docs/providers/aws/guide/credentials/" title="Serverless.com: AWS - Credentials">AWS &#8211; Credentials</a></li>
</ul>
<p>Next, I define a very simple Http handler for my function:</p>
<p><b>OfflineHttp/functions/eventsHttp.js</b> <a href="https://github.com/tarwn/serverless-examples/blob/master/OfflineHttp/functions/eventsHttp.js">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1">module.<span class="me1">exports</span>.<span class="me1">handler</span> <span class="sy0">=</span> <span class="br0">&#40;</span>event<span class="sy0">,</span> context<span class="sy0">,</span> callback<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span> 
&nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">&quot;You POSTed an event!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span>event.<span class="me1">body</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; callback<span class="br0">&#40;</span><span class="kw2">null</span><span class="sy0">,</span> <span class="br0">&#123;</span> statusCode<span class="sy0">:</span> <span class="nu0">200</span><span class="sy0">,</span> body<span class="sy0">:</span> <span class="st0">&quot;Success&quot;</span> <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">module.exports.handler = (event, context, callback) =&gt; { 
	console.log("You POSTed an event!");
	console.log(event.body);
	callback(null, { statusCode: 200, body: "Success" });
};</pre></div></div>

<p>Add the serverless-offline package: <code>npm install serverless-offline --save-dev</code></p>
<p>And then configure serverless:</p>
<p><b>OfflineHttp/serverless.yaml</b> <a href="https://github.com/tarwn/serverless-examples/tree/master/OfflineHttp/serverless.yaml">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="text"><thead><tr><td colspan="2"  class="head">Text</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="de1"><pre class="de1"># the name of my service - used during deployment
service: example-offline-http
&nbsp;
# serverless plugins to use with serverless
plugins:
&nbsp; - serverless-offline
&nbsp;
# set a default stage in case I don’t provide one
custom:
&nbsp; defaults:
&nbsp; &nbsp; stage: dev
&nbsp;
# some details about the environment and language I'm going to use
provider:
&nbsp; name: aws
&nbsp; runtime: nodejs6.10
&nbsp; region: us-east-1
&nbsp;
# the function entry point and defining the events to trigger it
functions:
&nbsp; events:
&nbsp; &nbsp; handler: functions/eventsHttp.handler
&nbsp; &nbsp; events:
&nbsp; &nbsp; &nbsp; - http:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method: POST
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path: events
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cors: true</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse"># the name of my service - used during deployment
service: example-offline-http

# serverless plugins to use with serverless
plugins:
  - serverless-offline

# set a default stage in case I don’t provide one
custom:
  defaults:
    stage: dev

# some details about the environment and language I'm going to use
provider:
  name: aws
  runtime: nodejs6.10
  region: us-east-1

# the function entry point and defining the events to trigger it
functions:
  events:
    handler: functions/eventsHttp.handler
    events:
      - http:
          method: POST
          path: events
          cors: true</pre></div></div>

<p>Now to test it, we will start serverless and then post some events with curl:</p>
<p>Run <code>serverless offline</code></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="text"><thead><tr><td colspan="2"  class="head">Text</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
</pre></td><td class="de1"><pre class="de1">Serverless: Starting Offline: dev/us-east-1.
Serverless: Routes for events:
Serverless: POST /events
Serverless: Offline listening on http://localhost:3000/</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">Serverless: Starting Offline: dev/us-east-1.
Serverless: Routes for events:
Serverless: POST /events
Serverless: Offline listening on http://localhost:3000/</pre></div></div>

<p>And now we run <code>curl -d "{'key1':'value1', 'key2':'value2'}" -H "Content-Type: application/json" -X POST http://localhost:3000/events </code><br />
And serverless processes the response, and sends back a 200 Success:</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="text"><thead><tr><td colspan="2"  class="head">Text</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
</pre></td><td class="de1"><pre class="de1">Serverless: POST /events (λ: events)
You POSTed an event!
{'key1':'value1', 'key2':'value2'}
Serverless: [200] {&quot;statusCode&quot;:200,&quot;body&quot;:&quot;Success&quot;}</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">Serverless: POST /events (λ: events)
You POSTed an event!
{'key1':'value1', 'key2':'value2'}
Serverless: [200] {"statusCode":200,"body":"Success"}</pre></div></div>

<p>To deploy this to real AWS, we run: <code>serverless deploy</code></p>
<p>Serverless creates the stack for us, creates a CloudFormation file to deploy the Lambda, performs the update, then returns information about the environment and the new endpoint it created. Replace the <code>localhost </code> entry above with that new endpoint and try it out!</p>
<p>We can continue to make changes and redeploy them, later deploys update that same stack. When we&#8217;re done, we can leave it running or remove it with <code>serverless remove</code>.</p>
<h3>2. Adding in Kinesis</h3>
<p>Adding a function to consume events from Kinesis is just as easy as the Http example above, but making this work locally is where it gets tricky. I looked at a few different approaches and eventually had to bundle something up on my own (I may go back to the drawing board and write a serverless-kinesalite plugin soon).</p>
<p><i>Note: From here out I&#8217;ll focus on running offline, you can then layer in the configurations for deploying to real Kinesis (lots of good posts on that).</i></p>
<p>To simulate kinesis locally, we can use the <a href="https://github.com/mhart/kinesalite">kinesalite</a> package. So let&#8217;s start by adding a script to bootstrap a Kinesis stream locally that we can publish to from our Http function above. </p>
<p>First, we can use a YAML file to define some environment-specific environment variables:</p>
<p><b>OfflineHttpAndKinesis/config/env.yml</b> <a href="https://github.com/tarwn/serverless-examples/blob/master/OfflineHttpAndKinesis/config/env.yml">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="text"><thead><tr><td colspan="2"  class="head">Text</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
</pre></td><td class="de1"><pre class="de1">---
offline: 
&nbsp; KINESIS_HOST: 'localhost'
&nbsp; KINESIS_PORT: 4567
&nbsp; KINESIS_REGION: 'us-east-1'
&nbsp; KINESIS_STREAM_NAME_EVENTS: 'offline-events'</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">---
offline: 
  KINESIS_HOST: 'localhost'
  KINESIS_PORT: 4567
  KINESIS_REGION: 'us-east-1'
  KINESIS_STREAM_NAME_EVENTS: 'offline-events'</pre></div></div>

<p>Because I don&#8217;t have a Kinesis plugin for serverless, we&#8217;re going to be running the bootstrap.js script prior to starting <code>serverless offline</code>, so we can use these environment variables across that bootstrap file, the Kinesis Lambda watcher, and in server less for the HTTP functions to publish to.</p>
<p>This is easy to make available in the serverless config, using a coalesce to look at the set for a stage passed in from the command line or falling back to a default value:</p>
<p><b>OfflineHttpAndKinesis/serverless.yml</b> <a href="https://github.com/tarwn/serverless-examples/blob/master/OfflineHttpAndKinesis/serverless.yml">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="text"><thead><tr><td colspan="2"  class="head">Text</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="de1"><pre class="de1">…
&nbsp;
custom:
&nbsp; defaults:
&nbsp; &nbsp; stage: dev
&nbsp;
provider:
&nbsp; name: aws
&nbsp; runtime: nodejs6.10
&nbsp; region: us-east-1
&nbsp; environment: ${file(./config/env.yml):${opt:stage, self:custom.defaults.stage}}
&nbsp;
…</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">…

custom:
  defaults:
    stage: dev

provider:
  name: aws
  runtime: nodejs6.10
  region: us-east-1
  environment: ${file(./config/env.yml):${opt:stage, self:custom.defaults.stage}}

…</pre></div></div>

<p>As we add the bootstrap and kinesis runner, we&#8217;ll pull these environment variables in as well.</p>
<p>Now we&#8217;ll need to add some additional npm packages:</p>
<ul>
<li><code>npm install aws-sdk --save</code> &#8211; For creating the Kinesis stream and publishing in the HTTP Function</li>
<li><code>npm install js-yaml --save-dev</code> &#8211; For parsing the env.yml file for the bootstrap + runner</li>
<li><code>npm install concurrently --save-dev</code> &#8211; To make a clean npm task to start everything</li>
<li><code>npm install -g kinesalite</code> &#8211; Kinesis emulation</li>
</ul>
<p>We&#8217;re ready to add in local kinesis now.</p>
<h3>3. Bootstrap the Stream</h3>
<p>Before we run functions to consume events from the stream, we need to make sure we have started kinesalite and run the bootstrap to ensure the stream is created. We can use the AWS SDK with the env.yml values to get everything ready.</p>
<p><b>OfflineHttpAndKinesis/utility/bootstrap.js</b> <a href="https://github.com/tarwn/serverless-examples/blob/master/OfflineHttpAndKinesis/utility/bootstrap.js">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="de1"><pre class="de1"><span class="kw1">const</span> AWS <span class="sy0">=</span> require<span class="br0">&#40;</span><span class="st0">'aws-sdk'</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">const</span> envFromYaml <span class="sy0">=</span> require<span class="br0">&#40;</span><span class="st0">'./envFromYaml'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
envFromYaml.<span class="me1">config</span><span class="br0">&#40;</span><span class="st0">'./config/env.yml'</span><span class="sy0">,</span><span class="st0">'offline'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">const</span> kinesis <span class="sy0">=</span> <span class="kw1">new</span> AWS.<span class="me1">Kinesis</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
&nbsp; &nbsp; endpoint<span class="sy0">:</span> `$<span class="br0">&#123;</span>process.<span class="me1">env</span>.<span class="me1">KINESIS_HOST</span><span class="br0">&#125;</span><span class="sy0">:</span>$<span class="br0">&#123;</span>process.<span class="me1">env</span>.<span class="me1">KINESIS_PORT</span><span class="br0">&#125;</span>`<span class="sy0">,</span>
&nbsp; &nbsp; region<span class="sy0">:</span> process.<span class="me1">env</span>.<span class="me1">KINESIS_REGION</span><span class="sy0">,</span>
&nbsp; &nbsp; apiVersion<span class="sy0">:</span> <span class="st0">'2013-12-02'</span><span class="sy0">,</span>
&nbsp; &nbsp; sslEnabled<span class="sy0">:</span> <span class="kw2">false</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
ensureStreamExists<span class="br0">&#40;</span>kinesis<span class="sy0">,</span> process.<span class="me1">env</span>.<span class="me1">KINESIS_STREAM_NAME_EVENTS</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">function</span> ensureStreamExists<span class="br0">&#40;</span>kinesis<span class="sy0">,</span> streamName<span class="br0">&#41;</span><span class="br0">&#123;</span>
&nbsp; &nbsp; <span class="kw1">var</span> req <span class="sy0">=</span> kinesis.<span class="me1">createStream</span><span class="br0">&#40;</span><span class="br0">&#123;</span> ShardCount<span class="sy0">:</span> <span class="nu0">1</span><span class="sy0">,</span> StreamName<span class="sy0">:</span> streamName <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; req.<span class="me1">send</span><span class="br0">&#40;</span><span class="kw1">function</span> <span class="br0">&#40;</span>err<span class="sy0">,</span> data<span class="br0">&#41;</span> <span class="br0">&#123;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>err<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>err.<span class="me1">code</span> <span class="sy0">===</span> <span class="st0">'ResourceInUseException'</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="co1">// Stream already exists, so no problem</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span>`Bootstrap<span class="sy0">:</span> Success <span class="sy0">-</span> Kinesis stream <span class="st0">'${streamName}'</span> already exists`<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process.<span class="me1">exit</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">else</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span>`Bootstrap<span class="sy0">:</span> Failed <span class="sy0">-</span> Create Kinesis stream <span class="st0">'${streamName}'</span> failed with error $<span class="br0">&#123;</span>err.<span class="me1">stack</span><span class="br0">&#125;</span>`<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process.<span class="me1">exit</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">else</span> <span class="br0">&#123;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span>`Bootstrap<span class="sy0">:</span> Success <span class="sy0">-</span> Kinesis stream <span class="st0">'${streamName}'</span> created`<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process.<span class="me1">exit</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">const AWS = require('aws-sdk');
const envFromYaml = require('./envFromYaml');

envFromYaml.config('./config/env.yml','offline');

const kinesis = new AWS.Kinesis({
    endpoint: `${process.env.KINESIS_HOST}:${process.env.KINESIS_PORT}`,
    region: process.env.KINESIS_REGION,
    apiVersion: '2013-12-02',
    sslEnabled: false
});

ensureStreamExists(kinesis, process.env.KINESIS_STREAM_NAME_EVENTS);

function ensureStreamExists(kinesis, streamName){
    var req = kinesis.createStream({ ShardCount: 1, StreamName: streamName });
    req.send(function (err, data) { 
        if (err) {
            if (err.code === 'ResourceInUseException') {
                // Stream already exists, so no problem
                console.log(`Bootstrap: Success - Kinesis stream '${streamName}' already exists`);
                process.exit(0);
            }
            else {
                console.log(`Bootstrap: Failed - Create Kinesis stream '${streamName}' failed with error ${err.stack}`);
                process.exit(1);
            }
        }
        else { 
            console.log(`Bootstrap: Success - Kinesis stream '${streamName}' created`);
            process.exit(0);
        }
    });
}</pre></div></div>

<p>At the top, we&#8217;re pulling the environment variables from the YAML file and pushing it into process.env. We then use the variables to define our Kinesis connection and call the homegrown <code>ensureStreamExists</code> function for each Stream we need to create it if it doesn&#8217;t already exist. My other application has multiple streams, so I have additional KINESIS_STREAM_NAME_* environment variables and call <code>ensureStreamExists</code> for each one. </p>
<p>Now to try it out, we can use two console sessions to run kinesalite: <code>kinesalite</code> and then the bootstrap: <code>node utility/bootstrap.js</code>, and we&#8217;ll know it&#8217;s working when we see this:</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="text"><thead><tr><td colspan="2"  class="head">Text</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1">Bootstrap: Success - Kinesis stream 'offline-events' created</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">Bootstrap: Success - Kinesis stream 'offline-events' created</pre></div></div>

<p>We&#8217;ll come back and use concurrently to bundle this into a single, easy npm task.</p>
<h3>4. Add a Kinesis Function</h3>
<p>Adding a new function to consume Kinesis events is as easy as the HTTP function.</p>
<p>Here is the function we&#8217;re adding:</p>
<p><b>OfflineHttpAndKinesis/functions/eventsStream.js</b> <a href="https://github.com/tarwn/serverless-examples/blob/master/OfflineHttpAndKinesis/functions/eventsStream.js">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
</pre></td><td class="de1"><pre class="de1"><span class="st0">'use strict'</span><span class="sy0">;</span>
&nbsp;
module.<span class="me1">exports</span>.<span class="me1">handler</span> <span class="sy0">=</span> <span class="br0">&#40;</span>event<span class="sy0">,</span> context<span class="sy0">,</span> callback<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; event.<span class="me1">Records</span>.<span class="me1">forEach</span><span class="br0">&#40;</span><span class="br0">&#40;</span>record<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">const</span> payload <span class="sy0">=</span> <span class="kw1">new</span> Buffer<span class="br0">&#40;</span>record.<span class="me1">kinesis</span>.<span class="me1">data</span><span class="sy0">,</span> <span class="st0">'base64'</span><span class="br0">&#41;</span>.<span class="me1">toString</span><span class="br0">&#40;</span><span class="st0">'ascii'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">&quot;Received an event: &quot;</span> <span class="sy0">+</span> payload<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; callback<span class="br0">&#40;</span><span class="kw2">null</span><span class="sy0">,</span> `Successfully processed $<span class="br0">&#123;</span>event.<span class="me1">Records</span>.<span class="me1">length</span><span class="br0">&#125;</span> event.`<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">'use strict';

module.exports.handler = (event, context, callback) =&gt; {
    event.Records.forEach((record) =&gt; {
        const payload = new Buffer(record.kinesis.data, 'base64').toString('ascii');
        console.log("Received an event: " + payload);
    });
    callback(null, `Successfully processed ${event.Records.length} event.`);
};</pre></div></div>

<p>This function accepts a batch of Kinesis events, loops through each to read the contents, and then console.log&#8217;s that event content. In later posts, I&#8217;ll go into more complex cases or you can look at the <a href="https://github.com/serverless/examples" title="github: serverless/examples">serverless/examples</a> for ideas.</p>
<p>Now for the hard part.</p>
<p>I&#8217;ve adapted a runner I found online for this part, which is available on <a href="
https://github.com/tarwn/local-kinesis-lambda-runner" title="github: tarwn/local-kinesis-lambda-runner">github</a>. I&#8217;ve fixed some bugs and made changes for wider function support, but I&#8217;m still leaning toward writing a serverless plugin directly instead.</p>
<p><code>npm install git+https://github.com/tarwn/local-kinesis-lambda-runner.git#package --save-dev</code> will install the version I&#8217;m using.</p>
<p>With the package above and the following script, we can bind functions locally to the Kinesis streams with minimal double-typing (there is still a little).</p>
<p><b>OfflineHttpAndKinesis/utility/runOfflineStreamHandlers.js</b> <a href="https://github.com/tarwn/serverless-examples/blob/master/OfflineHttpAndKinesis/utility/runOfflineStreamHandlers.js">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="de1"><pre class="de1"><span class="kw1">const</span> AWS <span class="sy0">=</span> require<span class="br0">&#40;</span><span class="st0">'aws-sdk'</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">const</span> run <span class="sy0">=</span> require<span class="br0">&#40;</span><span class="st0">'@rabblerouser/local-kinesis-lambda-runner'</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">const</span> envFromYaml <span class="sy0">=</span> require<span class="br0">&#40;</span><span class="st0">'./envFromYaml'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
envFromYaml.<span class="me1">config</span><span class="br0">&#40;</span><span class="st0">'./config/env.yml'</span><span class="sy0">,</span><span class="st0">'offline'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">const</span> kinesis <span class="sy0">=</span> <span class="kw1">new</span> AWS.<span class="me1">Kinesis</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
&nbsp; &nbsp; endpoint<span class="sy0">:</span> `$<span class="br0">&#123;</span>process.<span class="me1">env</span>.<span class="me1">KINESIS_HOST</span><span class="br0">&#125;</span><span class="sy0">:</span>$<span class="br0">&#123;</span>process.<span class="me1">env</span>.<span class="me1">KINESIS_PORT</span><span class="br0">&#125;</span>`<span class="sy0">,</span>
&nbsp; &nbsp; region<span class="sy0">:</span> process.<span class="me1">env</span>.<span class="me1">KINESIS_REGION</span><span class="sy0">,</span>
&nbsp; &nbsp; apiVersion<span class="sy0">:</span> <span class="st0">'2013-12-02'</span><span class="sy0">,</span>
&nbsp; &nbsp; sslEnabled<span class="sy0">:</span> <span class="kw2">false</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">const</span> functions <span class="sy0">=</span> <span class="br0">&#91;</span>
&nbsp; &nbsp; <span class="br0">&#123;</span> funName<span class="sy0">:</span> <span class="st0">'EventProcessor'</span><span class="sy0">,</span> handlerPath<span class="sy0">:</span> <span class="st0">'../functions/eventsStream'</span><span class="sy0">,</span> handlerName<span class="sy0">:</span> <span class="st0">'handler'</span><span class="sy0">,</span> kinesisStreamName<span class="sy0">:</span> process.<span class="me1">env</span>.<span class="me1">KINESIS_STREAM_NAME_EVENTS</span> <span class="br0">&#125;</span>
<span class="br0">&#93;</span><span class="sy0">;</span>
initialize<span class="br0">&#40;</span>functions<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// … more code …</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">const AWS = require('aws-sdk');
const run = require('@rabblerouser/local-kinesis-lambda-runner');
const envFromYaml = require('./envFromYaml');

envFromYaml.config('./config/env.yml','offline');

const kinesis = new AWS.Kinesis({
    endpoint: `${process.env.KINESIS_HOST}:${process.env.KINESIS_PORT}`,
    region: process.env.KINESIS_REGION,
    apiVersion: '2013-12-02',
    sslEnabled: false
});
const functions = [
    { funName: 'EventProcessor', handlerPath: '../functions/eventsStream', handlerName: 'handler', kinesisStreamName: process.env.KINESIS_STREAM_NAME_EVENTS }
];
initialize(functions);

// … more code …</pre></div></div>

<p>The key part of this file to edit is the names in the array of functions. <code>funName</code> is a human-readable name you will see in the console output, <code>handlerPath</code> is the relative path to the file the handler is in, <code>handlerName</code> is the module. Everything else is read from the environment variables that are pulled in from the env.yml file and you can add as few or as many entries to the functions array as you like. This file also invalidates the require() cache while it&#8217;s running, so you can make changes to functions and fire new events and the new code will be picked up immediately without restarting anything.</p>
<p>We have one more step before we can bring it all together: publishing events.</p>
<h2>Publishing Events to Kinesis</h2>
<p>We have all the pieces we need to publish events, an HTTP function, the AWS SDK, shared environment variables to identify the streams, so let&#8217;s connect all the dots.</p>
<p>Updating the function to publish the events looks like this:</p>
<p><b>OfflineHttpAndKinesis/functions/eventsHttp.js</b> <a href="https://github.com/tarwn/serverless-examples/blob/master/OfflineHttpAndKinesis/functions/eventsHttp.js">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="de1"><pre class="de1"><span class="st0">'use strict'</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">var</span> AWS <span class="sy0">=</span> require<span class="br0">&#40;</span><span class="st0">'aws-sdk'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; 
<span class="kw1">const</span> kinesis <span class="sy0">=</span> <span class="kw1">new</span> AWS.<span class="me1">Kinesis</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
&nbsp; &nbsp; endpoint<span class="sy0">:</span> `$<span class="br0">&#123;</span>process.<span class="me1">env</span>.<span class="me1">KINESIS_HOST</span><span class="br0">&#125;</span><span class="sy0">:</span>$<span class="br0">&#123;</span>process.<span class="me1">env</span>.<span class="me1">KINESIS_PORT</span><span class="br0">&#125;</span>`<span class="sy0">,</span>
&nbsp; &nbsp; region<span class="sy0">:</span> process.<span class="me1">env</span>.<span class="me1">KINESIS_REGION</span><span class="sy0">,</span>
&nbsp; &nbsp; apiVersion<span class="sy0">:</span> <span class="st0">'2013-12-02'</span><span class="sy0">,</span>
&nbsp; &nbsp; sslEnabled<span class="sy0">:</span> <span class="kw2">false</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
module.<span class="me1">exports</span>.<span class="me1">handler</span> <span class="sy0">=</span> <span class="br0">&#40;</span>event<span class="sy0">,</span> context<span class="sy0">,</span> callback<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> <span class="br0">&#123;</span> 
&nbsp; &nbsp; console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">&quot;You POSTed an event!&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
&nbsp; &nbsp; <span class="kw1">var</span> putReq <span class="sy0">=</span> kinesis.<span class="me1">putRecord</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; Data<span class="sy0">:</span> JSON.<span class="me1">stringify</span><span class="br0">&#40;</span>event.<span class="me1">body</span><span class="br0">&#41;</span><span class="sy0">,</span>
&nbsp; &nbsp; &nbsp; &nbsp; PartitionKey<span class="sy0">:</span> <span class="st0">'0'</span><span class="sy0">,</span>
&nbsp; &nbsp; &nbsp; &nbsp; StreamName<span class="sy0">:</span> process.<span class="me1">env</span>.<span class="me1">KINESIS_STREAM_NAME_EVENTS</span>
&nbsp; &nbsp; <span class="br0">&#125;</span><span class="sy0">,</span> <span class="kw1">function</span> <span class="br0">&#40;</span>err<span class="sy0">,</span> data<span class="br0">&#41;</span> <span class="br0">&#123;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>err<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; callback<span class="br0">&#40;</span>err<span class="sy0">,</span> <span class="br0">&#123;</span> statusCode<span class="sy0">:</span> <span class="nu0">500</span><span class="sy0">,</span> body<span class="sy0">:</span> <span class="st0">&quot;Error writing to kinesis&quot;</span> <span class="br0">&#125;</span> <span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">else</span> <span class="br0">&#123;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; callback<span class="br0">&#40;</span><span class="kw2">null</span><span class="sy0">,</span> <span class="br0">&#123;</span> statusCode<span class="sy0">:</span> <span class="nu0">200</span><span class="sy0">,</span> body<span class="sy0">:</span> <span class="st0">&quot;Ok&quot;</span> <span class="br0">&#125;</span> <span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span>
&nbsp; &nbsp; <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">'use strict';

var AWS = require('aws-sdk');
    
const kinesis = new AWS.Kinesis({
	endpoint: `${process.env.KINESIS_HOST}:${process.env.KINESIS_PORT}`,
	region: process.env.KINESIS_REGION,
	apiVersion: '2013-12-02',
	sslEnabled: false
});

module.exports.handler = (event, context, callback) =&gt; { 
	console.log("You POSTed an event!");

	var putReq = kinesis.putRecord({
		Data: JSON.stringify(event.body),
		PartitionKey: '0',
		StreamName: process.env.KINESIS_STREAM_NAME_EVENTS
	}, function (err, data) { 
		if (err) {
			callback(err, { statusCode: 500, body: "Error writing to kinesis" } );
		}
		else { 
			callback(null, { statusCode: 200, body: "Ok" } );
		}
	});
};</pre></div></div>

<p>Here we&#8217;re initializing the Kinesis connection, then inside the HTTP handler we use <code>putRecord</code> to publish the POSTed event to our Kinesis stream.</p>
<p>The first thing to note is that we initialize the kinesis object outside the function call in both functions. AWS will re-use functions if a lot of events are coming in, so this ensures we don&#8217;t lose time on every single call recreating that necessary resource.</p>
<p>The second to note is that I&#8217;ve hard-coded the PartitionKey. Kinesalite only handles a single partition, but for a real system you would want to replace this with some logic to calculate a PartitionKey, depending on whether you wanted events to consistently be placed in the same partition (maybe all events for a client are always on the same partition) or opt for something more random to level-load the partitions. Lambda will run a single function at a time against each partition, preserving the order of whatever processing you&#8217;re doing (only to the partition, though, not the whole stream).</p>
<p>So, we have a Kinesis emulator, a script to bootstrap the stream, an Http endpoint that pushes an event to kinesis, a function that consumes those events, and a script to run the kinesis function as if it were running under serverless. Time to put it all together!</p>
<h2>Let&#8217;s Go!</h2>
<p>Instead of firing up 4 consoles and running things in the perfect order, we&#8217;ll use <code>concurrently</code> to create a single npm task that will make our lives much easier (and more colorful). Here is the npm task:</p>
<p><b>OfflineHttpAndKinesis/package.json</b> <a href="https://github.com/tarwn/serverless-examples/blob/master/OfflineHttpAndKinesis/package.json">(github)</a></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="javascript"><thead><tr><td colspan="2"  class="head">Javascript</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1">&nbsp; <span class="st0">&quot;scripts&quot;</span><span class="sy0">:</span> <span class="br0">&#123;</span>
&nbsp; &nbsp; <span class="st0">&quot;offline&quot;</span><span class="sy0">:</span> <span class="st0">&quot;concurrently --names <span class="es0">\&quot;</span>KNSL,BOOT,HTTP,STRM<span class="es0">\&quot;</span> -c <span class="es0">\&quot;</span>bgGreen.bold,bgGreen.bold,bgBlue.bold,bgMagenta.bold<span class="es0">\&quot;</span> --kill-others-on-fail <span class="es0">\&quot;</span>kinesalite<span class="es0">\&quot;</span> <span class="es0">\&quot;</span>node utility/bootstrap.js<span class="es0">\&quot;</span> <span class="es0">\&quot;</span>serverless offline start --stage offline<span class="es0">\&quot;</span> <span class="es0">\&quot;</span>node utility/runOfflineStreamHandlers.js<span class="es0">\&quot;</span>&quot;</span>
&nbsp; <span class="br0">&#125;</span><span class="sy0">,</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">  "scripts": {
    "offline": "concurrently --names \"KNSL,BOOT,HTTP,STRM\" -c \"bgGreen.bold,bgGreen.bold,bgBlue.bold,bgMagenta.bold\" --kill-others-on-fail \"kinesalite\" \"node utility/bootstrap.js\" \"serverless offline start --stage offline\" \"node utility/runOfflineStreamHandlers.js\""
  },</pre></div></div>

<p>This sets up 4 names to show on console output, each with a different color, and each with a different command. We&#8217;re going to run kinesalite, the bootstrap, serverless offline, and the offline handler script. If we Ctrl+C, it will force a failure and exit them all.</p>
<p>To start, we just need to type <code>npm run offline</code>.</p>
<p>Initial output:<br />
<div id="attachment_8868" style="width: 796px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2018/01/OfflineHttpAndKinesisStartupOutput.png" alt="Offline Lambda and Kinesis Output" width="786" height="391" class="size-full wp-image-8868" srcset="/wp-content/uploads/2018/01/OfflineHttpAndKinesisStartupOutput.png 786w, /wp-content/uploads/2018/01/OfflineHttpAndKinesisStartupOutput-300x149.png 300w, /wp-content/uploads/2018/01/OfflineHttpAndKinesisStartupOutput-768x382.png 768w" sizes="(max-width: 786px) 100vw, 786px" /><p class="wp-caption-text">Offline Lambda and Kinesis Output</p></div></p>
<p>I&#8217;ve been ignoring the initial error that gets kicked out by the stream handler script, it doesn&#8217;t cause any issues at this time. (It&#8217;s adding to the &#8216;maybe I&#8217;ll write a plugin&#8217; balance, though).</p>
<p>And after running the curl command to add an event:<br />
<div id="attachment_8867" style="width: 666px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2018/01/OfflineHttpAndKinesisOutput.png" alt="cUrl =&gt; HTTP Function =&gt; Kinesis Stream =&gt; Kinesis Function" width="656" height="161" class="size-full wp-image-8867" srcset="/wp-content/uploads/2018/01/OfflineHttpAndKinesisOutput.png 656w, /wp-content/uploads/2018/01/OfflineHttpAndKinesisOutput-300x74.png 300w" sizes="(max-width: 656px) 100vw, 656px" /><p class="wp-caption-text">cUrl => HTTP Function => Kinesis Stream => Kinesis Function</p></div></p>
<p>So we have two pretty simple bits of code and we&#8217;re consuming events (with the first 1,000,000 runs/month being free). There were some complicated bits, but that was all for offline emulation. </p>
<p>Hopefully this was helpful, next up I&#8217;ll dive into the project that sparked this work and also adds in some DynamoDB and running an entire Express instance in a single HTTP Function (not recommend, by the way).</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/enterprisedev/cloud/serverless-http-kinesis-lambdas-with-offline-development/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
	</channel>
</rss>
