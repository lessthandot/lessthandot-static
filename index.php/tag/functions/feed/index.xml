<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>functions &#8211; LessthanDot</title>
	<atom:link href="/index.php/tag/functions/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>A Technical Community for IT Professionals</description>
	<lastBuildDate>Sat, 09 Mar 2019 12:50:36 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.1</generator>
	<item>
		<title>TRY_CONVERT in SQL Server Denali CTP3</title>
		<link>/index.php/datamgmt/datadesign/try_convert-in-sql-server-denali/</link>
		<comments>/index.php/datamgmt/datadesign/try_convert-in-sql-server-denali/#respond</comments>
		<pubDate>Tue, 19 Jul 2011 22:54:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[denali]]></category>
		<category><![CDATA[functions]]></category>
		<category><![CDATA[sql server]]></category>
		<category><![CDATA[try_convert]]></category>

		<guid isPermaLink="false">/index.php/2011/07/try_convert-in-sql-server-denali/</guid>
		<description><![CDATA[TRY_CONVERT  is a new function in SQL Server Denali CTP3, TRY_CONVERT   enables you to test if a value can be converted to a specific data type, TRY_CONVERT  returns a value cast to the specified data type if the cast succeeds; otherwise, TRY_CONVERT&#8230;]]></description>
				<content:encoded><![CDATA[<p>TRY_CONVERT  is a new function in SQL Server Denali CTP3, TRY_CONVERT   enables you to test if a value can be converted to a specific data type, TRY_CONVERT  returns a value cast to the specified data type if the cast succeeds; otherwise, TRY_CONVERT   returns null.</p>
<p>Here is what Books On Line has to say about TRY_CONVERT</p>
<p><em>TRY_CONVERT takes the value passed to it and tries to convert it to the specified data_type. If the cast succeeds, TRY_CONVERT returns the value as the specified data_type; if an error occurs, null is returned. However if you request a conversion that is explicitly not permitted, then TRY_CONVERT fails with an error.</p>
<p><strong>Arguments</strong></p>
<p><strong>data_type [ ( length ) ]</strong><br />
The data type into which to cast expression.</p>
<p><strong>expression</strong><br />
The value to be cast.</p>
<p><strong>style</strong><br />
Optional integer expression that specifies how the TRY_CONVERT function is to translate expression.</p>
<p>style accepts the same values as the style parameter of the CONVERT function. </p>
<p>The range of acceptable values is determined by the value of data_type. If style is null, then TRY_CONVERT returns null.</em></p>
<p>Here is what the syntax looks like</p>
<pre>TRY_CONVERT ( data_type [ ( length ) ], expression [, style ] )</pre>
<p>Let&#8217;s take a look how this all works, I will create a table and inserts some values</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="de1"><pre class="de1"><span class="kw1">create</span> <span class="kw1">table</span> #test<span class="br0">&#40;</span>SomeCol <span class="kw1">varchar</span><span class="br0">&#40;</span><span class="nu0">100</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
GO
&nbsp;
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'1'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'.'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'$'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'ddd'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'---'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'000'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'123aaa1'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'2de'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'(((('</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'20110230'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'20110228'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'14:58'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'16000228'</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #test <span class="kw1">values</span><span class="br0">&#40;</span><span class="st0">'0.12345678901'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">create table #test(SomeCol varchar(100))
GO

insert #test values('1')
insert #test values('.')
insert #test values('$')
insert #test values('ddd')
insert #test values('---')
insert #test values('000')
insert #test values('123aaa1')
insert #test values('2de')
insert #test values('((((')
insert #test values('20110230')
insert #test values('20110228')
insert #test values('14:58')
insert #test values('16000228')
insert #test values('0.12345678901')</pre></div></div>

<p>Now, I will try to convert the values in the table to various data types</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> SomeCol,
&nbsp; &nbsp; &nbsp; &nbsp;TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">float</span>,SomeCol<span class="br0">&#41;</span> <span class="kw1">as</span> <span class="kw1">float</span>,
&nbsp; &nbsp; &nbsp; &nbsp;TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">date</span>,SomeCol<span class="br0">&#41;</span> <span class="kw1">as</span> <span class="kw1">date</span>,
&nbsp; &nbsp; &nbsp; &nbsp;TRY_CONVERT<span class="br0">&#40;</span>datetime2,SomeCol<span class="br0">&#41;</span> <span class="kw1">as</span> datetime2,
&nbsp; &nbsp; &nbsp; &nbsp;TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">datetime</span>,SomeCol<span class="br0">&#41;</span> <span class="kw1">as</span> <span class="kw1">datetime</span>,
&nbsp; &nbsp; &nbsp; &nbsp;TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">time</span>,SomeCol<span class="br0">&#41;</span> <span class="kw1">as</span> <span class="kw1">time</span>,
&nbsp; &nbsp; &nbsp; &nbsp;TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">numeric</span><span class="br0">&#40;</span><span class="nu0">30</span>,<span class="nu0">10</span><span class="br0">&#41;</span>,SomeCol<span class="br0">&#41;</span> <span class="kw1">as</span> <span class="kw1">numeric</span>,
&nbsp; &nbsp; &nbsp; &nbsp;TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">int</span>,SomeCol<span class="br0">&#41;</span> <span class="kw1">as</span> <span class="kw1">int</span>
<span class="kw1">FROm</span> #test</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select SomeCol,
	   TRY_CONVERT(float,SomeCol) as float,
	   TRY_CONVERT(date,SomeCol) as date,
	   TRY_CONVERT(datetime2,SomeCol) as datetime2,
	   TRY_CONVERT(datetime,SomeCol) as datetime,
	   TRY_CONVERT(time,SomeCol) as time,
	   TRY_CONVERT(numeric(30,10),SomeCol) as numeric,
	   TRY_CONVERT(int,SomeCol) as int
FROm #test</pre></div></div>

<p>Here is the result</p>
<div class="tables">
<table>
<tr>
<th>	SomeCol	</th>
<th>	float	</th>
<th>	date	</th>
<th>	datetime2	</th>
<th>	datetime	</th>
<th>	time	</th>
<th>	numeric	</th>
<th>	int	</th>
<tr>
<tr>
<td>	1	</td>
<td>	1	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	1	</td>
<td>	1	</td>
</tr>
<tr>
<td>	.	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
</tr>
<tr>
<td>	$	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
</tr>
<tr>
<td>	ddd	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
</tr>
<tr>
<td>	&#8212;	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
</tr>
<tr>
<td>	0	</td>
<td>	0	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	0	</td>
<td>	0	</td>
</tr>
<tr>
<td>	123aaa1	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
</tr>
<tr>
<td>	2de	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
</tr>
<tr>
<td>	((((	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
</tr>
<tr>
<td>	20110230	</td>
<td>	20110230	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	20110230.0000000000</td>
<td>	20110230	</td>
</tr>
<tr>
<td>	20110228	</td>
<td>	20110228	</td>
<td>	2011-02-28	</td>
<td>	00:00.0	</td>
<td>	00:00.0	</td>
<td>	00:00.0	</td>
<td>	20110228.0000000000</td>
<td>	20110228	</td>
</tr>
<tr>
<td>	14:58	</td>
<td>	NULL	</td>
<td>	1900-01-01	</td>
<td>	1900-01-01 14:58:00.0000000	</td>
<td>	1900-01-01 14:58:00.000	</td>
<td>	14:58:00.0000000	</td>
<td>	NULL	</td>
<td>	NULL	</td>
</tr>
<tr>
<td>	16000228	</td>
<td>	16000228	</td>
<td>	1600-02-28	</td>
<td>	1600-02-28 00:00:00.0000000	</td>
<td>	NULL	</td>
<td>	00:00.0	</td>
<td>	16000228.0000000000</td>
<td>	16000228	</td>
</tr>
<tr>
<td>	0.12345678901</td>
<td>	0.12345678901</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	NULL	</td>
<td>	0.123456789	</td>
<td>	NULL	</td>
</tr>
</tr>
</tr>
</table></div>
<p>Pretty neat, as you can see if you for example try to convert 16000228	to a datetime you will get 0 since it falls out of the acceptable datetime range, for datetime2 and date you do get a value back. The conversion to numeric(30,10) also shows that the value is truncated after 10 decimals. This function is pretty handy since you won&#8217;t get the conversion errors you would get if you try to convert it with the regular convert function</p>
<p>You can also use CASE or IIF to return if the value can or cannot be converted, below is an example of both</p>
<p><strong>CASE</strong></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> 
&nbsp; &nbsp; <span class="kw1">CASE</span> <span class="kw1">WHEN</span> TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">float</span>,<span class="st0">'bla'</span><span class="br0">&#41;</span> <span class="kw1">IS</span> <span class="sy0">NULL</span> 
&nbsp; &nbsp; <span class="kw1">THEN</span> <span class="st0">'Cast failed'</span>
&nbsp; &nbsp; <span class="kw1">ELSE</span> <span class="st0">'Cast succeeded'</span>
<span class="kw1">END</span> 
<span class="kw1">UNION</span>
<span class="kw1">SELECT</span> 
&nbsp; &nbsp; <span class="kw1">CASE</span> <span class="kw1">WHEN</span> TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">float</span>,<span class="st0">'1'</span><span class="br0">&#41;</span> <span class="kw1">IS</span> <span class="sy0">NULL</span> 
&nbsp; &nbsp; <span class="kw1">THEN</span> <span class="st0">'Cast failed'</span>
&nbsp; &nbsp; <span class="kw1">ELSE</span> <span class="st0">'Cast succeeded'</span>
<span class="kw1">END</span> </pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT 
    CASE WHEN TRY_CONVERT(float,'bla') IS NULL 
    THEN 'Cast failed'
    ELSE 'Cast succeeded'
END 
UNION
SELECT 
    CASE WHEN TRY_CONVERT(float,'1') IS NULL 
    THEN 'Cast failed'
    ELSE 'Cast succeeded'
END </pre></div></div>

<p>&#8212;&#8212;&#8211;<br />
Cast failed<br />
Cast succeeded</p>
<p><strong>IIF</strong></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> IIF<span class="br0">&#40;</span>TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">float</span>,<span class="st0">'bla'</span><span class="br0">&#41;</span><span class="kw1">IS</span> <span class="sy0">NULL</span>,<span class="st0">'Cast failed'</span>,<span class="st0">'Cast succeeded'</span><span class="br0">&#41;</span>
<span class="kw1">UNION</span>
<span class="kw1">SELECT</span> IIF<span class="br0">&#40;</span>TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">float</span>,<span class="st0">'1'</span><span class="br0">&#41;</span><span class="kw1">IS</span> <span class="sy0">NULL</span>,<span class="st0">'Cast failed'</span>,<span class="st0">'Cast succeeded'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT IIF(TRY_CONVERT(float,'bla')IS NULL,'Cast failed','Cast succeeded')
UNION
SELECT IIF(TRY_CONVERT(float,'1')IS NULL,'Cast failed','Cast succeeded')</pre></div></div>

<p>&#8212;&#8212;&#8211;<br />
Cast failed<br />
Cast succeeded</p>
<p>Be aware that if you pass in a NULL, then NULL is returned</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> &nbsp;TRY_CONVERT<span class="br0">&#40;</span> <span class="kw1">numeric</span><span class="br0">&#40;</span><span class="nu0">30</span>,<span class="nu0">10</span><span class="br0">&#41;</span>,null<span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select  TRY_CONVERT( numeric(30,10),null)</pre></div></div>

<p></p>
<p>TRY_CONVERT is something that was long overdue and it will eliminate a lot of issues, no more need for custom IsNumeric and IsInt functions, this one does it all.</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/try_convert-in-sql-server-denali/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Format function in SQL Server Denali CTP3</title>
		<link>/index.php/datamgmt/datadesign/format-function-in-sql-server/</link>
		<comments>/index.php/datamgmt/datadesign/format-function-in-sql-server/#respond</comments>
		<pubDate>Fri, 15 Jul 2011 08:30:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[denali]]></category>
		<category><![CDATA[format]]></category>
		<category><![CDATA[functions]]></category>
		<category><![CDATA[localization]]></category>
		<category><![CDATA[sql server]]></category>

		<guid isPermaLink="false">/index.php/2011/07/format-function-in-sql-server/</guid>
		<description><![CDATA[SQL Server Denali CTP3 brings a couple of new functions, one of these is the FORMAT  function

The syntax of the format function looks like this

FORMAT ( value, format [, culture ] )

Here is what Books On Line has to say about the arguments that&#8230;]]></description>
				<content:encoded><![CDATA[<p>SQL Server Denali CTP3 brings a couple of new functions, one of these is the FORMAT  function</p>
<p>The syntax of the format function looks like this</p>
<p>FORMAT ( value, format [, culture ] )</p>
<p>Here is what Books On Line has to say about the arguments that you can pass in</p>
<p><em><strong>value</strong><br />
Expression of a supported data type to format.</p>
<p><strong>format</strong><br />
nvarchar format pattern.</p>
<p>The format argument must contain a valid .NET Framework format string, either as a standard format string (for example, &#8220;C&#8221; or &#8220;D&#8221;), or as a pattern of custom characters for dates and numeric values (for example, &#8220;MMMM dd, yyyy (dddd)&#8221;). Composite formatting is not supported. For a full explanation of these formatting patterns, please consult the.NET Framework documentation on string formatting in general, custom date and time formats, and custom number formats. A good starting point is the topic, &#8220;<a href="http://msdn.microsoft.com/en-us/library/26etazsy.aspx">Formatting Types.</a>&#8221;</p>
<p><strong>culture</strong><br />
Optional nvarchar argument specifying a culture.</p>
<p>If the culture argument is not provided, then the language of the current session is used. This language is set either implicitly, or explicitly by using the SET LANGUAGE statement. culture accepts any culture supported by the .NET Framework as an argument; it is not limited to the languages explicitly supported by SQL Server . If the culture argument is not valid, FORMAT raises an error.</em></p>
<p>
Before we continue, I recommend that you visit the <a href="http://msdn.microsoft.com/en-us/goglobal/bb896001.aspx">National Language Support (NLS) API Reference</a> page to see all the locales that are available</p>
<p>If you are a .NET programmer then this function should look very familiar to you</p>
<p>Let&#8217;s take a look at how it all works, first let&#8217;s create a table and inserts some locales info so that it will be easier to show the different output later</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> Locales<span class="br0">&#40;</span>locale <span class="kw1">varchar</span><span class="br0">&#40;</span><span class="nu0">100</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> Locales
<span class="kw1">select</span> <span class="st0">'en-US'</span> &nbsp; <span class="co1">--USA</span>
<span class="kw1">union</span>
<span class="kw1">select</span> <span class="st0">'nl'</span> <span class="co1">--Netherlands</span>
<span class="kw1">union</span>
<span class="kw1">select</span> <span class="st0">'fr'</span> &nbsp;<span class="co1">--France</span>
<span class="kw1">union</span>
<span class="kw1">select</span> <span class="st0">'de'</span> <span class="co1">--Germany</span>
<span class="kw1">union</span>
<span class="kw1">select</span> <span class="st0">'no'</span> &nbsp;<span class="co1">--Norway</span>
<span class="kw1">union</span>
<span class="kw1">select</span> <span class="st0">'ru'</span> <span class="co1">--Russia</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE Locales(locale varchar(100))
insert Locales
select 'en-US'   --USA
union
select 'nl' --Netherlands
union
select 'fr'  --France
union
select 'de' --Germany
union
select 'no'  --Norway
union
select 'ru' --Russia</pre></div></div>

<p>Now, let&#8217;s format some dates</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1"><span class="kw1">DECLARE</span> @d <span class="kw1">DATETIME</span> <span class="sy0">=</span> <span class="st0">'01/01/2011'</span>;
&nbsp;
<span class="kw1">select</span> locale,F<span class="sy0">OR</span>MAT <span class="br0">&#40;</span> @d, <span class="st0">'d'</span>, locale <span class="br0">&#41;</span> <span class="kw1">AS</span> <span class="kw1">Result</span>,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F<span class="sy0">OR</span>MAT<span class="br0">&#40;</span> @d, <span class="st0">'yyyy-MM-dd'</span>, locale <span class="br0">&#41;</span> Result2
<span class="kw1">from</span> Locales</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">DECLARE @d DATETIME = '01/01/2011';

select locale,FORMAT ( @d, 'd', locale ) AS Result,
              FORMAT( @d, 'yyyy-MM-dd', locale ) Result2
from Locales</pre></div></div>

<p>Here is what the output looks like, as you can see if you use specific formatting, the output is the same no matter what the locale is</p>
<div class="tables">
<table>
<tr>
<th>locale</th>
<th>	Result</th>
<th>Result2</th>
</tr>
<tr>
<td>de</td>
<td>	01.01.2011</td>
<td>	2011-01-01</td>
</tr>
<tr>
<td>en-US</td>
<td>	1/1/2011</td>
<td>	2011-01-01</td>
</tr>
<tr>
<td>fr</td>
<td>	01/01/2011</td>
<td>	2011-01-01</td>
</tr>
<tr>
<td>nl</td>
<td>	1-1-2011</td>
<td>	2011-01-01</td>
</tr>
<tr>
<td>no</td>
<td>	01.01.2011</td>
<td>	2011-01-01</td>
</tr>
<tr>
<td>ru</td>
<td>	01.01.2011</td>
<td>	2011-01-01</td>
</tr>
</table></div>
<p>Let&#8217;s look at another example, this one will format currency</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> locale,F<span class="sy0">OR</span>MAT <span class="br0">&#40;</span> <span class="nu0">100</span>, <span class="st0">'c'</span>, locale <span class="br0">&#41;</span> <span class="kw1">AS</span> <span class="kw1">Result</span>
<span class="kw1">from</span> Locales</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select locale,FORMAT ( 100, 'c', locale ) AS Result
from Locales</pre></div></div>

<p></p>
<div class="tables">
<table>
<tr>
<th>locale</th>
<th>	Result</th>
</tr>
<tr>
<td>de</td>
<td>	100,00 €</td>
</tr>
<tr>
<td>en-US</td>
<td>	$100.00</td>
</tr>
<tr>
<td>fr</td>
<td>	100,00 €</td>
</tr>
<tr>
<td>nl</td>
<td>	€ 100,00</td>
</tr>
<tr>
<td>no</td>
<td>	kr 100,00</td>
</tr>
<tr>
<td>ru</td>
<td>	100,00&#1088;.</td>
</tr>
</table></div>
<p>As you can see the currency symbol is different depending on what locale has been used, the symbol will also alternate between the end or the start of the output depending again on the locale</p>
<p>You can also specify the number of characters after the decimal point</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> locale,F<span class="sy0">OR</span>MAT <span class="br0">&#40;</span> <span class="nu0">100.34</span>, <span class="st0">'C1'</span>, locale <span class="br0">&#41;</span> <span class="kw1">AS</span> Result1,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F<span class="sy0">OR</span>MAT <span class="br0">&#40;</span> <span class="nu0">100.34</span>, <span class="st0">'C2'</span>, locale <span class="br0">&#41;</span> <span class="kw1">AS</span> Result2,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F<span class="sy0">OR</span>MAT <span class="br0">&#40;</span> <span class="nu0">100.34</span>, <span class="st0">'C3'</span>, locale <span class="br0">&#41;</span> <span class="kw1">AS</span> Result3,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F<span class="sy0">OR</span>MAT <span class="br0">&#40;</span> <span class="nu0">100.34</span>, <span class="st0">'C4'</span>, locale <span class="br0">&#41;</span> <span class="kw1">AS</span> Result4
<span class="kw1">from</span> Locales</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select locale,FORMAT ( 100.34, 'C1', locale ) AS Result1,
			  FORMAT ( 100.34, 'C2', locale ) AS Result2,
			  FORMAT ( 100.34, 'C3', locale ) AS Result3,
			  FORMAT ( 100.34, 'C4', locale ) AS Result4
from Locales</pre></div></div>

<p></p>
<div class="tables">
<table>
<tr>
<th>locale</th>
<th>	Result1</th>
<th>	Result2</th>
<th>	Result3</th>
<th>	Result4</th>
</tr>
<tr>
<td>de</td>
<td>	100,3 €	</td>
<td>100,34 €	</td>
<td>100,340 €	</td>
<td>100,3400 €</td>
</tr>
<tr>
<td>en-US</td>
<td>	$100.3	</td>
<td>$100.34	</td>
<td>$100.340	</td>
<td>$100.3400</td>
</tr>
<tr>
<td>fr</td>
<td>	100,3 €	</td>
<td>100,34 €	</td>
<td>100,340 €	</td>
<td>100,3400 €</td>
</tr>
<tr>
<td>nl</td>
<td>	€ 100,3	 </td>
<td>€ 100,34	</td>
<td>€ 100,340	</td>
<td>€ 100,3400</td>
</tr>
<tr>
<td>no</td>
<td>	kr 100,3	</td>
<td>kr 100,34	</td>
<td>kr 100,340	</td>
<td>kr 100,3400</td>
</tr>
<tr>
<td>ru</td>
<td>	100,3&#1088;.	</td>
<td>100,34&#1088;.	</td>
<td>100,340&#1088;.	</td>
<td>100,3400&#1088;.</td>
</tr>
</table></div>
<p>There you have it, formatted exactly like you want. I think the FORMAT function is a welcome addition, it will make formatting much easier than before when we have to mess around with CAST or CONVERT and style arguments</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/format-function-in-sql-server/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Concat function in SQL Server Denali CTP3</title>
		<link>/index.php/datamgmt/datadesign/concat-function-in-sql-server/</link>
		<comments>/index.php/datamgmt/datadesign/concat-function-in-sql-server/#comments</comments>
		<pubDate>Fri, 15 Jul 2011 07:53:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[concat]]></category>
		<category><![CDATA[denali]]></category>
		<category><![CDATA[functions]]></category>
		<category><![CDATA[sql server]]></category>

		<guid isPermaLink="false">/index.php/2011/07/concat-function-in-sql-server/</guid>
		<description><![CDATA[SQL Server Denali CTP3 brings a couple of new functions, one of these is the CONCAT function. The CONCAT  function returns a string that is the result of concatenating two or more string values.

The syntax of the CONCAT function looks like this

CO&#8230;]]></description>
				<content:encoded><![CDATA[<p>SQL Server Denali CTP3 brings a couple of new functions, one of these is the CONCAT function. The CONCAT  function returns a string that is the result of concatenating two or more string values.</p>
<p>The syntax of the CONCAT function looks like this</p>
<pre>CONCAT ( string_value1, string_value2 [, string_valueN ] )</pre>
<p>You can concatenate between 2 and 254 values, if you use for example only one value, you will get an error</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> CONCAT <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select CONCAT (1)</pre></div></div>

<p>Msg 189, Level 15, State 1, Line 1<br />
The concat function requires 2 to 254 arguments.</p>
<p>Here is some additional information</p>
<p><em>CONCAT takes a variable number of string arguments and concatenates them into a single string. It requires a minimum of two input values; otherwise, an error is raised. All arguments are implicitly converted to string types and then concatenated. Null values are implicitly converted to an empty string. If all the arguments are null, then an empty string of type varchar(1) is returned. The implicit conversion to strings follows the existing rules for data type conversions</em></p>
<p>Let&#8217;s run some code and do some comparison with a regular string concatenation by using the @val + @val2</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
</pre></td><td class="de1"><pre class="de1"><span class="kw1">declare</span> @i <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'1'</span>
<span class="kw1">declare</span> @i3 <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'3'</span>
&nbsp;
&nbsp;
<span class="kw1">select</span> CONCAT <span class="br0">&#40;</span>@i,@i3<span class="br0">&#41;</span>
<span class="kw1">select</span> @i<span class="sy0">+</span> &nbsp;@i3</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">declare @i char(1)  ='1'
declare @i3 char(1)  ='3'


select CONCAT (@i,@i3)
select @i+  @i3</pre></div></div>

<p>&#8212;&#8212;<br />
13<br />
13</p>
<p>As you can see both of these return the value 13</p>
<p>What happens if one of the data type is an integer?</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
</pre></td><td class="de1"><pre class="de1"><span class="kw1">declare</span> @i <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'1'</span>
<span class="kw1">declare</span> @i3 <span class="kw1">int</span> &nbsp;<span class="sy0">=</span><span class="st0">'3'</span>
&nbsp;
&nbsp;
<span class="kw1">select</span> CONCAT<span class="br0">&#40;</span>@i,@i3<span class="br0">&#41;</span>
<span class="kw1">select</span> @i<span class="sy0">+</span> &nbsp;@i3</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">declare @i char(1)  ='1'
declare @i3 int  ='3'


select CONCAT(@i,@i3)
select @i+  @i3</pre></div></div>

<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
13<br />
4</p>
<p>As you can see CONCAT concatenates the values while the other method does arithmetic and adds the values since one of them is an integer</p>
<p>Here is another example that does the same</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">declare</span> @i <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'1'</span>
<span class="kw1">declare</span> @i2 <span class="kw1">int</span> &nbsp;<span class="sy0">=</span><span class="nu0">2</span>
<span class="kw1">declare</span> @i3 <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'3'</span>
&nbsp;
&nbsp;
<span class="kw1">select</span> CONCAT<span class="br0">&#40;</span>@i,@i2,@i3<span class="br0">&#41;</span>
&nbsp;
<span class="kw1">select</span> @i<span class="sy0">+</span> @i2<span class="sy0">+</span> @i3</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">declare @i char(1)  ='1'
declare @i2 int  =2
declare @i3 char(1)  ='3'


select CONCAT(@i,@i2,@i3)

select @i+ @i2+ @i3</pre></div></div>

<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
123<br />
6</p>
<p>What happens if one of the values is NULL?</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">declare</span> @i <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'1'</span>
<span class="kw1">declare</span> @i2 <span class="kw1">int</span> &nbsp;<span class="sy0">=</span>null
<span class="kw1">declare</span> @i3 <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'3'</span>
&nbsp;
&nbsp;
<span class="kw1">select</span> CONCAT<span class="br0">&#40;</span>@i,@i2,@i3<span class="br0">&#41;</span>
&nbsp;
<span class="kw1">select</span> @i<span class="sy0">+</span> @i2<span class="sy0">+</span> @i3</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">declare @i char(1)  ='1'
declare @i2 int  =null
declare @i3 char(1)  ='3'


select CONCAT(@i,@i2,@i3)

select @i+ @i2+ @i3</pre></div></div>

<p>&#8212;&#8212;&#8212;&#8212;&#8211;<br />
13<br />
null</p>
<p>As you can see the CONCAT functions makes the NULL an empty string while the other method does not.</p>
<p>In order to get the same output, the old method is a lot more code</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
</pre></td><td class="de1"><pre class="de1"><span class="kw1">declare</span> @i <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'1'</span>
<span class="kw1">declare</span> @i2 <span class="kw1">int</span> &nbsp;<span class="sy0">=</span>null
<span class="kw1">declare</span> @i3 <span class="kw1">char</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span><span class="st0">'3'</span>
&nbsp;
&nbsp;
<span class="kw1">select</span> CONCAT<span class="br0">&#40;</span>@i,@i2,@i3<span class="br0">&#41;</span>
&nbsp;
&nbsp;
<span class="kw1">select</span> isnull<span class="br0">&#40;</span>@i,<span class="st0">''</span><span class="br0">&#41;</span><span class="sy0">+</span> isnull<span class="br0">&#40;</span><span class="kw1">convert</span><span class="br0">&#40;</span><span class="kw1">varchar</span><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span>,@i2<span class="br0">&#41;</span>,<span class="st0">''</span><span class="br0">&#41;</span><span class="sy0">+</span> isnull<span class="br0">&#40;</span>@i3,<span class="st0">''</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">declare @i char(1)  ='1'
declare @i2 int  =null
declare @i3 char(1)  ='3'


select CONCAT(@i,@i2,@i3)


select isnull(@i,'')+ isnull(convert(varchar(10),@i2),'')+ isnull(@i3,'')</pre></div></div>

<p>&#8212;&#8211;<br />
13<br />
13</p>
<p>So what is your opinion, are you happy that the CONCAT function has been added to SQL Server?</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/concat-function-in-sql-server/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
		</item>
		<item>
		<title>DATEFROMPARTS  and DATETIMEFROMPARTS functions in SQL Server Denali CTP3</title>
		<link>/index.php/datamgmt/datadesign/datefromparts-and-datetimefromparts-functions-in/</link>
		<comments>/index.php/datamgmt/datadesign/datefromparts-and-datetimefromparts-functions-in/#comments</comments>
		<pubDate>Wed, 13 Jul 2011 17:22:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[dates]]></category>
		<category><![CDATA[denali]]></category>
		<category><![CDATA[functions]]></category>

		<guid isPermaLink="false">/index.php/2011/07/datefromparts-and-datetimefromparts-functions-in/</guid>
		<description><![CDATA[Function 
         
         
          Syntax 
         
         
          Return value 
         
         
          Return data type 
         
        
       
       
         
           
            DATEFROMPARTS&#8230;]]></description>
				<content:encoded><![CDATA[<p>SQL Server Denali CTP3 has added a bunch of date/time functions.</p>
<p>In the <a href="/index.php/DataMgmt/DBProgramming/MSSQLServer/a-quick-look-at-the-1">A Quick look at the new EOMONTH function in SQL Server Denali CTP3</a> post I have already looked at the EOMONTH  function. In this post I want to take a look at the DATEFROMPARTS  and DATETIMEFROMPARTS functions</p>
<h2>DATEFROMPARTS</h2>
<p>If you are a .NET programmer then you probably know that you can construct a date by passing a bunch of integers to the DateTime constructor. To create a date of July, 13, 2011 you would do something like this</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="csharp"><thead><tr><td colspan="2"  class="head">C#</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1">DateTime date1 <span class="sy0">=</span> <span class="kw3">new</span> DateTime<span class="br0">&#40;</span><span class="nu0">2011</span>, <span class="nu0">7</span>, <span class="nu0">13</span><span class="br0">&#41;</span><span class="sy0">;</span>
Console<span class="sy0">.</span><span class="me1">WriteLine</span><span class="br0">&#40;</span>date1<span class="sy0">.</span><span class="me1">ToString</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">DateTime date1 = new DateTime(2011, 7, 13);
Console.WriteLine(date1.ToString());</pre></div></div>

<p>7/13/2011 12:00:00 AM</p>
<p>In SQL Server, you can do something similar now with the DATEFROMPARTS  function. Here is what the syntax looks like</p>
<p><em>DATEFROMPARTS ( year, month, day )</em></p>
<p>Here is an example</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> DATEFROMPARTS <span class="br0">&#40;</span> <span class="nu0">2011</span>, <span class="nu0">7</span>, <span class="nu0">13</span> <span class="br0">&#41;</span> <span class="kw1">AS</span> <span class="kw1">Result</span>;</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DATEFROMPARTS ( 2011, 7, 13 ) AS Result;</pre></div></div>

<p>2011-07-13</p>
<p>If you pass in all ones, you will get year 1, month 1 and day 1</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> DATEFROMPARTS<span class="br0">&#40;</span><span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DATEFROMPARTS(1,1,1)</pre></div></div>

<p>0001-01-01</p>
<p>You can of course also pass in functions, so to get the first day of the current year and month, you would do this</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> DATEFROMPARTS<span class="br0">&#40;</span><span class="kw1">year</span><span class="br0">&#40;</span><span class="kw2">getdate</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>,<span class="kw1">month</span><span class="br0">&#40;</span><span class="kw2">getdate</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>,<span class="nu0">1</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DATEFROMPARTS(year(getdate()),month(getdate()),1)</pre></div></div>

<p>2011-07-01</p>
<p>Here is what BOL has to say about DATEFROMPARTS:</p>
<p><em>DATEFROMPARTS returns a date value with the date portion set to the specified year, month and day, and the time portion set to the default. If the arguments are not valid, then an error is raised. If required arguments are null, then null is returned.</em></p>
<h2>DATETIMEFROMPARTS </h2>
<p>The syntax for DATETIMEFROMPARTS  looks like this</p>
<p><em>DATETIMEFROMPARTS ( year, month, day, hour, minute, seconds, milliseconds )</em></p>
<p>If you were to pass in the same values as for date into the DATETIMEFROMPARTS function you will get an error</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> DATETIMEFROMPARTS<span class="br0">&#40;</span><span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DATETIMEFROMPARTS(1,1,1)</pre></div></div>

<p>Msg 174, Level 15, State 1, Line 1<br />
The datetimefromparts function requires 7 argument(s).</p>
<p>It would have been nice that the function returned you the datetime with every thing else as 0 instead of giving an error. </p>
<p>So if you have this in .NET</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="csharp"><thead><tr><td colspan="2"  class="head">C#</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1">DateTime date1 <span class="sy0">=</span> <span class="kw3">new</span> DateTime<span class="br0">&#40;</span><span class="nu0">2011</span>, <span class="nu0">7</span>, <span class="nu0">13</span>, <span class="nu0">16</span>, <span class="nu0">32</span>, <span class="nu0">18</span>, <span class="nu0">500</span><span class="br0">&#41;</span><span class="sy0">;</span>
Console<span class="sy0">.</span><span class="me1">WriteLine</span><span class="br0">&#40;</span>date1<span class="sy0">.</span><span class="me1">ToString</span><span class="br0">&#40;</span><span class="st0">&quot;M/dd/yyyy h:mm:ss.fff tt&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">DateTime date1 = new DateTime(2011, 7, 13, 16, 32, 18, 500);
Console.WriteLine(date1.ToString("M/dd/yyyy h:mm:ss.fff tt"));</pre></div></div>

<p>7/13/2011 4:32:18.500 PM</p>
<p>You can do this in SQL</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> DATETIMEFROMPARTS <span class="br0">&#40;</span> <span class="nu0">2011</span>, <span class="nu0">7</span>, <span class="nu0">13</span>, <span class="nu0">16</span>, <span class="nu0">32</span>, <span class="nu0">18</span>, <span class="nu0">500</span> <span class="br0">&#41;</span> <span class="kw1">AS</span> <span class="kw1">Result</span>;</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DATETIMEFROMPARTS ( 2011, 7, 13, 16, 32, 18, 500 ) AS Result;</pre></div></div>

<p>2011-07-13 16:32:18.500</p>
<p>There are a couple of things to be aware of<br />
You have to be within the valid datetime range (January 1, 1753, through December 31, 9999)</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> DATETIMEFROMPARTS<span class="br0">&#40;</span><span class="nu0">1600</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">500</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DATETIMEFROMPARTS(1600,1,1,1,1,1,500)</pre></div></div>

<p>Msg 289, Level 16, State 3, Line 1<br />
Cannot construct data type datetime, some of the arguments have values which are not valid.<br />
&#12288;</p>
<p>If you use datetime2, which goes back to year 1 then you are fine, however if you just change DATETIMEFROMPARTS to DATETIME2FROMPARTS you will have a problem, DATETIME2FROMPARTS needs also precision </p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> DATETIME2FROMPARTS<span class="br0">&#40;</span><span class="nu0">1600</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">500</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DATETIME2FROMPARTS(1600,1,1,1,1,1,500)</pre></div></div>

<p>Msg 174, Level 15, State 1, Line 1<br />
The datetime2fromparts function requires 8 argument(s).<br />
&#12288;</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> DATETIME2FROMPARTS<span class="br0">&#40;</span><span class="nu0">1600</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">1</span>,<span class="nu0">500</span>,<span class="nu0">3</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DATETIME2FROMPARTS(1600,1,1,1,1,1,500,3)</pre></div></div>

<p>1600-01-01 01:01:01.500</p>
<p>Here is what BOL has to say about DATETIMEFROMPARTS:</p>
<p><em>DATETIMEFROMPARTS returns a fully initialized datetime value. If the arguments are not valid, then an error is raised. If required arguments are null, then a null is returned.</em></p>
<p>Here is what BOL has to say about DATETIME2FROMPARTS:<br />
<em>DATETIME2FROMPARTS returns a fully initialized datetime2 value. If the arguments are not valid, an error is raised. If required arguments are null, then null is returned. However, if the precision argument is null, then an error is raised.</p>
<p>The fractions argument depends on the precision argument. For example, if precision is 7, then each fraction represents 100 nanoseconds; if precision is 3, then each fraction represents a millisecond. If the value of precision is zero, then the value of fractions must also be zero; otherwise, an error is raised.</em></p>
<p>Here is a list of some of these new date/time functions</p>
<div class="tables">
<table>
<tr>
<th>
<p>Function</p>
</th>
<th>
<p>Syntax</p>
</th>
<th>
<p>Return value</p>
</th>
<th>
<p>Return data type</p>
</th>
</tr>
<tr>
<td>
<p>
            <strong>DATEFROMPARTS </strong>
          </p>
</td>
<td>
<p>DATEFROMPARTS  ( year, month, day )</p>
</td>
<td>
<p>Returns a date value for the specified year, month, and day.</p>
</td>
<td>
<p>              date </p>
</td>
</tr>
<tr>
<td>
<p>
            <strong>DATETIME2FROMPARTS </strong>
          </p>
</td>
<td>
<p>DATETIME2FROMPARTS  ( year, month, day, hour, minute, seconds, fractions, precision )</p>
</td>
<td>
<p>Returns a datetime2 value for the specified date and time and with the specified precision.</p>
</td>
<td>
<p>              datetime2<br />
             <strong>(</strong> precision <strong>)</strong></p>
</td>
</tr>
<tr>
<td>
<p>
            <strong>DATETIMEFROMPARTS</strong>
          </p>
</td>
<td>
<p>DATETIMEFROMPARTS  ( year, month, day, hour, minute, seconds, milliseconds )</p>
</td>
<td>
<p>Returns a datetime value for the specified date and time.</p>
</td>
<td>
<p>              datetime </p>
</td>
</tr>
<tr>
<td>
<p>
            <strong>DATETIMEOFFSETFROMPARTS </strong>
          </p>
</td>
<td>
<p>DATETIMEOFFSETFROMPARTS  ( year, month, day, hour, minute, seconds, fractions, hour_offset, minute_offset, precision )</p>
</td>
<td>
<p>Returns a datetimeoffset value for the specified date and time and with the specified offsets and precision.</p>
</td>
<td>
<p>              datetime<br />
             <strong>(</strong> precision <strong>)</strong></p>
</td>
</tr>
<tr>
<td>
<p>
            <strong>SMALLDATETIMEFROMPARTS</strong>
          </p>
</td>
<td>
<p>SMALLDATETIMEFROMPARTS  ( year, month, day, hour, minute )</p>
</td>
<td>
<p>Returns a smalldatetime value for the specified date and time.</p>
</td>
<td>
<p>              smalldatetime </p>
</td>
</tr>
<tr>
<td>
<p>
            <strong>TIMEFROMPARTS </strong>
          </p>
</td>
<td>
<p>TIMEFROMPARTS  ( hour, minute, seconds, fractions, precision )</p>
</td>
<td>
<p>Returns a time value for the specified time and with the specified precision.</p>
</td>
<td>
<p>              time<br />
             <strong>(</strong> precision <strong>)</strong></p>
</td>
</tr>
<tr>
<td>
<p>
            <strong>EOMONTH </strong>
          </p>
</td>
<td>
<p>EOMONTH ( start_date [, month_to_add ] )</p>
</td>
<td>
<p>Returns the last day of the month that contains the specified date, with an optional offset.</p>
</td>
<td>
<p>
                 Return type is the type of start_date or datetime2(7).</p>
</td>
</tr>
</table></div>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/datefromparts-and-datetimefromparts-functions-in/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>A Quick look at the new EOMONTH function in SQL Server Denali CTP3</title>
		<link>/index.php/datamgmt/datadesign/a-quick-look-at-the-1/</link>
		<comments>/index.php/datamgmt/datadesign/a-quick-look-at-the-1/#comments</comments>
		<pubDate>Wed, 13 Jul 2011 14:09:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[dates]]></category>
		<category><![CDATA[denali]]></category>
		<category><![CDATA[functions]]></category>

		<guid isPermaLink="false">/index.php/2011/07/a-quick-look-at-the-1/</guid>
		<description><![CDATA[SQL Server Denali CTP3  has a bunch of new date/time functions like DATEFROMPARTS,  DATETIMEFROMPARTS and EOMONTH

First let's take a look at EOMONTH.

The syntax for EOMONTH is

EOMONTH ( start_date [, month_to_add ] )

If you pass in getdate()&#8230;]]></description>
				<content:encoded><![CDATA[<p>SQL Server Denali CTP3  has a bunch of new date/time functions like DATEFROMPARTS,  DATETIMEFROMPARTS and EOMONTH</p>
<p>First let&#8217;s take a look at EOMONTH.</p>
<p>The syntax for EOMONTH is</p>
<pre>EOMONTH ( start_date [, month_to_add ] )</pre>
<p>If you pass in getdate() you will get the last day of the month for the current month</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> EOMONTH<span class="br0">&#40;</span><span class="kw2">getdate</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT EOMONTH(getdate())</pre></div></div>

<p>2011-07-31 00:00:00.000</p>
<p>If you pass in a date, you will also get the last date for that month</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> EOMONTH<span class="br0">&#40;</span><span class="st0">'20110615'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT EOMONTH('20110615')</pre></div></div>

<p>2011-06-30 00:00:00.0000000</p>
<p>This function also accepts an optional parameter: month_to_add</p>
<p><em>month_to_add<br />
Optional integer expression specifying the number of months to add to start_date.</p>
<p>If this argument is specified, then EOMONTH adds the specified number of months to start_date, and then returns the last day of the month for the resulting date. If this addition overflows the valid range of dates, then an error is raised.</em></p>
<p>So if we pass 1 for month_to_add it will add a month</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> EOMONTH<span class="br0">&#40;</span><span class="st0">'20110615'</span>,<span class="nu0">1</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT EOMONTH('20110615',1)</pre></div></div>

<p>2011-07-31 00:00:00.0000000</p>
<p>If we pass -1 for month_to_add it will subtract a month</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> EOMONTH<span class="br0">&#40;</span><span class="st0">'20110615'</span>,<span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT EOMONTH('20110615',-1)</pre></div></div>

<p>2011-05-31 00:00:00.0000000</p>
<p>The one problem with this function is that if you do a query and specify between some date and EOMONTH it won&#8217;t give you anything after midnight. I already explained that in this post: <a href="/index.php/DataMgmt/DataDesign/how-does-between-work-with-dates-in-sql-">How Does Between Work With Dates In SQL Server?</a></p>
<p>I also wonder why there is no SOMONTH function? Yes, I know it starts with 1, but if there is an <em>end of month</em> function then someone will also search for a <em>start of month</em> function.</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/a-quick-look-at-the-1/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>A Quick look at the new IIF function in Denali CTP3</title>
		<link>/index.php/datamgmt/datadesign/a-quick-look-at-the/</link>
		<comments>/index.php/datamgmt/datadesign/a-quick-look-at-the/#comments</comments>
		<pubDate>Wed, 13 Jul 2011 13:19:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[denali]]></category>
		<category><![CDATA[functions]]></category>
		<category><![CDATA[iif]]></category>

		<guid isPermaLink="false">/index.php/2011/07/a-quick-look-at-the/</guid>
		<description><![CDATA[Denali CTP3 comes with the IIF function, if you have used VB or Excel then you already know how this function works. In essence this function is a shorter version of a CASE statement. 

The syntax is as follows

IIF ( boolean_expression, true_value,&#8230;]]></description>
				<content:encoded><![CDATA[<p>Denali CTP3 comes with the IIF function, if you have used VB or Excel then you already know how this function works. In essence this function is a shorter version of a CASE statement. </p>
<p>The syntax is as follows</p>
<pre>IIF ( boolean_expression, true_value, false_value )</pre>
<p>So instead of this</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw1">CASE</span> <span class="kw1">WHEN</span> <span class="nu0">1</span> <span class="sy0">=</span> <span class="nu0">2</span> <span class="kw1">THEN</span> <span class="st0">'equal'</span> <span class="kw1">ELSE</span> <span class="st0">'not equal'</span> <span class="kw1">END</span> <span class="kw1">AS</span> Comp</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT CASE WHEN 1 = 2 THEN 'equal' ELSE 'not equal' END AS Comp</pre></div></div>

<p>We can do this</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> IIF<span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">=</span><span class="nu0">2</span>,<span class="st0">'equal'</span>,<span class="st0">'not equal'</span><span class="br0">&#41;</span> <span class="kw1">as</span> Comp</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT IIF(1=2,'equal','not equal') as Comp</pre></div></div>

<p>Both of those will return not equal</p>
<p>Be aware that you can&#8217;t use NULL like in the example below</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> IIF<span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">=</span><span class="nu0">2</span>,<span class="sy0">NULL</span> ,<span class="sy0">NULL</span> <span class="br0">&#41;</span> <span class="kw1">as</span> calc</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT IIF(1=2,NULL ,NULL ) as calc</pre></div></div>

<p>It throws an error (with a typo)</p>
<p>Msg 8133, Level 16, State 1, Line 1<br />
At <strong>lease </strong>one of the result expressions in a CASE specification must be an expression other than the NULL constant.</p>
<p>If you use a variable then you can use NULL</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
</pre></td><td class="de1"><pre class="de1"><span class="kw1">declare</span> @i <span class="kw1">int</span> <span class="sy0">=</span> <span class="sy0">NULL</span> 
&nbsp;
&nbsp;
<span class="kw1">SELECT</span> IIF<span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">=</span><span class="nu0">2</span>,@i,@i<span class="br0">&#41;</span> <span class="kw1">as</span> calc</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">declare @i int = NULL 


SELECT IIF(1=2,@i,@i) as calc</pre></div></div>

<p>Here is some more info from Books On Line</p>
<p><em>IIF is a shorthand way for writing a CASE statement. It evaluates the Boolean expression passed as the first argument, and then returns either of the other two arguments based on the result of the evaluation. That is, the true_value is returned if the Boolean expression is true, and the false_value is returned if the Boolean expression is false or unknown. true_value and false_value can be of any type. The same rules that apply to the CASE statement for Boolean expressions, null handling, and return types also apply to IIF.</p>
<p>The fact that IIF is translated into CASE also has an impact on other aspects of the behavior of this function. Since CASE statements can nested only up to the level of 10, IIF statements can also be nested only up to the maximum level of 10. Also, IIF is remoted to other servers as a semantically equivalent CASE statement, with all the behaviors of a remoted CASE statement.</em></p>
<p>Here is a nested (silly) example</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> IIF<span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">=</span><span class="nu0">2</span>,<span class="st0">'equal'</span>,IIF<span class="br0">&#40;</span><span class="nu0">4</span><span class="sy0">=</span><span class="nu0">2</span>,<span class="st0">'equal'</span>,<span class="st0">'not equal'</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="kw1">as</span> Comp</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT IIF(1=2,'equal',IIF(4=2,'equal','not equal')) as Comp</pre></div></div>

<p>Here is another example that combines IIF with TRY_CONVERT to return if a value can be converted to a specific data type</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> IIF<span class="br0">&#40;</span>TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">float</span>,<span class="st0">'bla'</span><span class="br0">&#41;</span><span class="kw1">IS</span> <span class="sy0">NULL</span>,<span class="st0">'Cast failed'</span>,<span class="st0">'Cast succeeded'</span><span class="br0">&#41;</span>
<span class="kw1">UNION</span>
<span class="kw1">SELECT</span> IIF<span class="br0">&#40;</span>TRY_CONVERT<span class="br0">&#40;</span><span class="kw1">float</span>,<span class="st0">'1'</span><span class="br0">&#41;</span><span class="kw1">IS</span> <span class="sy0">NULL</span>,<span class="st0">'Cast failed'</span>,<span class="st0">'Cast succeeded'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT IIF(TRY_CONVERT(float,'bla')IS NULL,'Cast failed','Cast succeeded')
UNION
SELECT IIF(TRY_CONVERT(float,'1')IS NULL,'Cast failed','Cast succeeded')</pre></div></div>

<p>&#8212;&#8212;&#8211;<br />
Cast failed<br />
Cast succeeded</p>
<p>I welcome this function, anything that makes the code shorter is welcomed with open arms by me.</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/a-quick-look-at-the/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
		</item>
		<item>
		<title>Use the GROUPING function to determine whether a value is NULL because of ROLLUP</title>
		<link>/index.php/datamgmt/datadesign/use-the-grouping-function-to/</link>
		<comments>/index.php/datamgmt/datadesign/use-the-grouping-function-to/#comments</comments>
		<pubDate>Wed, 23 Mar 2011 13:58:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[aggregations]]></category>
		<category><![CDATA[functions]]></category>
		<category><![CDATA[group by]]></category>
		<category><![CDATA[grouping]]></category>
		<category><![CDATA[rollup]]></category>
		<category><![CDATA[sql server 2008]]></category>

		<guid isPermaLink="false">/index.php/2011/03/use-the-grouping-function-to/</guid>
		<description><![CDATA[If you have been writing queries that use ROLLUP, you are probably aware that the aggregated rows return NULL for the column that you are grouping by. What if you already have a NULL value in that column, how can you know which row is the aggregated row&#8230;]]></description>
				<content:encoded><![CDATA[<p>If you have been writing queries that use ROLLUP, you are probably aware that the aggregated rows return NULL for the column that you are grouping by. What if you already have a NULL value in that column, how can you know which row is the aggregated row? Let&#8217;s take a look, first create this table</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> TestRollup<span class="br0">&#40;</span>Country <span class="kw1">VARCHAR</span><span class="br0">&#40;</span><span class="nu0">20</span><span class="br0">&#41;</span>,Col1 <span class="kw1">INT</span>, col2 <span class="kw1">INT</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'United States'</span>,<span class="nu0">20</span>,<span class="nu0">10</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'United States'</span>,<span class="nu0">30</span>,<span class="nu0">90</span><span class="br0">&#41;</span>
&nbsp;
<span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'Denmark'</span>,<span class="nu0">20</span>,<span class="nu0">10</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'Denmark'</span>,<span class="nu0">44</span>,<span class="nu0">33</span><span class="br0">&#41;</span>
&nbsp;
<span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'Zimbabwe'</span>,<span class="nu0">20</span>,<span class="nu0">10</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'Zimbabwe'</span>,<span class="nu0">20</span>,<span class="nu0">10</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'Zimbabwe'</span>,<span class="nu0">20</span>,<span class="nu0">1000</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'Zimbabwe'</span>,<span class="nu0">2000</span>,<span class="nu0">10</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE TestRollup(Country VARCHAR(20),Col1 INT, col2 INT)
INSERT TestRollup VALUES('United States',20,10)
INSERT TestRollup VALUES('United States',30,90)

INSERT TestRollup VALUES('Denmark',20,10)
INSERT TestRollup VALUES('Denmark',44,33)

INSERT TestRollup VALUES('Zimbabwe',20,10)
INSERT TestRollup VALUES('Zimbabwe',20,10)
INSERT TestRollup VALUES('Zimbabwe',20,1000)
INSERT TestRollup VALUES('Zimbabwe',2000,10)</pre></div></div>

<p>Now let&#8217;s do our simple ROLLUP query</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> Country, <span class="kw2">SUM</span><span class="br0">&#40;</span>Col1<span class="br0">&#41;</span> Col1Sum, <span class="kw2">SUM</span><span class="br0">&#40;</span>col2<span class="br0">&#41;</span> <span class="kw1">AS</span> Col2Sum
<span class="kw1">FROM</span> TestRollup
<span class="kw1">GROUP</span> <span class="kw1">BY</span> Country <span class="kw1">WITH</span> <span class="kw1">ROLLUP</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT Country, SUM(Col1) Col1Sum, SUM(col2) AS Col2Sum
FROM TestRollup
GROUP BY Country WITH ROLLUP</pre></div></div>

<p>Here is the results</p>
<div class="tables">
<table>
<tr>
<th>Country</th>
<th>	Col1Sum</th>
<th>	Col2Sum</th>
</tr>
<tr>
<td>Denmark	</td>
<td>64</td>
<td>	43</td>
</tr>
<tr>
<td>United States</td>
<td>	50</td>
<td>	100</td>
</tr>
<tr>
<td>Zimbabwe	</td>
<td>2060</td>
<td>	1030</td>
</tr>
<tr>
<td>NULL	</td>
<td>2174</td>
<td>	1173</td>
</tr>
</table>
</div>
<p>We can easily determine that the Country column that has the value NULL is the total. What happens when we add the following row</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">INSERT</span> TestRollup <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="sy0">NULL</span>,<span class="nu0">2000</span>,<span class="nu0">3000</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">INSERT TestRollup VALUES(NULL,2000,3000)</pre></div></div>

<p>Now when we run the same query again, we have two rows where Country is NULL</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> Country, <span class="kw2">SUM</span><span class="br0">&#40;</span>Col1<span class="br0">&#41;</span> Col1Sum, <span class="kw2">SUM</span><span class="br0">&#40;</span>col2<span class="br0">&#41;</span> <span class="kw1">AS</span> Col2Sum
<span class="kw1">FROM</span> TestRollup
<span class="kw1">GROUP</span> <span class="kw1">BY</span> Country <span class="kw1">WITH</span> <span class="kw1">ROLLUP</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT Country, SUM(Col1) Col1Sum, SUM(col2) AS Col2Sum
FROM TestRollup
GROUP BY Country WITH ROLLUP</pre></div></div>

<div class="tables">
<p>Here are the results</p>
<table>
<tr>
<th>Country</th>
<th>	Col1Sum</th>
<th>	Col2Sum</th>
</tr>
<tr>
<td>NULL</td>
<td>	2000</td>
<td>	3000</td>
</tr>
<tr>
<td>Denmark	</td>
<td>64</td>
<td>	43</td>
</tr>
<tr>
<td>United States</td>
<td>	50</td>
<td>	100</td>
</tr>
<tr>
<td>Zimbabwe	</td>
<td>2060</td>
<td>	1030</td>
</tr>
<tr>
<td>NULL	</td>
<td>4174</td>
<td>	4173</td>
</tr>
</table>
</div>
<p>To figure out which of the two is the one that is caused by ROLLUP, you can use the GROUPING function, the function will return 1 if it is aggregated and 0 otherwise.</p>
<p>Here is what Books On Line has to say about <a href="http://msdn.microsoft.com/en-us/library/ms178544.aspx">GROUPING</a></p>
<p><em><strong>GROUPING</strong><br />
Indicates whether a specified column expression in a GROUP BY list is aggregated or not. GROUPING returns 1 for aggregated or 0 for not aggregated in the result set. GROUPING can be used only in the SELECT &lt;select&gt; list, HAVING, and ORDER BY clauses when GROUP BY is specified.</p>
<p>GROUPING is used to distinguish the null values that are returned by ROLLUP, CUBE or GROUPING SETS from standard null values. The NULL returned as the result of a ROLLUP, CUBE or GROUPING SETS operation is a special use of NULL. This acts as a column placeholder in the result set and means all.</em></p>
<p>Now, let&#8217;s add GROUPING(Country) to our query</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> Country, <span class="kw2">SUM</span><span class="br0">&#40;</span>Col1<span class="br0">&#41;</span> Col1Sum, <span class="kw2">SUM</span><span class="br0">&#40;</span>col2<span class="br0">&#41;</span> <span class="kw1">AS</span> Col2Sum, <span class="kw1">GROUPING</span><span class="br0">&#40;</span>Country<span class="br0">&#41;</span> <span class="kw1">AS</span> GroupingCountry
<span class="kw1">FROM</span> TestRollup
<span class="kw1">GROUP</span> <span class="kw1">BY</span> Country <span class="kw1">WITH</span> <span class="kw1">ROLLUP</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT Country, SUM(Col1) Col1Sum, SUM(col2) AS Col2Sum, GROUPING(Country) AS GroupingCountry
FROM TestRollup
GROUP BY Country WITH ROLLUP</pre></div></div>

<p>Here are the results, as you can see the function returns 1 for the aggregated row</p>
<div class="tables">
<table>
<tr>
<th>Country</th>
<th>	Col1Sum</th>
<th>	Col2Sum</th>
<th>	GroupingCountry</th>
</tr>
<tr>
<td>NULL</td>
<td>	2000</td>
<td>	3000</td>
<td>	0</td>
</tr>
<tr>
<td>Denmark</td>
<td>	64</td>
<td>	43</td>
<td>	0</td>
</tr>
<tr>
<td>United States</td>
<td>	50</td>
<td>	100</td>
<td>	0</td>
</tr>
<tr>
<td>Zimbabwe</td>
<td>	2060</td>
<td>	1030</td>
<td>	0</td>
</tr>
<tr>
<td>NULL</td>
<td>	4174</td>
<td>	4173</td>
<td>	1</td>
</tr>
</table>
</div>
<p>Now we can simply add a CASE expression to display Total for the aggregated column</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw1">CASE</span> &nbsp;<span class="kw1">GROUPING</span><span class="br0">&#40;</span>Country<span class="br0">&#41;</span> <span class="kw1">WHEN</span> <span class="nu0">1</span> <span class="kw1">THEN</span> <span class="st0">'Total'</span> <span class="kw1">ELSE</span> Country <span class="kw1">END</span> Country, <span class="kw2">SUM</span><span class="br0">&#40;</span>Col1<span class="br0">&#41;</span> Col1Sum, <span class="kw2">SUM</span><span class="br0">&#40;</span>col2<span class="br0">&#41;</span> <span class="kw1">AS</span> Col2Sum
<span class="kw1">FROM</span> TestRollup
<span class="kw1">GROUP</span> <span class="kw1">BY</span> Country <span class="kw1">WITH</span> <span class="kw1">ROLLUP</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT CASE  GROUPING(Country) WHEN 1 THEN 'Total' ELSE Country END Country, SUM(Col1) Col1Sum, SUM(col2) AS Col2Sum
FROM TestRollup
GROUP BY Country WITH ROLLUP</pre></div></div>

<p>Here is what the results look like </p>
<div class="tables">
<table>
<tr>
<th>Country</th>
<th>	Col1Sum</th>
<th>	Col2Sum</th>
</tr>
<tr>
<td>NULL	</td>
<td>2000</td>
<td>	3000</td>
</tr>
<tr>
<td>Denmark	</td>
<td>64</td>
<td>	43</td>
</tr>
<tr>
<td>United States	</td>
<td>50</td>
<td>	100</td>
</tr>
<tr>
<td>Zimbabwe	</td>
<td>2060</td>
<td>	1030</td>
</tr>
<tr>
<td>Total	</td>
<td>4174</td>
<td>	4173</td>
</tr>
</table>
</div>
<p>That is it for this post, hopefully it will help someone</p>
<p>*** <strong>Remember, if you have a SQL related question, try our <a href="http://forum.lessthandot.com/viewforum.php?f=17">Microsoft SQL Server Programming</a> forum or our <a href="http://forum.lessthandot.com/viewforum.php?f=22">Microsoft SQL Server Admin</a> forum</strong><ins></ins></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/use-the-grouping-function-to/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>T-SQL To find Out If An Index Is Clustered Or Non Clustered</title>
		<link>/index.php/datamgmt/datadesign/t-sql-to-find-out-if-an-index-is-cluster/</link>
		<comments>/index.php/datamgmt/datadesign/t-sql-to-find-out-if-an-index-is-cluster/#comments</comments>
		<pubDate>Tue, 06 Oct 2009 16:41:12 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[functions]]></category>
		<category><![CDATA[how to]]></category>
		<category><![CDATA[indexing]]></category>
		<category><![CDATA[sql server 2000]]></category>
		<category><![CDATA[sql server 2005]]></category>
		<category><![CDATA[sql server 2008]]></category>
		<category><![CDATA[tip]]></category>

		<guid isPermaLink="false">/index.php/2009/10/t-sql-to-find-out-if-an-index-is-cluster/</guid>
		<description><![CDATA[I saw this question in in Google Analytics from a Google search that hit our site. So, how can you determice if an index is clustered or not? There are two ways, you can use either the INDEXPROPERTY function or the sysindexes/sys.sysindexes system table/view To see how it works we will create a table with [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>I saw this question in in Google Analytics from a Google search that hit our site.<br />
So, how can you determice if an index is clustered or not? There are two ways, you can use either the INDEXPROPERTY function or the sysindexes/sys.sysindexes system table/view</p>
<p>To see how it works we will create a table with one clustered and one non clustered index on it<br />
Here is the code for that</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="de1"><pre class="de1"><span class="kw1">USE</span> tempdb
go
&nbsp;
<span class="kw1">CREATE</span> <span class="kw1">TABLE</span> Test <span class="br0">&#40;</span>id <span class="kw1">INT</span>, col1 <span class="kw1">VARCHAR</span><span class="br0">&#40;</span><span class="nu0">40</span><span class="br0">&#41;</span>, col2 <span class="kw1">INT</span>, col3 <span class="kw1">INT</span><span class="br0">&#41;</span>
go
&nbsp;
&nbsp;
<span class="kw1">CREATE</span> <span class="kw1">NONCLUSTERED</span> &nbsp;<span class="kw1">INDEX</span> ix_test <span class="kw1">ON</span> test <span class="br0">&#40;</span>id <span class="kw1">ASC</span>, col1 <span class="kw1">DESC</span>,col2 <span class="kw1">DESC</span>, col3 <span class="kw1">ASC</span><span class="br0">&#41;</span>
go
&nbsp;
&nbsp;
<span class="kw1">CREATE</span> <span class="kw1">CLUSTERED</span> &nbsp;<span class="kw1">INDEX</span> ix_test_clust <span class="kw1">ON</span> test <span class="br0">&#40;</span>id <span class="kw1">ASC</span>, col1 <span class="kw1">DESC</span><span class="br0">&#41;</span>
go</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">USE tempdb
go
 
CREATE TABLE Test (id INT, col1 VARCHAR(40), col2 INT, col3 INT)
go


CREATE NONCLUSTERED  INDEX ix_test ON test (id ASC, col1 DESC,col2 DESC, col3 ASC)
go
 
 
CREATE CLUSTERED  INDEX ix_test_clust ON test (id ASC, col1 DESC)
go</pre></div></div>

<p><strong>INDEXPROPERTY</strong><br />
To use INDEXPROPERTY you need to know the table ID, the name of the index and use IsClustered for the property. To get the table id, you use the OBJECT_ID function with the table name passed in<br />
So for the index ix_test on table Test we will use INDEXPROPERTY(OBJECT_ID(&#8216;Test&#8217;), &#8216;ix_test&#8217;,&#8217;IsClustered&#8217;)</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="st0">'ix_test'</span>,<span class="kw2">INDEXPROPERTY</span><span class="br0">&#40;</span><span class="kw2">OBJECT_ID</span><span class="br0">&#40;</span><span class="st0">'Test'</span><span class="br0">&#41;</span>, <span class="st0">'ix_test'</span>,<span class="st0">'IsClustered'</span><span class="br0">&#41;</span>
<span class="kw1">union</span> all
<span class="kw1">SELECT</span> <span class="st0">'ix_test_clust'</span>,<span class="kw2">INDEXPROPERTY</span><span class="br0">&#40;</span><span class="kw2">OBJECT_ID</span><span class="br0">&#40;</span><span class="st0">'Test'</span><span class="br0">&#41;</span>, <span class="st0">'ix_test_clust'</span>, <span class="st0">'IsClustered'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT 'ix_test',INDEXPROPERTY(OBJECT_ID('Test'), 'ix_test','IsClustered')
union all
SELECT 'ix_test_clust',INDEXPROPERTY(OBJECT_ID('Test'), 'ix_test_clust', 'IsClustered')</pre></div></div>

<p></p>
<pre>Output
-------------------
ix_test		0
ix_test_clust	1</pre>
<p><strong>SYSINDEXES</strong><br />
indid holds the information needed to determine if the index is clustered or not<br />
This info is for SQL Server 2000<br />
<em>1 = Clustered index<br />
>1 = Nonclustered<br />
255 = Entry for tables that have text or image data</em></p>
<p>This info is for SQL Server 2005 and up</p>
<p><em>0 = Heap<br />
1 = Clustered index<br />
>1 = Nonclustered index</em></p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> name,<span class="kw1">case</span> indid <span class="kw1">when</span> <span class="nu0">1</span> <span class="kw1">then</span> <span class="st0">'Clustered'</span> <span class="kw1">else</span> <span class="st0">'Non Clustered'</span> <span class="kw1">end</span> <span class="kw1">as</span> TypeOfIndex
<span class="kw1">from</span> sysindexes <span class="co1">--or sys.sysindexes on sql 2005 and up</span>
<span class="kw1">where</span> name in<span class="br0">&#40;</span> <span class="st0">'ix_test'</span>, <span class="st0">'ix_test_clust'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select name,case indid when 1 then 'Clustered' else 'Non Clustered' end as TypeOfIndex
from sysindexes --or sys.sysindexes on sql 2005 and up
where name in( 'ix_test', 'ix_test_clust')</pre></div></div>

<p></p>
<pre>Output
-----------------------
name	TypeOfIndex
ix_test_clust	Clustered
ix_test	Non Clustered</pre>
<p>And of course you can combine the two methods</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> name,<span class="kw2">INDEXPROPERTY</span><span class="br0">&#40;</span>id, name,<span class="st0">'IsClustered'</span><span class="br0">&#41;</span>
<span class="kw1">from</span> sysindexes 
<span class="kw1">where</span> name in<span class="br0">&#40;</span> <span class="st0">'ix_test'</span>, <span class="st0">'ix_test_clust'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT name,INDEXPROPERTY(id, name,'IsClustered')
from sysindexes 
where name in( 'ix_test', 'ix_test_clust')</pre></div></div>

<p></p>
<pre>Output
-------------
ix_test_clust	1
ix_test		0</pre>
<p>As you can see it is pretty easy to determine if an index is a clustered index or a non clustered index. I prefer to use INDEXPROPERTY instead of SYSINDEXES, what about you?</p>
<p></p>
<p>*** <strong>If you have a SQL related question try our <a href="http://forum.lessthandot.com/viewforum.php?f=17">Microsoft SQL Server Programming</a> forum or our <a href="http://forum.lessthandot.com/viewforum.php?f=22">Microsoft SQL Server Admin</a> forum</strong><ins></ins></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/t-sql-to-find-out-if-an-index-is-cluster/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Use INDEXKEY_PROPERTY in SQL Server to determine if columns in indexes are sorted ascending or descending</title>
		<link>/index.php/datamgmt/datadesign/use-indexkey_property-in-sql-server-to-d/</link>
		<comments>/index.php/datamgmt/datadesign/use-indexkey_property-in-sql-server-to-d/#comments</comments>
		<pubDate>Wed, 23 Sep 2009 18:20:23 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Administration]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[functions]]></category>
		<category><![CDATA[indexes]]></category>
		<category><![CDATA[indexing]]></category>
		<category><![CDATA[sql server 2005]]></category>
		<category><![CDATA[sql server 2008]]></category>

		<guid isPermaLink="false">/index.php/2009/09/use-indexkey_property-in-sql-server-to-d/</guid>
		<description><![CDATA[How can you find out if the columns that are part of the index are sorted descending or ascending in that index? For example when you create the following index T-SQL1 CREATE CLUSTERED &#160;INDEX ix_test_clust ON test &#40;id ASC, col1 DESC&#41; CREATE CLUSTERED INDEX ix_test_clust ON test (id ASC, col1 DESC) How would you find [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>How can you find out if the columns that are part of the index are sorted descending or ascending in that index? For example when you create the following index</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">CLUSTERED</span> &nbsp;<span class="kw1">INDEX</span> ix_test_clust <span class="kw1">ON</span> test <span class="br0">&#40;</span>id <span class="kw1">ASC</span>, col1 <span class="kw1">DESC</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE CLUSTERED  INDEX ix_test_clust ON test (id ASC, col1 DESC)</pre></div></div>

<p>How would you find out without scripting the index if the columns are in descending or ascending order? SQL Server has a function for that, the name of this function is INDEXKEY_PROPERTY<br />
Before starting I need to warn you that this will only run on SQL Server 2005 and above, I have not tested this on SQL Server 2000 but if you need it to run on SQL Server 2000 remove sys. in front of the tables&#8230;so instead of sys.sysindexes use sysindexes that should do the trick.</p>
<p>Let&#8217;s see how that works. first create this table in the tempdb</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1"><span class="kw1">USE</span> tempdb
go
&nbsp;
<span class="kw1">CREATE</span> <span class="kw1">TABLE</span> Test <span class="br0">&#40;</span>id <span class="kw1">INT</span>, col1 <span class="kw1">VARCHAR</span><span class="br0">&#40;</span><span class="nu0">40</span><span class="br0">&#41;</span>, col2 <span class="kw1">INT</span>, col3 <span class="kw1">INT</span><span class="br0">&#41;</span>
go</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">USE tempdb
go
 
CREATE TABLE Test (id INT, col1 VARCHAR(40), col2 INT, col3 INT)
go</pre></div></div>

<p>Now create 2 indexes, one clustered with 2 columns and one non clustered with 4 columns</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">NONCLUSTERED</span> &nbsp;<span class="kw1">INDEX</span> ix_test <span class="kw1">ON</span> test <span class="br0">&#40;</span>id <span class="kw1">ASC</span>, col1 <span class="kw1">DESC</span>,col2 <span class="kw1">DESC</span>, col3 <span class="kw1">ASC</span><span class="br0">&#41;</span>
go
&nbsp;
&nbsp;
<span class="kw1">CREATE</span> <span class="kw1">CLUSTERED</span> &nbsp;<span class="kw1">INDEX</span> ix_test_clust <span class="kw1">ON</span> test <span class="br0">&#40;</span>id <span class="kw1">ASC</span>, col1 <span class="kw1">DESC</span><span class="br0">&#41;</span>
go</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE NONCLUSTERED  INDEX ix_test ON test (id ASC, col1 DESC,col2 DESC, col3 ASC)
go
 
 
CREATE CLUSTERED  INDEX ix_test_clust ON test (id ASC, col1 DESC)
go</pre></div></div>

<p>First we need to see what the arguments are for the INDEXKEY_PROPERTY function; here is what you can find in Books On Line<br />
<strong>INDEXKEY_PROPERTY ( object_ID ,index_ID ,key_ID ,property )</strong></p>
<p><strong>Arguments</strong></p>
<table border="1" cellpadding="10">
<tr>
<td><strong>object_ID</strong></td>
<td>Is the object identification number of the table or indexed view. object_ID is int.</td>
</tr>
<tr>
<td><strong>index_ID</strong></td>
<td>Is the index identification number. index_ID is int.</td>
</tr>
<tr>
<td><strong>key_ID</strong></td>
<td>Is the index key column position. key_ID is int.</td>
</tr>
<tr>
<td valign="top"><strong>property</strong></td>
<td>Is the name of the property for which information will be returned. property is a character string and can be one of the following values.</p>
<table border="1">
<tr>
<td><strong>Value</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>ColumnId</td>
<td>  Column ID at the key_ID position of the index.</td>
</tr>
<tr>
<td>IsDescending</td>
<td>Order in which the index column is stored.</td>
</tr>
<tr>
<td colspan="2" align="right">1 = Descending 0 = Ascending</td>
</tr>
</table>
</td>
</tr>
</table>
<p>So to use it we need to know a couple of things, we need the table name, the index id and the index key column position.<br />
Run the following query which will give you all that info for the table Test, change the table name if you are interested in other tables.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> <span class="kw2">OBJECT_NAME</span><span class="br0">&#40;</span>k.<span class="me1">id</span><span class="br0">&#41;</span> <span class="kw1">as</span> TableName,i.<span class="me1">name</span> <span class="kw1">as</span> IndexName,c.<span class="me1">name</span> <span class="kw1">as</span> ColumnName,k.<span class="me1">keyno</span>,k.<span class="me1">indid</span> <span class="kw1">as</span> IndexID 
<span class="kw1">from</span> sys.<span class="me1">sysindexes</span> i
join sys.<span class="me1">sysindexkeys</span> k <span class="kw1">on</span> i.<span class="me1">id</span> <span class="sy0">=</span> k.<span class="me1">id</span>
and k.<span class="me1">indid</span> <span class="sy0">=</span> i.<span class="me1">indid</span>
join sys.<span class="me1">syscolumns</span> c <span class="kw1">on</span> k.<span class="me1">id</span> <span class="sy0">=</span> c.<span class="me1">id</span>
and k.<span class="me1">colid</span> <span class="sy0">=</span> c.<span class="me1">colid</span>
<span class="kw1">where</span> <span class="kw2">OBJECT_NAME</span><span class="br0">&#40;</span>k.<span class="me1">id</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="st0">'Test'</span>
<span class="kw1">order</span> <span class="kw1">by</span> <span class="kw2">OBJECT_NAME</span><span class="br0">&#40;</span>k.<span class="me1">id</span><span class="br0">&#41;</span>,i.<span class="me1">name</span>,k.<span class="me1">keyno</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select OBJECT_NAME(k.id) as TableName,i.name as IndexName,c.name as ColumnName,k.keyno,k.indid as IndexID 
from sys.sysindexes i
join sys.sysindexkeys k on i.id = k.id
and k.indid = i.indid
join sys.syscolumns c on k.id = c.id
and k.colid = c.colid
where OBJECT_NAME(k.id) = 'Test'
order by OBJECT_NAME(k.id),i.name,k.keyno</pre></div></div>

<p>Here is the output</p>
<table border="1">
<tr>
<td>TableName</td>
<td> IndexName</td>
<td> ColumnName</td>
<td>keyno</td>
<td> IndexID</td>
</tr>
<tr>
<td>Test</td>
<td>	ix_test</td>
<td>id</td>
<td>1</td>
<td>	2</td>
</tr>
<tr>
<td>Test</td>
<td>	ix_test</td>
<td>col1</td>
<td>2</td>
<td>	2</td>
</tr>
<tr>
<td>Test</td>
<td>	ix_test</td>
<td>col2</td>
<td>3</td>
<td>	2</td>
</tr>
<tr>
<td>Test</td>
<td>	ix_test</td>
<td>col3</td>
<td>4</td>
<td>	2</td>
</tr>
<tr>
<td>Test</td>
<td>	ix_test_clust</td>
<td>id</td>
<td>1</td>
<td>	1</td>
</tr>
<tr>
<td>Test</td>
<td>	ix_test_clust</td>
<td>col1</td>
<td>2</td>
<td>	1</td>
</tr>
</table>
<p>Now with the output from above can easily call the INDEXKEY_PROPERTY  function, we use the IsDescending property to find out the sort order, below are the function calls for the two indexes we created.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1"><span class="co1">--index ix_test </span>
<span class="kw1">SELECT</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span> <span class="kw2">OBJECT_ID</span><span class="br0">&#40;</span><span class="st0">'Test'</span><span class="br0">&#41;</span> , <span class="nu0">2</span> , <span class="nu0">1</span> , <span class="st0">'isdescending'</span> <span class="br0">&#41;</span>
<span class="kw1">SELECT</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span> <span class="kw2">OBJECT_ID</span><span class="br0">&#40;</span><span class="st0">'Test'</span><span class="br0">&#41;</span> , <span class="nu0">2</span> , <span class="nu0">2</span> , <span class="st0">'isdescending'</span> <span class="br0">&#41;</span>
<span class="kw1">SELECT</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span> <span class="kw2">OBJECT_ID</span><span class="br0">&#40;</span><span class="st0">'Test'</span><span class="br0">&#41;</span> , <span class="nu0">2</span> , <span class="nu0">3</span> , <span class="st0">'isdescending'</span> <span class="br0">&#41;</span>
<span class="kw1">SELECT</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span> <span class="kw2">OBJECT_ID</span><span class="br0">&#40;</span><span class="st0">'Test'</span><span class="br0">&#41;</span> , <span class="nu0">2</span> , <span class="nu0">4</span> , <span class="st0">'isdescending'</span> <span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">--index ix_test 
SELECT INDEXKEY_PROPERTY ( OBJECT_ID('Test') , 2 , 1 , 'isdescending' )
SELECT INDEXKEY_PROPERTY ( OBJECT_ID('Test') , 2 , 2 , 'isdescending' )
SELECT INDEXKEY_PROPERTY ( OBJECT_ID('Test') , 2 , 3 , 'isdescending' )
SELECT INDEXKEY_PROPERTY ( OBJECT_ID('Test') , 2 , 4 , 'isdescending' )</pre></div></div>


<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="co1">-- index ix_test_clust</span>
<span class="kw1">SELECT</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span> <span class="kw2">OBJECT_ID</span><span class="br0">&#40;</span><span class="st0">'Test'</span><span class="br0">&#41;</span> , <span class="nu0">1</span> , <span class="nu0">1</span> , <span class="st0">'isdescending'</span> <span class="br0">&#41;</span>
<span class="kw1">SELECT</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span> <span class="kw2">OBJECT_ID</span><span class="br0">&#40;</span><span class="st0">'Test'</span><span class="br0">&#41;</span> , <span class="nu0">1</span> , <span class="nu0">2</span> , <span class="st0">'isdescending'</span> <span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">-- index ix_test_clust
SELECT INDEXKEY_PROPERTY ( OBJECT_ID('Test') , 1 , 1 , 'isdescending' )
SELECT INDEXKEY_PROPERTY ( OBJECT_ID('Test') , 1 , 2 , 'isdescending' )</pre></div></div>

<p>Of course we are not amateurs and nobody wants to type all that stuff, we will just take the query from before and put the following in the select statement <em>INDEXKEY_PROPERTY (k.id,k.indid ,c.colid,&#8217;isdescending&#8217;) as IsDescending</em><br />
Run the code below to see how that works.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span>k.<span class="me1">id</span>,k.<span class="me1">indid</span> ,k.<span class="me1">keyno</span>,<span class="st0">'isdescending'</span><span class="br0">&#41;</span> <span class="kw1">as</span> IsDescending,<span class="kw2">OBJECT_NAME</span><span class="br0">&#40;</span>k.<span class="me1">id</span><span class="br0">&#41;</span> <span class="kw1">as</span> TableName,i.<span class="me1">name</span> <span class="kw1">as</span> IndexName,c.<span class="me1">name</span> <span class="kw1">as</span> ColumnName,c.<span class="me1">colid</span>,k.<span class="me1">indid</span> <span class="kw1">as</span> IndexID 
<span class="kw1">from</span> sys.<span class="me1">sysindexes</span> i
join sys.<span class="me1">sysindexkeys</span> k <span class="kw1">on</span> i.<span class="me1">id</span> <span class="sy0">=</span> k.<span class="me1">id</span>
and k.<span class="me1">indid</span> <span class="sy0">=</span> i.<span class="me1">indid</span>
join sys.<span class="me1">syscolumns</span> c <span class="kw1">on</span> k.<span class="me1">id</span> <span class="sy0">=</span> c.<span class="me1">id</span>
and k.<span class="me1">colid</span> <span class="sy0">=</span> c.<span class="me1">colid</span>
<span class="kw1">where</span> <span class="kw2">OBJECT_NAME</span><span class="br0">&#40;</span>k.<span class="me1">id</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="st0">'Test'</span>
<span class="kw1">order</span> <span class="kw1">by</span> <span class="kw2">OBJECT_NAME</span><span class="br0">&#40;</span>k.<span class="me1">id</span><span class="br0">&#41;</span>,i.<span class="me1">name</span>,k.<span class="me1">keyno</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select INDEXKEY_PROPERTY (k.id,k.indid ,k.keyno,'isdescending') as IsDescending,OBJECT_NAME(k.id) as TableName,i.name as IndexName,c.name as ColumnName,c.colid,k.indid as IndexID 
from sys.sysindexes i
join sys.sysindexkeys k on i.id = k.id
and k.indid = i.indid
join sys.syscolumns c on k.id = c.id
and k.colid = c.colid
where OBJECT_NAME(k.id) = 'Test'
order by OBJECT_NAME(k.id),i.name,k.keyno</pre></div></div>

<p>Here is the output</p>
<table border="1">
<tr>
<td>IsDescending</td>
<td>TableName</td>
<td> IndexName</td>
<td> ColumnName</td>
<td>keyno</td>
<td> IndexID</td>
</tr>
<tr>
<td>0</td>
<td>Test</td>
<td>	ix_test</td>
<td>id</td>
<td>1</td>
<td>	2</td>
</tr>
<tr>
<td>1</td>
<td>Test</td>
<td>	ix_test</td>
<td>col1</td>
<td>2</td>
<td>	2</td>
</tr>
<tr>
<td>1</td>
<td>Test</td>
<td>	ix_test</td>
<td>col2</td>
<td>3</td>
<td>	2</td>
</tr>
<tr>
<td>0</td>
<td>Test</td>
<td>	ix_test</td>
<td>col3</td>
<td>4</td>
<td>	2</td>
</tr>
<tr>
<td>0</td>
<td>Test</td>
<td>	ix_test_clust</td>
<td>id</td>
<td>1</td>
<td>	1</td>
</tr>
<tr>
<td>1</td>
<td>Test</td>
<td>	ix_test_clust</td>
<td>col1</td>
<td>2</td>
<td>	1</td>
</tr>
</table>
<p>Of course if you can do that you can also very simply write a query that returns all the columns that are sorted descending in any index by making the WHERE clause the following: where INDEXKEY_PROPERTY (k.id,k.indid ,k.keyno,&#8217;isdescending&#8217;) = 1. Run the query below to see how that works</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span>k.<span class="me1">id</span>,k.<span class="me1">indid</span> ,k.<span class="me1">keyno</span>,<span class="st0">'isdescending'</span><span class="br0">&#41;</span> <span class="kw1">as</span> IsDescending,<span class="kw2">OBJECT_NAME</span><span class="br0">&#40;</span>k.<span class="me1">id</span><span class="br0">&#41;</span> <span class="kw1">as</span> TableName,i.<span class="me1">name</span> <span class="kw1">as</span> IndexName,c.<span class="me1">name</span> <span class="kw1">as</span> ColumnName,k.<span class="me1">keyno</span>,k.<span class="me1">indid</span> <span class="kw1">as</span> IndexID 
<span class="kw1">from</span> sys.<span class="me1">sysindexes</span> i
join sys.<span class="me1">sysindexkeys</span> k <span class="kw1">on</span> i.<span class="me1">id</span> <span class="sy0">=</span> k.<span class="me1">id</span>
and k.<span class="me1">indid</span> <span class="sy0">=</span> i.<span class="me1">indid</span>
join sys.<span class="me1">syscolumns</span> c <span class="kw1">on</span> k.<span class="me1">id</span> <span class="sy0">=</span> c.<span class="me1">id</span>
and k.<span class="me1">colid</span> <span class="sy0">=</span> c.<span class="me1">colid</span>
<span class="kw1">where</span> <span class="kw2">INDEXKEY_PROPERTY</span> <span class="br0">&#40;</span>k.<span class="me1">id</span>,k.<span class="me1">indid</span> ,k.<span class="me1">keyno</span>,<span class="st0">'isdescending'</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="nu0">1</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select INDEXKEY_PROPERTY (k.id,k.indid ,k.keyno,'isdescending') as IsDescending,OBJECT_NAME(k.id) as TableName,i.name as IndexName,c.name as ColumnName,k.keyno,k.indid as IndexID 
from sys.sysindexes i
join sys.sysindexkeys k on i.id = k.id
and k.indid = i.indid
join sys.syscolumns c on k.id = c.id
and k.colid = c.colid
where INDEXKEY_PROPERTY (k.id,k.indid ,k.keyno,'isdescending') = 1</pre></div></div>

<p></p>
<p>*** <strong>If you have a SQL related question try our <a href="http://forum.lessthandot.com/viewforum.php?f=17">Microsoft SQL Server Programming</a> forum or our <a href="http://forum.lessthandot.com/viewforum.php?f=22">Microsoft SQL Server Admin</a> forum</strong><ins></ins></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/use-indexkey_property-in-sql-server-to-d/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>Replace Your Case When Then Else Syntax With the Sign Function In SQL Server</title>
		<link>/index.php/datamgmt/datadesign/replace-your-case-when-then-else-syntax/</link>
		<comments>/index.php/datamgmt/datadesign/replace-your-case-when-then-else-syntax/#comments</comments>
		<pubDate>Mon, 22 Jun 2009 12:50:30 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[functions]]></category>
		<category><![CDATA[howto]]></category>
		<category><![CDATA[sql server 2000]]></category>
		<category><![CDATA[sql server 2008]]></category>

		<guid isPermaLink="false">/index.php/2009/06/replace-your-case-when-then-else-syntax/</guid>
		<description><![CDATA[If you want to show a 1 when there is a value for something in the column and 0 if none of the rows have that values you typically do something like this T-SQL1 CASE WHEN SUM&#40;CONVERT&#40;INT,SomeValue&#41;&#41; &#62; 0 THEN 1 ELSE 0 END CASE WHEN SUM(CONVERT(INT,SomeValue)) &#62; 0 THEN 1 ELSE 0 END Basically [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>If you want to show a 1 when there is a value for something in the column and 0 if none of the rows have that values you typically do something like this</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CASE</span> <span class="kw1">WHEN</span> <span class="kw2">SUM</span><span class="br0">&#40;</span><span class="kw1">CONVERT</span><span class="br0">&#40;</span><span class="kw1">INT</span>,SomeValue<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu0">0</span> <span class="kw1">THEN</span> <span class="nu0">1</span> <span class="kw1">ELSE</span> <span class="nu0">0</span> <span class="kw1">END</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CASE WHEN SUM(CONVERT(INT,SomeValue)) &gt; 0 THEN 1 ELSE 0 END</pre></div></div>

<p>Basically you sum it up and if the sum is greater than 0 then you show 1 otherwise you show 0<br />
Here is what it might look like in code</p>
<p>First create the following table with this data</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
</pre></td><td class="de1"><pre class="de1"><span class="kw1">create</span> <span class="kw1">table</span> #Cars<span class="br0">&#40;</span>id <span class="kw1">int</span>,brand <span class="kw1">varchar</span><span class="br0">&#40;</span><span class="nu0">20</span><span class="br0">&#41;</span>,HasDefects <span class="kw1">bit</span><span class="br0">&#41;</span>
&nbsp;
<span class="kw1">insert</span> #Cars <span class="kw1">values</span><span class="br0">&#40;</span><span class="nu0">1</span>,<span class="st0">'Chevy Corvette'</span>,<span class="nu0">1</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #Cars <span class="kw1">values</span><span class="br0">&#40;</span><span class="nu0">2</span>,<span class="st0">'Ford Taurus'</span>,<span class="nu0">0</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #Cars <span class="kw1">values</span><span class="br0">&#40;</span><span class="nu0">3</span>,<span class="st0">'Ford Taurus'</span>,<span class="nu0">1</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #Cars <span class="kw1">values</span><span class="br0">&#40;</span><span class="nu0">4</span>,<span class="st0">'BMW 635 CSi'</span>,<span class="nu0">0</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #Cars <span class="kw1">values</span><span class="br0">&#40;</span><span class="nu0">5</span>,<span class="st0">'BMW 635 CSi'</span>,<span class="nu0">0</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #Cars <span class="kw1">values</span><span class="br0">&#40;</span><span class="nu0">6</span>,<span class="st0">'Fiat 500'</span>,<span class="nu0">1</span><span class="br0">&#41;</span>
<span class="kw1">insert</span> #Cars <span class="kw1">values</span><span class="br0">&#40;</span><span class="nu0">7</span>,<span class="st0">'Fiat 500'</span>,<span class="nu0">1</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">create table #Cars(id int,brand varchar(20),HasDefects bit)

insert #Cars values(1,'Chevy Corvette',1)
insert #Cars values(2,'Ford Taurus',0)
insert #Cars values(3,'Ford Taurus',1)
insert #Cars values(4,'BMW 635 CSi',0)
insert #Cars values(5,'BMW 635 CSi',0)
insert #Cars values(6,'Fiat 500',1)
insert #Cars values(7,'Fiat 500',1)</pre></div></div>

<p>And here is our CASE WHEN THEN ELSE query</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> brand,<span class="kw1">CASE</span> <span class="kw1">WHEN</span> <span class="kw2">SUM</span><span class="br0">&#40;</span><span class="kw1">convert</span><span class="br0">&#40;</span><span class="kw1">int</span>,HasDefects<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu0">0</span> <span class="kw1">THEN</span> <span class="nu0">1</span> <span class="kw1">ELSE</span> <span class="nu0">0</span> <span class="kw1">END</span> <span class="kw1">AS</span> HasDefects
<span class="kw1">from</span> #Cars
<span class="kw1">group</span> <span class="kw1">by</span> brand</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT brand,CASE WHEN SUM(convert(int,HasDefects)) &gt; 0 THEN 1 ELSE 0 END AS HasDefects
from #Cars
group by brand</pre></div></div>

<p>We need to convert HasDefects to an integer before using the sum function, otherwise you will get the following error</p>
<p><em>Server: Msg 409, Level 16, State 2, Line 1<br />
The sum or average aggregate operation cannot take a bit data type as an argument.</em></p>
<p>So how can we change that to use the sign function? It is very easy all you have to do is wrap the sign function around the sign function</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> brand, <span class="kw2">sign</span><span class="br0">&#40;</span><span class="kw2">sum</span><span class="br0">&#40;</span><span class="kw1">convert</span><span class="br0">&#40;</span><span class="kw1">int</span>,HasDefects<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="kw1">as</span> HasDefects
<span class="kw1">from</span> #Cars
<span class="kw1">group</span> <span class="kw1">by</span> brand</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select brand, sign(sum(convert(int,HasDefects))) as HasDefects
from #Cars
group by brand</pre></div></div>

<p>Here is our output<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;</p>
<pre>brand	HasDefects
BMW 635 CSi	0
Chevy Corvette	1
Fiat 500	1
Ford Taurus	1</pre>
<p>As you can see that made the code smaller by about 20 bytes. This of course will only work if you want 0 and 1; if you want more posibilities then you need to use case. Another reason why you maybe don&#8217;t want to use the sign function is that someone looking at your code might not immediately know what the code is supposed to do.<br />
Remember you should always write code with the assumption that the person who will be maintaining your code is a psychopatic killer who has your address  <img src="https://s.w.org/images/core/emoji/2/72x72/1f609.png" alt="😉" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p>How does the sign function work? </p>
<p>If the value is negative then -1 is returned<br />
If the value is positive then 1 is returned<br />
If the value is 0 then 0 is returned<br />
If the value is NULL then NULL is returned</p>
<p>Scale will affect the output also; if you use -22.0001 then  -1.0000 will be returned and if you use -22.01 then -1.00 will be returned<br />
Here is a query you can run to see what sign returns for different values</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="de1"><pre class="de1"><span class="kw1">select</span> &nbsp;<span class="kw2">sign</span> <span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span>, &nbsp;<span class="co1">-- 0</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span>, &nbsp;<span class="co1">-- 1</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span>, <span class="co1">-- -1</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span>null<span class="br0">&#41;</span>, <span class="co1">--null</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">200</span><span class="br0">&#41;</span>, <span class="co1">-- -1</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span><span class="nu0">200</span><span class="br0">&#41;</span>, &nbsp;<span class="co1">-- 1</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">22.0001</span><span class="br0">&#41;</span>, <span class="co1">-- -1.0000</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span><span class="nu0">22.0001</span><span class="br0">&#41;</span>, &nbsp;<span class="co1">-- 1.0000</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">22.01</span><span class="br0">&#41;</span>, <span class="co1">-- -1.00</span>
&nbsp; &nbsp; <span class="kw2">sign</span> <span class="br0">&#40;</span><span class="nu0">22.01</span><span class="br0">&#41;</span> &nbsp;<span class="co1">-- 1.00</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">select 	sign (0),  -- 0
	sign (1),  -- 1
	sign (-1), -- -1
	sign (null), --null
	sign (-200), -- -1
	sign (200),  -- 1
	sign (-22.0001), -- -1.0000
	sign (22.0001),  -- 1.0000
	sign (-22.01), -- -1.00
	sign (22.01)  -- 1.00</pre></div></div>

<p>On our wiki there is an article that shows you another 9 lesser know functions; these functions are</p>
<p>BINARY_CHECKSUM<br />
COLUMNPROPERTY<br />
DATALENGTH<br />
ASCII, CHAR,UNICODE<br />
NULLIF<br />
PARSENAME<br />
STUFF<br />
REVERSE<br />
GETUTCDATE</p>
<p>You can find that article here <a href="http://wiki.lessthandot.com/index.php/Ten_SQL_Server_Functions_That_You_Have_Ignored_Until_Now">Ten SQL Server Functions That You Have Ignored Until Now</a></p>
<p></p>
<p>*** <strong>If you have a SQL related question try our <a href="http://forum.lessthandot.com/viewforum.php?f=17">Microsoft SQL Server Programming</a> forum or our <a href="http://forum.lessthandot.com/viewforum.php?f=22">Microsoft SQL Server Admin</a> forum</strong><ins></ins></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/replace-your-case-when-then-else-syntax/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
	</channel>
</rss>
