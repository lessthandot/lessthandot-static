<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>t-sql &#8211; LessthanDot</title>
	<atom:link href="/index.php/tag/t-sql/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>A Technical Community for IT Professionals</description>
	<lastBuildDate>Sat, 09 Mar 2019 12:50:36 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.1</generator>
	<item>
		<title>Solving a slow running query issue with UNION</title>
		<link>/index.php/datamgmt/dbprogramming/mssqlserver/solving-a-slow-running-query-issue-with-union/</link>
		<comments>/index.php/datamgmt/dbprogramming/mssqlserver/solving-a-slow-running-query-issue-with-union/#comments</comments>
		<pubDate>Wed, 25 Feb 2015 11:38:03 +0000</pubDate>
		<dc:creator><![CDATA[Koen Verbeeck]]></dc:creator>
				<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[sql]]></category>
		<category><![CDATA[sql server]]></category>
		<category><![CDATA[syndicated]]></category>
		<category><![CDATA[t-sql]]></category>

		<guid isPermaLink="false">/?p=3253</guid>
		<description><![CDATA[That&#8217;s right! I will solve a performance issue by adding a UNION into the query. Interested? Read on! I recently encountered a curious issue with a query. The query itself wasn‚Äôt exactly rocket science: it read data from a few tables and calculated the start and the end dates of a contract in the SELECT [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>That&#8217;s right! I will solve a performance issue by adding a UNION into the query. Interested? Read on!</p>
<p>I recently encountered a curious issue with a query. The query itself wasn‚Äôt exactly rocket science: it read data from a few tables and calculated the start and the end dates of a contract in the SELECT statement. In an outer query there‚Äôs a range join with a date dimension to explode the data over the different months. Let me explain that last part. Suppose we have a contract with ID 5 that is valid between January 2015 and March 2015. The range join with the date dimension would thus return 3 rows:</p>
<p><a href="/wp-content/uploads/2015/02/Exploding.png"><img class="alignnone size-full wp-image-3257" src="/wp-content/uploads/2015/02/Exploding.png" alt="Exploding" width="187" height="97" /></a></p>
<p>The query looked something like this:</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="de1"><pre class="de1"><span class="kw1">WITH</span> CTE_Contracts <span class="kw1">AS</span>
<span class="br0">&#40;</span>
&nbsp; &nbsp; <span class="kw1">SELECT</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.<span class="me1">ContractID</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,ContractFrom &nbsp; <span class="sy0">=</span> IIF<span class="br0">&#40;</span> ... <span class="me1">some</span> <span class="kw1">date</span> logic<span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,ContractTo &nbsp; &nbsp; <span class="sy0">=</span> IIF<span class="br0">&#40;</span> ... <span class="me1">some</span> <span class="kw1">date</span> logic<span class="br0">&#41;</span>
&nbsp; &nbsp; <span class="kw1">FROM</span> contracts&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c
&nbsp; &nbsp; <span class="sy0">JOIN</span> contractsdetail&nbsp; &nbsp; cd <span class="kw1">ON</span> c.<span class="me1">ContractID</span> <span class="sy0">=</span> cd.<span class="me1">ContractID</span>
<span class="br0">&#41;</span>
<span class="kw1">SELECT</span>
&nbsp; &nbsp; &nbsp;ContractID
&nbsp; &nbsp; ,ContractMonth <span class="sy0">=</span> d.<span class="br0">&#91;</span><span class="kw1">Month</span><span class="br0">&#93;</span>
<span class="kw1">FROM</span> CTE_Contracts&nbsp; c
<span class="sy0">JOIN</span> dateDim&nbsp; &nbsp; &nbsp; &nbsp; d <span class="kw1">ON</span>&nbsp; &nbsp; d.<span class="br0">&#91;</span><span class="kw1">Date</span><span class="br0">&#93;</span>&nbsp; &nbsp; <span class="sy0">BETWEEN</span> c.<span class="me1">ContractFrom</span> <span class="sy0">AND</span> c.<span class="me1">ContractTo</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> d.<span class="br0">&#91;</span><span class="kw1">Day</span><span class="br0">&#93;</span> &nbsp; &nbsp; <span class="sy0">=</span> <span class="nu0">1</span>; <span class="co1">-- only get the first of the month </span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">WITH CTE_Contracts AS
(
	SELECT
		 c.ContractID
		,ContractFrom	= IIF( ... some date logic)
		,ContractTo		= IIF( ... some date logic)
	FROM contracts			c
	JOIN contractsdetail	cd ON c.ContractID = cd.ContractID
)
SELECT
	 ContractID
	,ContractMonth = d.[Month]
FROM CTE_Contracts	c
JOIN dateDim		d ON	d.[Date]	BETWEEN c.ContractFrom AND c.ContractTo
						AND	d.[Day]		= 1; -- only get the first of the month </pre></div></div>

<p>The query is a bit more complex, but you get the idea. On the test server, the query took 1 minute and 24 seconds to return about 90,000 rows. That‚Äôs a tad slow if you ask me. I didn‚Äôt see anything wrong with the query (and indexes wouldn‚Äôt help), so I just blamed it on the server and on the standard edition of SQL Server. That was until I came across a very similar query. That query did about the same thing, but it also fetched data from another table and appended it to the first result set with a UNION. Something like this:</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="de1"><pre class="de1"><span class="kw1">WITH</span> CTE_Contracts <span class="kw1">AS</span>
<span class="br0">&#40;</span>
&nbsp; &nbsp; <span class="kw1">SELECT</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.<span class="me1">ContractID</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,ContractFrom &nbsp; <span class="sy0">=</span> IIF<span class="br0">&#40;</span> ... <span class="me1">some</span> <span class="kw1">date</span> logic<span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,ContractTo &nbsp; &nbsp; <span class="sy0">=</span> IIF<span class="br0">&#40;</span> ... <span class="me1">some</span> <span class="kw1">date</span> logic<span class="br0">&#41;</span>
&nbsp; &nbsp; <span class="kw1">FROM</span> contracts&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c
&nbsp; &nbsp; <span class="sy0">JOIN</span> contractsdetail&nbsp; &nbsp; cd <span class="kw1">ON</span> c.<span class="me1">ContractID</span> <span class="sy0">=</span> cd.<span class="me1">ContractID</span>
&nbsp; &nbsp; <span class="kw1">UNION</span>
&nbsp; &nbsp; <span class="kw1">SELECT</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.<span class="me1">ContractID</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,ContractFrom &nbsp; <span class="sy0">=</span> IIF<span class="br0">&#40;</span> ... <span class="me1">some</span> <span class="kw1">date</span> logic<span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,ContractTo &nbsp; &nbsp; <span class="sy0">=</span> IIF<span class="br0">&#40;</span> ... <span class="me1">some</span> <span class="kw1">date</span> logic<span class="br0">&#41;</span>
&nbsp; &nbsp; <span class="kw1">FROM</span> contractsextra &nbsp; &nbsp; c
&nbsp; &nbsp; <span class="sy0">JOIN</span> contractsdetail&nbsp; &nbsp; cd <span class="kw1">ON</span> c.<span class="me1">ContractID</span> <span class="sy0">=</span> cd.<span class="me1">ContractID</span>
<span class="br0">&#41;</span>
<span class="kw1">SELECT</span>
&nbsp; &nbsp; &nbsp;ContractID
&nbsp; &nbsp; ,ContractMonth <span class="sy0">=</span> d.<span class="br0">&#91;</span><span class="kw1">Month</span><span class="br0">&#93;</span>
<span class="kw1">FROM</span> CTE_Contracts&nbsp; c
<span class="sy0">JOIN</span> dateDim&nbsp; &nbsp; &nbsp; &nbsp; d <span class="kw1">ON</span>&nbsp; &nbsp; d.<span class="br0">&#91;</span><span class="kw1">Date</span><span class="br0">&#93;</span>&nbsp; &nbsp; <span class="sy0">BETWEEN</span> c.<span class="me1">ContractFrom</span> <span class="sy0">AND</span> c.<span class="me1">ContractTo</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> d.<span class="br0">&#91;</span><span class="kw1">Day</span><span class="br0">&#93;</span> &nbsp; &nbsp; <span class="sy0">=</span> <span class="nu0">1</span>; <span class="co1">-- only get the first of the month</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">WITH CTE_Contracts AS
(
	SELECT
		 c.ContractID
		,ContractFrom	= IIF( ... some date logic)
		,ContractTo		= IIF( ... some date logic)
	FROM contracts			c
	JOIN contractsdetail	cd ON c.ContractID = cd.ContractID
	UNION
	SELECT
		 c.ContractID
		,ContractFrom	= IIF( ... some date logic)
		,ContractTo		= IIF( ... some date logic)
	FROM contractsextra		c
	JOIN contractsdetail	cd ON c.ContractID = cd.ContractID
)
SELECT
	 ContractID
	,ContractMonth = d.[Month]
FROM CTE_Contracts	c
JOIN dateDim		d ON	d.[Date]	BETWEEN c.ContractFrom AND c.ContractTo
						AND	d.[Day]		= 1; -- only get the first of the month</pre></div></div>

<p>Now this query returned about 120,000 rows in 6 seconds. What? More rows in less time? How‚Äôs that possible? Time to take a look at the execution plans. The execution plan of the second query:</p>
<p><a href="/wp-content/uploads/2015/02/executionplan_1.png"><img class="alignnone size-full wp-image-3258" src="/wp-content/uploads/2015/02/executionplan_1.png" alt="executionplan_1" width="852" height="511" srcset="/wp-content/uploads/2015/02/executionplan_1.png 852w, /wp-content/uploads/2015/02/executionplan_1-300x179.png 300w" sizes="(max-width: 852px) 100vw, 852px" /></a></p>
<p>You can clearly see the two paths of the union being merged with the hash match after which the results are joined to the date dimension using the nested loops.</p>
<p>The execution plan of the first query is a bit different:</p>
<p><a href="/wp-content/uploads/2015/02/executionplan_2.png"><img class="alignnone size-full wp-image-3255" src="/wp-content/uploads/2015/02/executionplan_2.png" alt="executionplan_2" width="1013" height="340" srcset="/wp-content/uploads/2015/02/executionplan_2.png 1013w, /wp-content/uploads/2015/02/executionplan_2-300x100.png 300w" sizes="(max-width: 1013px) 100vw, 1013px" /></a></p>
<p>The nested loops now gives a warning that there is no join predicate. This results in about 5 million rows, which are filtered later on with the Filter operator to the desired 90,000 rows. A bit of unnecessary overhead it seems. So the execution plan of the first query is a bit silly, since it calculates the date columns for the inner select after the join (in the Compute Scalar operator between the Filter and the Nested Loops). In the second query, these columns are calculated before the join and so the Nested Loops can use them as join predicates.</p>
<p>The question is why does SQL Server change behavior? Well, the second query has a UNION operator in the inner query. This means that SQL Server has to compare the two result sets which each other, so the date columns have to be calculated directly in the inner query. Knowing this, we can easily optimize the first query by adding a ‚Äúdummy UNION‚Äù:</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="de1"><pre class="de1"><span class="kw1">WITH</span> CTE_Contracts <span class="kw1">AS</span>
<span class="br0">&#40;</span>
&nbsp; &nbsp; <span class="kw1">SELECT</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.<span class="me1">ContractID</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,ContractFrom &nbsp; <span class="sy0">=</span> IIF<span class="br0">&#40;</span> ... <span class="me1">some</span> <span class="kw1">date</span> logic<span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,ContractTo &nbsp; &nbsp; <span class="sy0">=</span> IIF<span class="br0">&#40;</span> ... <span class="me1">some</span> <span class="kw1">date</span> logic<span class="br0">&#41;</span>
&nbsp; &nbsp; <span class="kw1">FROM</span> contracts&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c
&nbsp; &nbsp; <span class="sy0">JOIN</span> contractsdetail&nbsp; &nbsp; cd <span class="kw1">ON</span> c.<span class="me1">ContractID</span> <span class="sy0">=</span> cd.<span class="me1">ContractID</span>
&nbsp; &nbsp; <span class="kw1">UNION</span>
&nbsp; &nbsp; <span class="kw1">SELECT</span> <span class="sy0">NULL</span>, <span class="sy0">NULL</span>, <span class="sy0">NULL</span>, <span class="sy0">NULL</span> <span class="co1">-- just to enforce performance</span>
<span class="br0">&#41;</span>
<span class="kw1">SELECT</span>
&nbsp; &nbsp; &nbsp;ContractID
&nbsp; &nbsp; ,ContractMonth <span class="sy0">=</span> d.<span class="br0">&#91;</span><span class="kw1">Month</span><span class="br0">&#93;</span>
<span class="kw1">FROM</span> CTE_Contracts&nbsp; c
<span class="sy0">JOIN</span> dateDim&nbsp; &nbsp; &nbsp; &nbsp; d <span class="kw1">ON</span>&nbsp; &nbsp; d.<span class="br0">&#91;</span><span class="kw1">Date</span><span class="br0">&#93;</span>&nbsp; &nbsp; <span class="sy0">BETWEEN</span> c.<span class="me1">ContractFrom</span> <span class="sy0">AND</span> c.<span class="me1">ContractTo</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> d.<span class="br0">&#91;</span><span class="kw1">Day</span><span class="br0">&#93;</span> &nbsp; &nbsp; <span class="sy0">=</span> <span class="nu0">1</span>; <span class="co1">-- only get the first of the month </span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">WITH CTE_Contracts AS
(
	SELECT
		 c.ContractID
		,ContractFrom	= IIF( ... some date logic)
		,ContractTo		= IIF( ... some date logic)
	FROM contracts			c
	JOIN contractsdetail	cd ON c.ContractID = cd.ContractID
	UNION
	SELECT NULL, NULL, NULL, NULL -- just to enforce performance
)
SELECT
	 ContractID
	,ContractMonth = d.[Month]
FROM CTE_Contracts	c
JOIN dateDim		d ON	d.[Date]	BETWEEN c.ContractFrom AND c.ContractTo
						AND	d.[Day]		= 1; -- only get the first of the month </pre></div></div>

<p>This extra row with all NULL values will be filtered out by the INNER JOIN with the date dimension. Now the query runs in 3 seconds!</p>
<p><a href="/wp-content/uploads/2015/02/executionplan_3.png"><img class="alignnone size-full wp-image-3256" src="/wp-content/uploads/2015/02/executionplan_3.png" alt="executionplan_3" width="769" height="168" srcset="/wp-content/uploads/2015/02/executionplan_3.png 769w, /wp-content/uploads/2015/02/executionplan_3-300x65.png 300w" sizes="(max-width: 769px) 100vw, 769px" /></a></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/dbprogramming/mssqlserver/solving-a-slow-running-query-issue-with-union/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
		</item>
		<item>
		<title>Beware the defaults! (in windowing functions) &#8211; The Movie!</title>
		<link>/index.php/datamgmt/dbprogramming/mssqlserver/beware-the-defaults-in-windowing-functions-the-movie/</link>
		<comments>/index.php/datamgmt/dbprogramming/mssqlserver/beware-the-defaults-in-windowing-functions-the-movie/#comments</comments>
		<pubDate>Thu, 27 Nov 2014 14:30:53 +0000</pubDate>
		<dc:creator><![CDATA[Koen Verbeeck]]></dc:creator>
				<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[online training]]></category>
		<category><![CDATA[sql server]]></category>
		<category><![CDATA[syndicated]]></category>
		<category><![CDATA[t-sql]]></category>
		<category><![CDATA[webucator]]></category>
		<category><![CDATA[windowing functions]]></category>

		<guid isPermaLink="false">/?p=3071</guid>
		<description><![CDATA[I was recently contacted by the fine gents of Webucator, an online training services provider. In order to promote their SQL Server classes, they are doing a free series called¬†SQL Server Solutions from the Web where they show different SQL Server solutions found in blog posts around the web. Essentially, they are turning blog posts [&#8230;]]]></description>
				<content:encoded><![CDATA[<p style="text-align: justify;">I was recently contacted by the fine gents of <a href="https://www.webucator.com/">Webucator</a>, an online training services provider. In order to promote their <a href="https://www.webucator.com/database/mssql.cfm">SQL Server classes</a>, they are doing a free series called¬†<em>SQL Server Solutions from the Web</em> where they show different SQL Server solutions found in blog posts around the web. Essentially, they are turning blog posts into videos. They asked me if they could turn my blog post¬†<a href="/index.php/datamgmt/dbprogramming/mssqlserver/beware-the-defaults-in-windowing-functions/">Beware the defaults! (in windowing functions)</a>¬†into such a video and &#8211; humble as I am &#8211; I gave them permission to do so. And the result is now here for everyone to watch:</p>
<p><iframe width="500" height="281" src="https://www.youtube.com/embed/nBUnoVRjVSA?feature=oembed" frameborder="0" allowfullscreen></iframe></p>
<p style="text-align: justify;"><a href="https://www.youtube.com/watch?v=nBUnoVRjVSA">URL to Youtube video</a></p>
<p style="text-align: justify;">I&#8217;m quite pleased with the video &#8211; excellent <a href="http://technet.microsoft.com/en-us/sysinternals/bb897434.aspx">Zoomit </a>use by the way &#8211; as it highlights the most important aspects of my blog post:</p>
<ul style="text-align: justify;">
<li>For regular aggregation functions using the OVER clause, do not use the ORDER BY unless necessary because this invokes the horrible default of RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW.</li>
<li>If you do use the ORDER BY specify a correct sorting order.</li>
</ul>
<p style="text-align: justify;">Or even better, specify ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW or another framing option. Just not the default <img src="https://s.w.org/images/core/emoji/2/72x72/1f642.png" alt="üôÇ" class="wp-smiley" style="height: 1em; max-height: 1em;" /><br />
The one thing missing in the video &#8211; and I must confess I didn&#8217;t highlight it enough in my blog post &#8211; is the massive performance difference between ROWS and RANGE. I&#8217;m re-reading the excellent book by Itzik Ben-Gan about the <a href="http://www.amazon.com/Microsoft-High-Performance-Functions-Developer-Reference/dp/0735658366/ref=sr_1_1?ie=UTF8&amp;qid=1417091814&amp;sr=8-1&amp;keywords=windowing+functions">T-SQL windowing functions</a>¬†and there Itzik explains why this is the case. In a nutshell:</p>
<p style="text-align: justify;">When using the ROWS window frame extent, the window spool operator can use an optimized in-memory work table which speeds things up tremendously. However, when using RANGE the typical on-disk work table has to be used, which is of course much slower. In theory, RANGE is equal to ROWS when the ordering values are unique within the partition, but the optimizer doesn&#8217;t check for uniqueness so RANGE will always default to the on-disk work table.</p>
<p style="text-align: justify;">If you were not convinced to always specify ROWS instead of the default RANGE, I hope you now are.</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/dbprogramming/mssqlserver/beware-the-defaults-in-windowing-functions-the-movie/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
		</item>
		<item>
		<title>Beware the defaults! (in windowing functions)</title>
		<link>/index.php/datamgmt/dbprogramming/mssqlserver/beware-the-defaults-in-windowing-functions/</link>
		<comments>/index.php/datamgmt/dbprogramming/mssqlserver/beware-the-defaults-in-windowing-functions/#comments</comments>
		<pubDate>Tue, 07 Oct 2014 12:22:28 +0000</pubDate>
		<dc:creator><![CDATA[Koen Verbeeck]]></dc:creator>
				<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[sql]]></category>
		<category><![CDATA[syndicated]]></category>
		<category><![CDATA[t-sql]]></category>
		<category><![CDATA[windowing functions]]></category>

		<guid isPermaLink="false">/?p=3007</guid>
		<description><![CDATA[Some time ago I was writing some windowing functions on a set of data. Basically I was looking for the last date an event had occurred for each type of event. Let‚Äôs illustrate with an example: T-SQL1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CREATE TABLE dbo.TestOver &#160; [&#8230;]]]></description>
				<content:encoded><![CDATA[<p style="text-align: justify">Some time ago I was writing some windowing functions on a set of data. Basically I was looking for the last date an event had occurred for each type of event. Let‚Äôs illustrate with an example:</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> dbo.<span class="me1">TestOver</span>
&nbsp; &nbsp; <span class="br0">&#40;</span>ID <span class="kw1">INT</span> <span class="kw1">IDENTITY</span><span class="br0">&#40;</span><span class="nu0">1</span>,<span class="nu0">1</span><span class="br0">&#41;</span> <span class="kw1">PRIMARY</span> <span class="kw1">KEY</span> <span class="sy0">NOT</span> <span class="sy0">NULL</span>
&nbsp; &nbsp; ,<span class="br0">&#91;</span><span class="kw1">Group</span><span class="br0">&#93;</span> <span class="kw1">CHAR</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">NOT</span> <span class="sy0">NULL</span>
&nbsp; &nbsp; ,<span class="kw1">Value</span> <span class="kw1">INT</span> <span class="sy0">NOT</span> <span class="sy0">NULL</span><span class="br0">&#41;</span>;
&nbsp;
<span class="kw1">INSERT</span> <span class="kw1">INTO</span> dbo.<span class="me1">TestOver</span><span class="br0">&#40;</span><span class="br0">&#91;</span><span class="kw1">Group</span><span class="br0">&#93;</span>,<span class="kw1">Value</span><span class="br0">&#41;</span>
<span class="kw1">VALUES</span>&nbsp; &nbsp;<span class="br0">&#40;</span><span class="st0">'A'</span>,<span class="nu0">1</span><span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,<span class="br0">&#40;</span><span class="st0">'A'</span>,<span class="nu0">2</span><span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,<span class="br0">&#40;</span><span class="st0">'A'</span>,<span class="nu0">3</span><span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,<span class="br0">&#40;</span><span class="st0">'A'</span>,<span class="nu0">4</span><span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,<span class="br0">&#40;</span><span class="st0">'B'</span>,<span class="nu0">5</span><span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,<span class="br0">&#40;</span><span class="st0">'B'</span>,<span class="nu0">6</span><span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,<span class="br0">&#40;</span><span class="st0">'B'</span>,<span class="nu0">7</span><span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,<span class="br0">&#40;</span><span class="st0">'B'</span>,<span class="nu0">8</span><span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp; ,<span class="br0">&#40;</span><span class="st0">'B'</span>,<span class="nu0">9</span><span class="br0">&#41;</span>;</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE dbo.TestOver
	(ID INT IDENTITY(1,1) PRIMARY KEY NOT NULL
	,[Group] CHAR(1) NOT NULL
	,Value INT NOT NULL);

INSERT INTO dbo.TestOver([Group],Value)
VALUES	 ('A',1)
		,('A',2)
		,('A',3)
		,('A',4)
		,('B',5)
		,('B',6)
		,('B',7)
		,('B',8)
		,('B',9);</pre></div></div>

<p style="text-align: justify">Using the data above, I need to find the value 4 for group A and the value 9 for group B. I first wrote the following T-SQL statement to retrieve the data:</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw1">DISTINCT</span> <span class="br0">&#91;</span><span class="kw1">Group</span><span class="br0">&#93;</span>, <span class="kw2">MAX</span><span class="br0">&#40;</span><span class="kw1">Value</span><span class="br0">&#41;</span> <span class="kw1">OVER</span> <span class="br0">&#40;</span>PARTITION <span class="kw1">BY</span> <span class="br0">&#91;</span><span class="kw1">Group</span><span class="br0">&#93;</span> <span class="kw1">ORDER</span> <span class="kw1">BY</span> <span class="kw1">Value</span><span class="br0">&#41;</span>
<span class="kw1">FROM</span> dbo.<span class="me1">TestOver</span>;</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DISTINCT [Group], MAX(Value) OVER (PARTITION BY [Group] ORDER BY Value)
FROM dbo.TestOver;</pre></div></div>

<p style="text-align: justify"><a href="/wp-content/uploads/2014/10/query1.png"><img class="alignnone size-full wp-image-3013" src="/wp-content/uploads/2014/10/query1.png" alt="query1" width="595" height="290" srcset="/wp-content/uploads/2014/10/query1.png 595w, /wp-content/uploads/2014/10/query1-300x146.png 300w" sizes="(max-width: 595px) 100vw, 595px" /></a></p>
<p style="text-align: justify">The results are of course incorrect. A little baffled why this was the cause, I changed the ORDER BY to descending which gave me the results I wanted.</p>
<p style="text-align: justify"><a href="/wp-content/uploads/2014/10/query2.png"><img class="alignnone size-full wp-image-3011" src="/wp-content/uploads/2014/10/query2.png" alt="query2" width="617" height="142" srcset="/wp-content/uploads/2014/10/query2.png 617w, /wp-content/uploads/2014/10/query2-300x69.png 300w" sizes="(max-width: 617px) 100vw, 617px" /></a></p>
<p style="text-align: justify">I really didn‚Äôt think twice over this, until I joined the session <a href="http://www.sqlserverdays.be/powerful-t-sql-improvements-that-reduce-query-complexity/">Powerful T-SQL Improvements that Reduce Query Complexity</a> by Hugo Kornelis (<a href="http://sqlblog.com/blogs/hugo_kornelis/">blog</a> | <a href="https://twitter.com/Hugo_Kornelis">twitter</a>) on the SQL Server Days. I learned two things.</p>
<ol style="text-align: justify">
<li>You don‚Äôt need to specify the ORDER BY.</li>
</ol>
<p style="text-align: justify">In SQL Server 2005, the <a href="http://msdn.microsoft.com/en-us/library/ms189461(v=sql.90).aspx">OVER clause</a> was introduced and it simplified some aggregations like the one we‚Äôre doing here. When using the ranking window functions the ORDER BY clause is mandatory, but when using a regular aggregate window function the ORDER BY clause is not allowed. This gives us the following T-SQL which is the perfect solution for our problem here:</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw1">DISTINCT</span> <span class="br0">&#91;</span><span class="kw1">Group</span><span class="br0">&#93;</span>, <span class="kw2">MAX</span><span class="br0">&#40;</span><span class="kw1">Value</span><span class="br0">&#41;</span> <span class="kw1">OVER</span> <span class="br0">&#40;</span>PARTITION <span class="kw1">BY</span> <span class="br0">&#91;</span><span class="kw1">Group</span><span class="br0">&#93;</span><span class="br0">&#41;</span>
<span class="kw1">FROM</span> dbo.<span class="me1">TestOver</span>;</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT DISTINCT [Group], MAX(Value) OVER (PARTITION BY [Group])
FROM dbo.TestOver;</pre></div></div>

<p style="text-align: justify">To be honest, I completely forgot aggregate functions could be used this way. The PARTITION BY clause is optional as well, so you can have a completely empty OVER clause.</p>
<ol style="text-align: justify" start="2">
<li>When you do specify the ORDER BY, defaults come into play.</li>
</ol>
<p style="text-align: justify">Starting from SQL Server 2012, the T-SQL windowing functions and the <a href="http://msdn.microsoft.com/en-us/library/ms189461(v=sql.120).aspx">OVER clause</a> were greatly enhanced. Suddenly you can specify an ORDER BY for the aggregate windowing functions (which I did in the first attempts, remember?). However, if you specify an ORDER BY clause but no ROW or RANGE clause, SQL Server will apply the following defaults: RANGE UNBOUNDED PRECEDING as the lower limit and CURRENT ROW for the upper limit of the window. When Hugo explained this, I had my ‚ÄúEureka‚Äù moment (or rather my ‚ÄúHow could I have been this stupid?‚Äù moment). Because of these defaults, the MAX aggregate was calculated over the wrong windows! Let‚Äôs illustrate the concept for group A:</p>
<p style="text-align: justify"><a href="/wp-content/uploads/2014/10/windows.png"><img class="alignnone size-full wp-image-3012" src="/wp-content/uploads/2014/10/windows.png" alt="windows" width="204" height="189" /></a></p>
<p style="text-align: justify">Because of the defaults, the first window is limited to only one row. This means the MAX aggregate will return the value 1. In the second window, two rows are included and MAX will return 2 and so on. By reversing the sort order, the value 4 will always be included in the windows, so MAX will return the correct answers. However dropping the ORDER BY is in my opinion the cleanest option to solve the problem.</p>
<p style="text-align: justify"><strong>Conclusion</strong></p>
<p style="text-align: justify">Learn your T-SQL syntax and be aware of the defaults! Hugo also mentioned that ROWS <del>might</del>¬†<strong>will</strong> have better performance than RANGE, so you better always specify your window frames to avoid the default.</p>
<p style="text-align: justify"><i>Update: I was contacted by the amazing Rob Farley who told me that ROWS will beat RANGE any day of the week and that you should always specify ROWS unless you really need RANGE.</i></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/dbprogramming/mssqlserver/beware-the-defaults-in-windowing-functions/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>Why avoiding multiple code blocks in a Stored Procedure</title>
		<link>/index.php/datamgmt/dbprogramming/why-avoiding-multiple-code-blocks/</link>
		<comments>/index.php/datamgmt/dbprogramming/why-avoiding-multiple-code-blocks/#respond</comments>
		<pubDate>Mon, 21 Jan 2013 11:45:00 +0000</pubDate>
		<dc:creator><![CDATA[Axel Achten (axel8s)]]></dc:creator>
				<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[case]]></category>
		<category><![CDATA[if else]]></category>
		<category><![CDATA[procedure cache]]></category>
		<category><![CDATA[t-sql]]></category>

		<guid isPermaLink="false">/index.php/2013/01/why-avoiding-multiple-code-blocks/</guid>
		<description><![CDATA[It was a little remark from Bob Beauchemin (B&#124;T) during the Belgian SQL Server Days that started me writing this post.
Showing cached Execution Plans
In this post I‚Äôm going to use information from the following Dynamic Management Views and Functions t&#8230;]]></description>
				<content:encoded><![CDATA[<p>It was a little remark from Bob Beauchemin (<a href="http://www.sqlskills.com/blogs/bobb">B</a>|<a href="https://twitter.com/bobbeauch">T</a>) during the <a href="http://www.sqlserverdays.be/">Belgian SQL Server Days</a> that started me writing this post.</p>
<p><b>Showing cached Execution Plans</b><br />
In this post I‚Äôm going to use information from the following Dynamic Management Views and Functions to show some information about the cached Execution Plans of the queries used in this post:</p>
<ul>
<li>sys.dm_exec_cached_plans shows types, usage, size‚Ä¶ of the Execution Plans;</li>
<li>sys.dm_exec_sql_text shows the actual code of the query;</li>
<li>sys.dm_exec_query_plan is used to get the XML Execution Plan itself.</li>
</ul>
<p>In fact I use following query to get the results:</p>
<pre>SELECT cp.objtype, cp.cacheobjtype, cp.usecounts, cp.size_in_bytes, st.[text], qp.query_plan
	FROM sys.dm_exec_cached_plans cp
	CROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) st
	CROSS APPLY sys.dm_exec_query_plan (cp.plan_handle)qp;</pre>
<p>The result set of this query looks like this:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB1.JPG?mtime=1358775444"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB1.JPG?mtime=1358775444" width="933" height="427" /></a></div>
<p>The result set can contain thousands of rows, depending on the uptime of the server, the number of queries and their corresponding execution plans, the available buffer memory‚Ä¶</p>
<p><b>IF using 2 code blocks</b><br />
So let‚Äôs create a simple Stored Procedure that executes against the AdventureWorks2008R2 database:</p>
<pre>USE AdventureWorks2008R2;
GO

CREATE PROCEDURE TwoPlans
	@IfParameter int
AS
	SET NOCOUNT ON;
	IF @IfParameter = 1
		SELECT a.City, COUNT(bea.AddressID) EmployeeCount
		FROM Person.BusinessEntityAddress bea 
			INNER JOIN Person.Address a
				ON bea.AddressID = a.AddressID
		GROUP BY a.City
		ORDER BY a.City
	ELSE
		SELECT DATEPART(yyyy,OrderDate) AS N'Year'
			,SUM(TotalDue) AS N'Total Order Amount'
		FROM Sales.SalesOrderHeader
		GROUP BY DATEPART(yyyy,OrderDate)
		ORDER BY DATEPART(yyyy,OrderDate);
GO</pre>
<p>The results of the query aren‚Äôt important what is important is to see what happens in the Procedure Cache. To be able to see what‚Äôs happening we are going to empty the procedure cache:</p>
<p><span class="MT_red">WARNING: executing the following code deletes all cached plans from the Procedure Cache. All Execution Plans need to be recompiled. This can result in a slow or unresponsive server.<br />
DON‚ÄôT EXECUTE THE FOLLOWING CODE ON A PRODUCTION SERVER!!!<br />
</span></p>
<pre>DBCC FREEPROCCACHE;
GO</pre>
<p>When you execute our first query again:</p>
<pre>SELECT cp.objtype, cp.cacheobjtype, cp.usecounts, cp.size_in_bytes, st.[text], qp.query_plan
	FROM sys.dm_exec_cached_plans cp
	CROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) st
	CROSS APPLY sys.dm_exec_query_plan (cp.plan_handle)qp;</pre>
<p>You can see in the result set that only the Execution Plan from the above query is stored in the Procedure Cache.</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB2.JPG?mtime=1358775444"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB2.JPG?mtime=1358775444" width="871" height="67" /></a></div>
<p>Now execute the stored procedure:</p>
<pre>EXEC TwoPlans 1;
GO</pre>
<p>Execute the query against the Procedure Cache again:</p>
<pre>SELECT cp.objtype, cp.cacheobjtype, cp.usecounts, cp.size_in_bytes, st.[text], qp.query_plan
	FROM sys.dm_exec_cached_plans cp
	CROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) st
	CROSS APPLY sys.dm_exec_query_plan (cp.plan_handle)qp;</pre>
<p>The result set shows us the execution of the above query with a usecount of 2 and the Execution Plan of our Stored Procedure:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB3.JPG?mtime=1358775444"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB3.JPG?mtime=1358775444" width="871" height="85" /></a></div>
<p>Now click the XML link in the query_plan column. A new tab will open in SSMS showing you the XML Execution Plan:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB4.JPG?mtime=1358775444"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB4.JPG?mtime=1358775444" width="1434" height="865" /></a></div>
<p>You can now read the XML plan and you will find both the statements in the query plan:</p>
<pre>ShowPlanXML xmlns="http://schemas.microsoft.com/sqlserver/2004/07/showplan" Version="1.1" Build="10.50.2500.0"&gt;
  &lt;BatchSequence&gt;
    &lt;Batch&gt;
      &lt;Statements&gt;
        &lt;StmtSimple StatementText="CREATE procedure TwoPlans&amp;#xD;&amp;#xA;&amp;#x9;@IfParameter int&amp;#xD;&amp;#xA;as&amp;#xD;&amp;#xA;&amp;#x9;SET NOCOUNT ON;&amp;#xD;&amp;#xA;" StatementId="1" StatementCompId="3" StatementType="SET ON/OFF" /&gt;
        &lt;StmtCond StatementText="&amp;#x9;If @IfParameter = 1&amp;#xD;&amp;#xA;&amp;#x9;" StatementId="2" StatementCompId="4" StatementType="COND"&gt;
          &lt;Condition /&gt;
          &lt;Then&gt;
            &lt;Statements&gt;
              &lt;StmtSimple StatementText="&amp;#x9;SELECT a.City, COUNT(bea.AddressID) EmployeeCount&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;FROM Person.BusinessEntityAddress bea &amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;&amp;#x9;INNER JOIN Person.Address a&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;&amp;#x9;&amp;#x9;ON bea.AddressID = a.AddressID&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;GROUP BY a.City&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;ORDER BY a.City&amp;#xD;&amp;#xA;" StatementId="3" StatementCompId="5" StatementType="SELECT" StatementSubTreeCost="0.604708" StatementEstRows="574.696" StatementOptmLevel="FULL" QueryHash="0x03E92D79FC617C86" QueryPlanHash="0xED13B89036D1A5E6" StatementOptmEarlyAbortReason="GoodEnoughPlanFound"&gt;
                &lt;StatementSetOptions QUOTED_IDENTIFIER="true" ARITHABORT="true" CONCAT_NULL_YIELDS_NULL="true" ANSI_NULLS="true" ANSI_PADDING="true" ANSI_WARNINGS="true" NUMERIC_ROUNDABORT="false" /&gt;
                &lt;QueryPlan CachedPlanSize="32" CompileTime="7" CompileCPU="7" CompileMemory="344"&gt;‚Ä¶
             &lt;/StmtSimple&gt;
            &lt;/Statements&gt;
          &lt;/Then&gt;
          &lt;Else&gt;
            &lt;Statements&gt;
              &lt;StmtSimple StatementText="&amp;#x9;Else&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;SELECT DATEPART(yyyy,OrderDate) AS N'Year'&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;&amp;#x9;,SUM(TotalDue) AS N'Total Order Amount'&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;FROM Sales.SalesOrderHeader&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;GROUP BY DATEPART(yyyy,OrderDate)&amp;#xD;&amp;#xA;&amp;#x9;&amp;#x9;ORDER BY DATEPART(yyyy,OrderDate);&amp;#xD;" StatementId="4" StatementCompId="8" StatementType="SELECT" StatementSubTreeCost="0.780189" StatementEstRows="4" StatementOptmLevel="FULL" QueryHash="0xA73814A2D4649412" QueryPlanHash="0x7A5BDE1102728DAA" StatementOptmEarlyAbortReason="GoodEnoughPlanFound"&gt;‚Ä¶
            &lt;/Statements&gt;
          &lt;/Else&gt;
        &lt;/StmtCond&gt;
      &lt;/Statements&gt;
    &lt;/Batch&gt;
  &lt;/BatchSequence&gt;
&lt;/ShowPlanXML&gt;</pre>
<p>An easier trick to see the Graphical Execution Plans is to open <a href="http://www.sqlsentry.com/plan-explorer/sql-server-query-view.asp">SQL Sentry Plan Explorer</a> and copy the XML into the Plan XML tab:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB5.JPG?mtime=1358775444"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB5.JPG?mtime=1358775444" width="652" height="298" /></a></div>
<p>After doing this SQL Sentry Plan Explorer will give you all the details about the Execution Plan and you‚Äôll see in the Plan Diagram that SQL Server created an Execution Plan for both the queries altough only the first one was used:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB6.JPG?mtime=1358775445"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB6.JPG?mtime=1358775445" width="1347" height="765" /></a></div>
<p><b>IF calling 2 Stored Procedures</b><br />
Now let‚Äôs create 2 Stored Procedures that each will execute 1 part of the code from the previous query:</p>
<pre>CREATE PROCEDURE EmpCntCity
AS
	SET NOCOUNT ON;
	SELECT a.City, COUNT(bea.AddressID) EmployeeCount
	FROM Person.BusinessEntityAddress bea 
		INNER JOIN Person.Address a
			ON bea.AddressID = a.AddressID
	GROUP BY a.City
	ORDER BY a.City;
GO

CREATE PROCEDURE OrderAmountYear
AS
	SET NOCOUNT ON;
	SELECT DATEPART(yyyy,OrderDate) AS N'Year'
		,SUM(TotalDue) AS N'Total Order Amount'
	FROM Sales.SalesOrderHeader
	GROUP BY DATEPART(yyyy,OrderDate)
	ORDER BY DATEPART(yyyy,OrderDate);
GO</pre>
<p>Next we create a Stored Procedure that will contain the IF‚Ä¶ELSE logic and based on the input parameter will execute one of the above Stored Procedures:</p>
<pre>CREATE PROCEDURE TwoProcs
	@IfParameter int
AS
	SET NOCOUNT ON;
	IF @IfParameter = 1
		EXEC EmpCntCity
	ELSE
		EXEC OrderAmountYear;
GO</pre>
<p>Now we can call our Stored Procedure and execute 1 of the Stored Procedures:</p>
<pre>EXEC TwoProcs 1;
GO</pre>
<p>Let‚Äôs again query the Procedure Cache:</p>
<pre>SELECT cp.objtype, cp.cacheobjtype, cp.usecounts, cp.size_in_bytes, st.[text], qp.query_plan
	FROM sys.dm_exec_cached_plans cp
	CROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) st
	CROSS APPLY sys.dm_exec_query_plan (cp.plan_handle)qp;</pre>
<p>And have a look at the result:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB7.JPG?mtime=1358775445"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/IFCB7.JPG?mtime=1358775445" width="919" height="125" /></a></div>
<p>Now we see that executing the second Stored Procedure also created 2 Executions Plans: 1 for the Stored Procedure ‚ÄúTwoProcs‚Äù and one for the Stored Procedure ‚ÄúEmpCntCity‚Äù that was effectively executed. But we see that there was no Execution Plan created for the Stored Procedure ‚ÄúOrderAmountYear‚Äù. And this Execution Plan was more complex than the Execution Plan of our ‚ÄúTwoProcs‚Äù Stored Procedure. We can also see that the sum of the sizes of the 2 Execution Plans (65536 + 16384 = 81920) is still smaller than the Execution Plan of the ‚ÄúTwoPlans‚Äù Stored Procedure (98304).</p>
<p><b>Conclusion</b><br />
Avoid Stored Procedures that contain complete code blocks encapsulated in IF&#8230;ELSE or CASE blocks. It will result in SQL Server creating Execution Plans for all possibilities, consuming more Buffer Cache (memory) and in the end slow down the execution of the code.<br />
As a bonus, troubleshooting the individual Stored Procedures will be much easier and there is a bigger chance that you can reuse the Stored Procedures.</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/dbprogramming/why-avoiding-multiple-code-blocks/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Scripts to Detect Data Warehouse Issues</title>
		<link>/index.php/webdev/business-intelligence/scripts-to-detect-data-warehouse/</link>
		<comments>/index.php/webdev/business-intelligence/scripts-to-detect-data-warehouse/#comments</comments>
		<pubDate>Tue, 15 Jan 2013 12:31:00 +0000</pubDate>
		<dc:creator><![CDATA[Sam Vanga]]></dc:creator>
				<category><![CDATA[Business Intelligence]]></category>
		<category><![CDATA[best practices]]></category>
		<category><![CDATA[data warehouse]]></category>
		<category><![CDATA[t-sql]]></category>

		<guid isPermaLink="false">/index.php/2013/01/scripts-to-detect-data-warehouse/</guid>
		<description><![CDATA[Standards and best practices are like flu shots you take before you're infected; Database best practices protect your databases from bad things. But, we all make mistakes. It could be because we're on a time crunch, or we're lazy (which I'm guilty of by&#8230;]]></description>
				<content:encoded><![CDATA[<p>Standards and best practices are like flu shots you take before you&#8217;re infected; Database best practices protect your databases from bad things. But, we all make mistakes. It could be because we&#8217;re on a time crunch, or we&#8217;re lazy (which I&#8217;m guilty of by the way), or maybe it&#8217;s part of being a developer.</p>
<p>Common mistakes include: tables without a primary key, column name problems, missing foreign keys, etc., This is where I love LTD&#8217;s very own <a title="SQLCop" href="http://sqlcop.lessthandot.com/">SQLCop</a>. I can quickly go on with my database development and rely on SQLCop to <a title="SQLCop detects these issues" href="http://sqlcop.lessthandot.com/detectedissues.php">detect the issues</a>. It saves time and ensures that database standards are met.</p>
<p>However, there are some issues explicit to data warehouses that SQLCop doesn&#8217;t look for. I list those issues below and provide scripts to detect them. I use these scripts in conjunction with SQLCop.</p>
<h4>Detect tables in a data warehouse that aren&#8217;t prefixed with either Dim or Fact:</h4>
<p>Tables in a warehouse are generally prefixed with Dim and Fact for dimensions and fact respectively, to easily distinguish them.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> &nbsp;<span class="br0">&#91;</span>schema_name<span class="br0">&#93;</span> <span class="sy0">=</span> s.<span class="me1">name</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; table_name <span class="sy0">=</span> t.<span class="me1">name</span>
<span class="kw1">FROM</span> &nbsp; &nbsp;sys.<span class="me1">tables</span> t
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">schemas</span> s <span class="kw1">ON</span> s.<span class="me1">schema_id</span> <span class="sy0">=</span> t.<span class="me1">schema_id</span>
<span class="kw1">WHERE</span> &nbsp; t.<span class="me1">name</span> <span class="sy0">NOT</span> <span class="sy0">LIKE</span> <span class="st0">'Dim%'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> t.<span class="me1">name</span> <span class="sy0">NOT</span> <span class="sy0">LIKE</span> <span class="st0">'Fact%'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> t.<span class="me1">TYPE</span> <span class="sy0">=</span> <span class="st0">'U'</span>;</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT  [schema_name] = s.name ,
        table_name = t.name
FROM    sys.tables t
        INNER JOIN sys.schemas s ON s.schema_id = t.schema_id
WHERE   t.name NOT LIKE 'Dim%'
        AND t.name NOT LIKE 'Fact%'
        AND t.TYPE = 'U';</pre></div></div>

</p>
<h4>Find tables in a data warehouse that don&#8217;t have a primary key:</h4>
<p>Like in OLTP databases, all tables in a data warehouse also should have a primary key defined.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> &nbsp;schema_name <span class="sy0">=</span> SCHEMA_NAME<span class="br0">&#40;</span>schema_id<span class="br0">&#41;</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; table_name <span class="sy0">=</span> name
<span class="kw1">FROM</span> &nbsp; &nbsp;sys.<span class="me1">tables</span>
<span class="kw1">WHERE</span> &nbsp; <span class="kw2">OBJECTPROPERTY</span><span class="br0">&#40;</span><span class="kw2">OBJECT_ID</span>, <span class="st0">'TableHasPrimaryKey'</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="nu0">0</span>
<span class="kw1">ORDER</span> <span class="kw1">BY</span> SCHEMA_NAME<span class="br0">&#40;</span>schema_id<span class="br0">&#41;</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; name;</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT  schema_name = SCHEMA_NAME(schema_id) ,
        table_name = name
FROM    sys.tables
WHERE   OBJECTPROPERTY(OBJECT_ID, 'TableHasPrimaryKey') = 0
ORDER BY SCHEMA_NAME(schema_id) ,
        name;</pre></div></div>

<p>¬†</p>
<h4>Detect dimension tables with a composite primary key:</h4>
<p>A composite primary key on a dimension table causes degraded performance. It is best to create a single column primary key.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> &nbsp;c.<span class="me1">TABLE_NAME</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw2">COUNT</span><span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span>
<span class="kw1">FROM</span> &nbsp; &nbsp;<span class="sy0">IN</span>F<span class="sy0">OR</span>MATION_SCHEMA.<span class="me1">TABLE_CONSTRAINTS</span> pk ,
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">IN</span>F<span class="sy0">OR</span>MATION_SCHEMA.<span class="me1">KEY_COLUMN_USAGE</span> c
<span class="kw1">WHERE</span> &nbsp; CONSTRA<span class="sy0">IN</span>T_TYPE <span class="sy0">=</span> <span class="st0">'PRIMARY KEY'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> c.<span class="me1">TABLE_NAME</span> <span class="sy0">=</span> pk.<span class="me1">TABLE_NAME</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> c.<span class="me1">CONSTRAINT_NAME</span> <span class="sy0">=</span> pk.<span class="me1">CONSTRAINT_NAME</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> c.<span class="me1">TABLE_NAME</span> <span class="sy0">LIKE</span> <span class="st0">'Dim%'</span>
<span class="kw1">GROUP</span> <span class="kw1">BY</span> c.<span class="me1">TABLE_NAME</span>
<span class="kw1">HAVING</span> &nbsp;<span class="kw2">COUNT</span><span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu0">1</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT  c.TABLE_NAME ,
        COUNT(*)
FROM    INFORMATION_SCHEMA.TABLE_CONSTRAINTS pk ,
        INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
WHERE   CONSTRAINT_TYPE = 'PRIMARY KEY'
        AND c.TABLE_NAME = pk.TABLE_NAME
        AND c.CONSTRAINT_NAME = pk.CONSTRAINT_NAME
        AND c.TABLE_NAME LIKE 'Dim%'
GROUP BY c.TABLE_NAME
HAVING  COUNT(*) &gt; 1</pre></div></div>

<p>¬†</p>
<h4>Detect dimension tables that don&#8217;t have Identity column as a primary key:</h4>
<p>Usually, surrogate key is made the primary key of the dimension table. Surrogate key is an auto generated Identity value.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> &nbsp;dim_table <span class="sy0">=</span> t.<span class="me1">name</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; primary_key <span class="sy0">=</span> c.<span class="me1">name</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; c.<span class="me1">is_identity</span>
<span class="kw1">FROM</span> &nbsp; &nbsp;sys.<span class="me1">tables</span> t
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">key_constraints</span> kc <span class="kw1">ON</span> t.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> kc.<span class="me1">parent_object_id</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">indexes</span> i <span class="kw1">ON</span> i.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> kc.<span class="me1">parent_object_id</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> i.<span class="me1">type_desc</span> <span class="sy0">=</span> <span class="st0">'CLUSTERED'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">index_columns</span> ic <span class="kw1">ON</span> ic.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> kc.<span class="me1">parent_object_id</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="sy0">AND</span> ic.<span class="me1">index_id</span> <span class="sy0">=</span> <span class="nu0">1</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">columns</span> c <span class="kw1">ON</span> c.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> t.<span class="kw2">OBJECT_ID</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> c.<span class="me1">column_id</span> <span class="sy0">=</span> ic.<span class="me1">column_id</span>
<span class="kw1">WHERE</span> &nbsp; t.<span class="me1">TYPE</span> <span class="sy0">=</span> <span class="st0">'U'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> t.<span class="me1">name</span> <span class="sy0">LIKE</span> <span class="st0">'Dim%'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> kc.<span class="me1">type_desc</span> <span class="sy0">=</span> <span class="st0">'PRIMARY_KEY_CONSTRAINT'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> c.<span class="me1">is_identity</span> <span class="sy0">=</span> <span class="nu0">0</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT  dim_table = t.name ,
        primary_key = c.name ,
        c.is_identity
FROM    sys.tables t
        INNER JOIN sys.key_constraints kc ON t.OBJECT_ID = kc.parent_object_id
        INNER JOIN sys.indexes i ON i.OBJECT_ID = kc.parent_object_id
                                    AND i.type_desc = 'CLUSTERED'
        INNER JOIN sys.index_columns ic ON ic.OBJECT_ID = kc.parent_object_id
                                           AND ic.index_id = 1
        INNER JOIN sys.columns c ON c.OBJECT_ID = t.OBJECT_ID
                                    AND c.column_id = ic.column_id
WHERE   t.TYPE = 'U'
        AND t.name LIKE 'Dim%'
        AND kc.type_desc = 'PRIMARY_KEY_CONSTRAINT'
        AND c.is_identity = 0</pre></div></div>

<p>¬†</p>
<h4>Detect primary keys that don&#8217;t follow the naming convention:</h4>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> &nbsp;dim_table <span class="sy0">=</span> t.<span class="me1">name</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; primary_key <span class="sy0">=</span> c.<span class="me1">name</span>
<span class="kw1">FROM</span> &nbsp; &nbsp;sys.<span class="me1">tables</span> t
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">key_constraints</span> kc <span class="kw1">ON</span> t.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> kc.<span class="me1">parent_object_id</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">indexes</span> i <span class="kw1">ON</span> i.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> kc.<span class="me1">parent_object_id</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> i.<span class="me1">type_desc</span> <span class="sy0">=</span> <span class="st0">'CLUSTERED'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">index_columns</span> ic <span class="kw1">ON</span> ic.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> kc.<span class="me1">parent_object_id</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="sy0">AND</span> ic.<span class="me1">index_id</span> <span class="sy0">=</span> <span class="nu0">1</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">columns</span> c <span class="kw1">ON</span> c.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> t.<span class="kw2">OBJECT_ID</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> c.<span class="me1">column_id</span> <span class="sy0">=</span> ic.<span class="me1">column_id</span>
<span class="kw1">WHERE</span> &nbsp; t.<span class="me1">TYPE</span> <span class="sy0">=</span> <span class="st0">'U'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> t.<span class="me1">name</span> <span class="sy0">LIKE</span> <span class="st0">'Dim%'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> kc.<span class="me1">type_desc</span> <span class="sy0">=</span> <span class="st0">'PRIMARY_KEY_CONSTRAINT'</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> c.<span class="me1">name</span> <span class="sy0">&lt;&gt;</span> <span class="kw2">REPLACE</span><span class="br0">&#40;</span>t.<span class="me1">name</span>, <span class="st0">'Dim'</span>, <span class="st0">''</span><span class="br0">&#41;</span> <span class="sy0">+</span> <span class="st0">'Key'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT  dim_table = t.name ,
        primary_key = c.name
FROM    sys.tables t
        INNER JOIN sys.key_constraints kc ON t.OBJECT_ID = kc.parent_object_id
        INNER JOIN sys.indexes i ON i.OBJECT_ID = kc.parent_object_id
                                    AND i.type_desc = 'CLUSTERED'
        INNER JOIN sys.index_columns ic ON ic.OBJECT_ID = kc.parent_object_id
                                           AND ic.index_id = 1
        INNER JOIN sys.columns c ON c.OBJECT_ID = t.OBJECT_ID
                                    AND c.column_id = ic.column_id
WHERE   t.TYPE = 'U'
        AND t.name LIKE 'Dim%'
        AND kc.type_desc = 'PRIMARY_KEY_CONSTRAINT'
        AND c.name &lt;&gt; REPLACE(t.name, 'Dim', '') + 'Key'</pre></div></div>

<p>¬†</p>
<h4>Detect fact tables that have no foreign keys:</h4>
<p>Without a foreign key, a fact table isn&#8217;t really a fact table.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> table_name <span class="sy0">=</span> t.<span class="me1">name</span>
&nbsp; &nbsp; &nbsp; &nbsp; , fk_count <span class="sy0">=</span> <span class="kw2">COUNT</span><span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span>
&nbsp; &nbsp; <span class="kw1">FROM</span> sys.<span class="me1">tables</span> t
&nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span>
&nbsp; &nbsp; sys.<span class="me1">foreign_keys</span> fk <span class="kw1">ON</span> t.<span class="kw2">OBJECT_ID</span> <span class="sy0">=</span> fk.<span class="me1">parent_object_id</span>
&nbsp; &nbsp; <span class="kw1">WHERE</span> &nbsp;t.<span class="me1">name</span> <span class="sy0">LIKE</span> <span class="st0">'fact%'</span>
&nbsp; &nbsp; <span class="kw1">GROUP</span> <span class="kw1">BY</span> t.<span class="me1">name</span>
&nbsp; &nbsp; <span class="kw1">HAVING</span> <span class="kw2">COUNT</span><span class="br0">&#40;</span><span class="sy0">*</span><span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">1</span> &nbsp;</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT table_name = t.name
		, fk_count = COUNT(*)
    FROM sys.tables t
    INNER JOIN
    sys.foreign_keys fk ON t.OBJECT_ID = fk.parent_object_id
    WHERE  t.name LIKE 'fact%'
    GROUP BY t.name
    HAVING COUNT(*) &lt; 1  </pre></div></div>

<p>¬†</p>
<h4>Detect fact tables that have foreign key(s) to another fact table:</h4>
<p> It&#8217;s unlikely to have a fact table related to another fact table.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> &nbsp;foreign_key <span class="sy0">=</span> fk.<span class="me1">name</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; child_table <span class="sy0">=</span> t.<span class="me1">name</span> ,
&nbsp; &nbsp; &nbsp; &nbsp; parent_name <span class="sy0">=</span> rt.<span class="me1">name</span>
<span class="kw1">FROM</span> &nbsp; &nbsp;sys.<span class="me1">foreign_keys</span> fk
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">tables</span> rt <span class="kw1">ON</span> rt.<span class="kw2">object_id</span> <span class="sy0">=</span> fk.<span class="me1">referenced_object_id</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> <span class="sy0">JOIN</span> sys.<span class="me1">tables</span> t <span class="kw1">ON</span> t.<span class="kw2">object_id</span> <span class="sy0">=</span> fk.<span class="me1">parent_object_id</span>
<span class="kw1">WHERE</span> &nbsp; rt.<span class="me1">name</span> <span class="sy0">LIKE</span> <span class="st0">'Fact%'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT  foreign_key = fk.name ,
        child_table = t.name ,
        parent_name = rt.name
FROM    sys.foreign_keys fk
        INNER JOIN sys.tables rt ON rt.object_id = fk.referenced_object_id
        INNER JOIN sys.tables t ON t.object_id = fk.parent_object_id
WHERE   rt.name LIKE 'Fact%'</pre></div></div>

<p>¬†</p>
<h4>Detect missing foreign key(s) in fact tables &#8211; Columns suffixed with Key, but don&#8217;t have foreign key constraint:</h4>
<p>I stole the following query from <a title="missing foreign keys sql cop" href="/index.php/DataMgmt/DataDesign/missing-foreign-key-constraints">here</a> posted by <a title="George M" href="/index.php/All/?disp=authdir&amp;author=10">George Mastros</a>, and replaced ID with Key to use it for data warehouse scenario.</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="de1"><pre class="de1">&nbsp; &nbsp; <span class="kw1">SELECT</span> &nbsp;C.<span class="me1">TABLE_SCHEMA</span>,C.<span class="me1">TABLE_NAME</span>,C.<span class="me1">COLUMN_NAME</span>
&nbsp; &nbsp; <span class="kw1">FROM</span> &nbsp; &nbsp;<span class="sy0">IN</span>F<span class="sy0">OR</span>MATION_SCHEMA.<span class="me1">COLUMNS</span> C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">INNER</span> Join <span class="sy0">IN</span>F<span class="sy0">OR</span>MATION_SCHEMA.<span class="me1">TABLES</span> T &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">ON</span> C.<span class="me1">TABLE_NAME</span> <span class="sy0">=</span> T.<span class="me1">TABLE_NAME</span> &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; And T.<span class="me1">TABLE_TYPE</span> <span class="sy0">=</span> <span class="st0">'Base Table'</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> T.<span class="me1">TABLE_SCHEMA</span> <span class="sy0">=</span> C.<span class="me1">TABLE_SCHEMA</span> &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">LEFT</span> Join <span class="sy0">IN</span>F<span class="sy0">OR</span>MATION_SCHEMA.<span class="me1">CONSTRAINT_COLUMN_USAGE</span> U &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">ON</span> C.<span class="me1">TABLE_NAME</span> <span class="sy0">=</span> U.<span class="me1">TABLE_NAME</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; And C.<span class="me1">COLUMN_NAME</span> <span class="sy0">=</span> U.<span class="me1">COLUMN_NAME</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; And U.<span class="me1">TABLE_SCHEMA</span> <span class="sy0">=</span> C.<span class="me1">TABLE_SCHEMA</span>
&nbsp; &nbsp; <span class="kw1">WHERE</span> &nbsp; U.<span class="me1">COLUMN_NAME</span> <span class="kw1">IS</span> Null &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; And C.<span class="me1">COLUMN_NAME</span> Like <span class="st0">'%Key'</span>
&nbsp; &nbsp; <span class="kw1">ORDER</span> <span class="kw1">BY</span> C.<span class="me1">TABLE_SCHEMA</span>, C.<span class="me1">TABLE_NAME</span>, C.<span class="me1">COLUMN_NAME</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">    SELECT  C.TABLE_SCHEMA,C.TABLE_NAME,C.COLUMN_NAME
    FROM    INFORMATION_SCHEMA.COLUMNS C          
            INNER Join INFORMATION_SCHEMA.TABLES T            
              ON C.TABLE_NAME = T.TABLE_NAME    
              And T.TABLE_TYPE = 'Base Table'
              AND T.TABLE_SCHEMA = C.TABLE_SCHEMA        
            LEFT Join INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE U            
              ON C.TABLE_NAME = U.TABLE_NAME            
              And C.COLUMN_NAME = U.COLUMN_NAME
              And U.TABLE_SCHEMA = C.TABLE_SCHEMA
    WHERE   U.COLUMN_NAME IS Null          
            And C.COLUMN_NAME Like '%Key'
    ORDER BY C.TABLE_SCHEMA, C.TABLE_NAME, C.COLUMN_NAME</pre></div></div>

<p>¬†</p>
<p>Results of above queries aren&#8217;t always issues. They are just rare, you&#8217;ve to look at them closely and make sure there is a reason for each choice. Also, you may use different naming conventions that make these queries void. In that case, I hope you&#8217;re able to alter them to your needs.</p>
<p>Follow me on Twitter! @<a title="SamuelVanga Twitter" href="/twitter.com/SamuelVanga">SamuelVanga</a></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/webdev/business-intelligence/scripts-to-detect-data-warehouse/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>T-SQL Tuesday #38 ‚Äì Resolving an SSIS package performance problem</title>
		<link>/index.php/datamgmt/dbprogramming/mssqlserver/t-sql-tuesday-38-resolving/</link>
		<comments>/index.php/datamgmt/dbprogramming/mssqlserver/t-sql-tuesday-38-resolving/#comments</comments>
		<pubDate>Tue, 08 Jan 2013 05:04:00 +0000</pubDate>
		<dc:creator><![CDATA[Koen Verbeeck]]></dc:creator>
				<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[SSIS]]></category>
		<category><![CDATA[performance tuning]]></category>
		<category><![CDATA[ssis]]></category>
		<category><![CDATA[t-sql]]></category>

		<guid isPermaLink="false">/index.php/2013/01/t-sql-tuesday-38-resolving/</guid>
		<description><![CDATA[This is my contribution to T-SQL Tuesday #38: Standing Firm. I describe how I resolved an SSIS package performance issue.]]></description>
				<content:encoded><![CDATA[<p class="MsoNormal" style="text-align: justify;"><span lang="EN-US"> </span></p>
<div class="image_block" style="text-align: justify;">
<div class="image_block" style="text-align: justify;"><a href="http://jasonbrimhall.info/2013/01/02/t-sql-tuesday-38-standing-firm/"><img style="float: left;" src="/wp-content/uploads/users/koenverbeeck/TSQL2sday37/TSQL2sday.PNG?mtime=1355209029" alt="" width="133" height="134" /></a></div>
<p>It‚Äôs this time of the month again: the T-SQL Tuesday is back and Jason Brimhall (<a href="http://jasonbrimhall.info/">blog</a> | <a href="https://twitter.com/sqlrnnr">twitter</a>) is hosting the 38<sup>th</sup> installment. The theme is <em>‚Äústanding firm‚Äù</em>, which basically means to tell a story about one of these words: <em>resolve, resolution</em> or <em>resolute</em>. My contribution will be a story on how I once <strong>resolved<em> </em></strong>an issue with an SSIS package taking more than one hour to complete.</div>
<p><span style="text-align: justify;">At a client, they had a package developed some time ago and after a while it started to slow down enormously, to the point where it took over one hour to complete, if it completed at all. Sometimes out-of-memory exceptions where thrown and they had to start all over again. They asked if I could take a look at the package and perhaps speed it up a little. The package was not a typical data warehouse scenario, but ran on a normalized database which was being used as an OLTP application database and a reporting database at the same time (don‚Äôt get me started on the design). The package itself was pretty complex &#8211; especially the data flow &#8211; and it managed quite a workflow. The data set being handled was large, but not that large to be a gigantic problem.</span></p>
<p class="MsoNormal" style="text-align: justify;"><span lang="EN-US">I took a quick look on the package and some things immediately popped out:</span></p>
<ul style="margin-left: 20pt; list-style-position: outside;">
<li><em><span lang="EN-US">Lookup components </span></em><span style="text-align: justify; text-indent: -18pt;" lang="EN-US">There were quite a few of them and some of those had either partial or no caching and even worse, they all used the dropdown box to select the table. This is a big red flag.</span></li>
<li><em><span lang="EN-US">OLE DB Commands</span></em><span style="text-indent: -18pt;" lang="EN-US"> I just hate those pesky little buggers. They fire off a statement for each row in your data flow, causing an avalanche of transactions against the database. The database in question was on Full Recovery Model, something I had no control over, so logging exploded when this package ran. If you thought the previous bullet is a red flag, this one is Defcon 2.</span></li>
<li><em><span lang="EN-US">OLE DB Destinations without the Fast Load option </span></em><span style="text-align: justify; text-indent: -18pt;" lang="EN-US">Pretty much the same as an OLE DB command. Each insert is a separate transaction instead of a bulk insert.</span></li>
<li><em><span lang="EN-US">Redundant or unnecessary logic</span></em><span style="text-align: justify; text-indent: -18pt;" lang="EN-US"> Obviously, this is to be avoided.</span></li>
</ul>
<p><!--[if !supportLists]--></p>
<p class="MsoNormal" style="text-align: justify;"><span lang="EN-US">So how do you tackle a package like this? Let‚Äôs start with the Lookups. Most of the referenced tables were pretty large, but if you write a query retrieving only the columns you actually need instead of using the dropdown box, you can fit a whole lot more rows in memory. I guess the original creator of the package used partial or no caching because the referenced data sets were too big to fit all in memory. I wrote a few queries selecting only the lookup keys and the columns needing to be retrieved (which is the point of a lookup obviously) and suddenly everything fitted nicely in memory with the Full caching option. Nice.</span></p>
<p class="MsoNormal" style="text-align: justify;"><span lang="EN-US">The OLE DB commands. Usually they are used to execute UPDATE statements, as there isn‚Äôt a way to do set based updates in the data flow. I got rid of them by creating temporary tables in the beginning of the package and inserting the data into the temp table with an OLE DB Destination using the Fast Load option. After the data flow, I use an Execute SQL Task to execute a set-based UPDATE statement by doing an inner join between the destination table and the temp table. You can‚Äôt believe the performance improvement you get using this technique on large data sets. I‚Äôm a strong advocate of using a hybrid combination of SSIS components and T-SQL in SSIS packages. For the time being, updates certainly belong in the T-SQL realm.</span></p>
<p class="MsoNormal" style="text-align: justify;"><span lang="EN-US">The OLE DB Destinations without the Fast Load option. No idea why the default was changed to a worse option, but it was quickly resolved: simply change it to the fast load option and you‚Äôre good to go.</span></p>
<p class="MsoNormal" style="text-align: justify;"><span lang="EN-US">Finally I looked at the logic of the package itself. There were some script components doing pretty basic stuff (I guess the creator was a .NET developer doing his first SSIS development) so I removed them and moved all the logic to the source query. I also removed columns that weren‚Äôt used in the data flow. In SSIS, it‚Äôs very important to get your row size as small as possible in order to get as many rows as possible in one buffer. I also enhanced the buffer size, so I could get rows faster in and out the data flow. To finish everything off, I removed a SORT component used to remove duplicates and used a DISTINCT clause in the source query. A SORT component is a blocking component ‚Äì DEFCON 1 for large data sets ‚Äì and is to be avoided at all costs.</span></p>
<p class="MsoNormal" style="text-align: justify;"><span lang="EN-US">All this work took one afternoon. I ran the package and behold, it ran in a mere 4 minutes. From over one hour to just a couple of minutes. The sad part is most performance bottlenecks could easily be avoided. By being <em>resolute</em> (see what I did there?) about some very simple SSIS design principles, you can make a big difference in the performance of a package. If you‚Äôre interested in SSIS performance tuning, start at this magnificent SQLCAT article: <a href="http://sqlcat.com/sqlcat/b/top10lists/archive/2008/10/01/top-10-sql-server-integration-services-best-practices.aspx?PageIndex=2">Top 10 SQL Server Integration Services Best Practices</a>. It‚Äôs my bible when tuning SSIS packages.</span></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/dbprogramming/mssqlserver/t-sql-tuesday-38-resolving/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Why you shouldn&#8217;t use SELECT *</title>
		<link>/index.php/datamgmt/dbprogramming/why-you-shouldn-t-use/</link>
		<comments>/index.php/datamgmt/dbprogramming/why-you-shouldn-t-use/#comments</comments>
		<pubDate>Wed, 02 Jan 2013 11:28:00 +0000</pubDate>
		<dc:creator><![CDATA[Axel Achten (axel8s)]]></dc:creator>
				<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[select]]></category>
		<category><![CDATA[select star]]></category>
		<category><![CDATA[t-sql]]></category>

		<guid isPermaLink="false">/index.php/2013/01/why-you-shouldn-t-use/</guid>
		<description><![CDATA[A customer's DBA team created a checklist for the development teams with some best practices for writing proper T-SQL and asked me to write some contributions for their tips document library. So if I do the research and write the documents I might as we&#8230;]]></description>
				<content:encoded><![CDATA[<p>A customer&#8217;s DBA team created a checklist for the development teams with some best practices for writing proper T-SQL and asked me to write some contributions for their tips document library. So if I do the research and write the documents I might as well post them here. The content may not be all sparkling and new but since there is a demand from customers, there are still people out there having trouble finding the correct information.<br />
So let&#8217;s get started. The first document is why you should avoid SELECT * in your queries:</p>
<p><b>For performance reasons</b></p>
<p>To be honest this part of the post is based on Ted&#8217;s post: <a href="/index.php/DataMgmt/DBAdmin/MSSQLServerAdmin/select-vs-select-1-with">SELECT * vs SELECT 1 with EXISTS</a>.<br />
To check the performance impact I use a tool called <a href="http://www.datamanipulation.net/sqlquerystress/">SQLQueryStress</a> to execute my queries and see how much time elapsed.<br />
To get started I need a table with a large number of columns, data is not necessary for this test so I use this script to generate a table with 127 columns:</p>
<pre>DECLARE @colnumber int = 1
DECLARE @command VARCHAR(4000) =''

WHILE @colnumber &lt;= 125
	BEGIN
		SET @command = @command + ' col' + CAST(@colnumber AS varchar(3)) + ' int, '
		SET @colnumber += 1
	END
SET @command = 'CREATE TABLE StarPerform (PerfId int, ' + @command + ' Lastcolumn int)'

EXEC (@command)</pre>
<p>Now I query the table using the SQLQueryStress tool and I choose a high Number of Iterations to get a meaningful average:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform1.JPG?mtime=1357132527"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform1.JPG?mtime=1357132527" width="1361" height="430" /></a></div>
<p>In the Client Seconds/Iteration (Avg) you see that the performance difference for an individual query is negligible but a similar query often executed on a busy server can result in 15 extra seconds on 5000 Iterations.</p>
<p><b>Broken code</b></p>
<p>Using SELECT * in Views is also a bad practice because changes to the underlying table will return unexpected results or fail completely.<br />
First I create a table and insert some data:</p>
<pre>--Create the table
CREATE TABLE StarBreak
 (
	ID int IDENTITY (1,1),
	Name varchar (10),
	DateFirstPost date,
	DateLastPost date
);
GO

--Insert some values
INSERT INTO StarBreak (Name, DateFirstPost, DateLastPost)
	VALUES ('Denis','20080207','20130101'),('Ted','20081107','20121231'),('Koen','20121123','20121227'),('Jes','20101210','20121221');
GO</pre>
<p>Now I create and query a View to return all the columns:</p>
<pre>CREATE VIEW GetStarFromStarBreak
	AS
		SELECT * from Starbreak;
		
GO</pre>
<p>And I get this result back:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform2.JPG?mtime=1357132538"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform2.JPG?mtime=1357132538" width="261" height="95" /></a></div>
<p>Now let‚Äôs drop the table and recreate it but switch the position of the two datecolumns:</p>
<pre>--Drop the table
DROP TABLE StarBreak;
GO

--Create the table
CREATE TABLE StarBreak
 (
	ID int IDENTITY (1,1),
	Name varchar (10),
	DateLastPost date,
	DateFirstPost date
);
GO

--Insert some values
INSERT INTO StarBreak (Name, DateFirstPost, DateLastPost)
	VALUES ('Denis','20080207','20130101'),('Ted','20081107','20121231'),('Koen','20121123','20121227'),('Jes','20101210','20121221');
GO</pre>
<p>When I query the table again I get the correct result:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform3.JPG?mtime=1357132547"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform3.JPG?mtime=1357132547" width="262" height="97" /></a></div>
<p>But when I query my view again I get the following result:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform4.JPG?mtime=1357132561"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform4.JPG?mtime=1357132561" width="261" height="95" /></a></div>
<p>You see that the column headers are in the same order as in the initial table but the data reflects the column order of the second table.<br />
Dropping the table, and adding a column in the middle will also result in the above behavior:</p>
<pre>--Drop the table
DROP TABLE StarBreak;
GO

--Create the table
CREATE TABLE StarBreak
 (
	ID int IDENTITY (1,1),
	Name varchar (10),
	Gender char(1),
	DateLastPost date,
	DateFirstPost date
);
GO

--Insert some values
INSERT INTO StarBreak (Name, DateFirstPost, DateLastPost)
	VALUES ('Denis','20080207','20130101'),('Ted','20081107','20121231'),('Koen','20121123','20121227'),('Jes','20101210','20121221');
GO</pre>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform5.JPG?mtime=1357132571"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform5.JPG?mtime=1357132571" width="258" height="96" /></a></div>
<p>What happens when I recreate the table but only 3 instead of 4 columns? Let‚Äôs try:</p>
<pre>--Drop the table
DROP TABLE StarBreak;
GO

--Create the table
CREATE TABLE StarBreak
 (
	ID int IDENTITY (1,1),
	Name varchar (10),
	DateLastPost date,
);
GO

--Insert some values
INSERT INTO StarBreak (Name, DateLastPost)
	VALUES ('Denis','20130101'),('Ted','20121231'),('Koen','20121227'),('Jes','20121221');
GO</pre>
<p>Now query the view again but use this query to make sure you only select the 3 existing columns:</p>
<pre>SELECT ID, Name, DateLastPost FROM GetStarFromStarBreak</pre>
<p>And the result is:</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform6.JPG?mtime=1357132583"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform6.JPG?mtime=1357132583" width="672" height="66" /></a></div>
<p>You see the code breaks because the view still expects 4 columns although you specified you only query 3 columns from the view.</p>
<p><b>Conclusion</b></p>
<p>We have seen several reasons to stay away from the SELECT * statement but we do understand the pain in typing in 127 column names. So here is a last tip:<br />
When you drag the Columns folder of your table in Object Explorer to the Query Pane, SQL Server Management Studio will automatically list the column names separated with commas for you.</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform7.JPG?mtime=1357132592"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Axel8s/StarPerform7.JPG?mtime=1357132592" width="608" height="233" /></a></div>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/dbprogramming/why-you-shouldn-t-use/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Dealing with the Column name &#8216;TEXT()&#8217; contains an invalid XML identifier as required by FOR XML; &#8216;(&#8216;(0x0028) is the first character at fault error</title>
		<link>/index.php/webdev/business-intelligence/dealing-with-the-column-name/</link>
		<comments>/index.php/webdev/business-intelligence/dealing-with-the-column-name/#respond</comments>
		<pubDate>Wed, 05 Dec 2012 11:42:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Business Intelligence]]></category>
		<category><![CDATA[concatenate]]></category>
		<category><![CDATA[how to]]></category>
		<category><![CDATA[rows to column]]></category>
		<category><![CDATA[sql server 2005]]></category>
		<category><![CDATA[sql server 2008]]></category>
		<category><![CDATA[sql server 2012]]></category>
		<category><![CDATA[t-sql]]></category>
		<category><![CDATA[xml]]></category>

		<guid isPermaLink="false">/index.php/2012/12/dealing-with-the-column-name/</guid>
		<description><![CDATA[I had to deploy a user defined function I was given yesterday, when I tried to I got the following error

Msg 6850, Level 16, State 1, Procedure fnGetBooks, Line 8
Column name 'TEXT()' contains an invalid XML identifier as required by FOR XML; '('(0x&#8230;]]></description>
				<content:encoded><![CDATA[<p>I had to deploy a user defined function I was given yesterday, when I tried to I got the following error</p>
<p>Msg 6850, Level 16, State 1, Procedure fnGetBooks, Line 8<br />
Column name &#8216;TEXT()&#8217; contains an invalid XML identifier as required by FOR XML; &#8216;(&#8216;(0x0028) is the first character at fault.</p>
<p>The function looked a little like this one</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">FUNCTION</span> fnGetBooks <span class="br0">&#40;</span>@AuthorID <span class="kw1">INT</span><span class="br0">&#41;</span>
&nbsp;
<span class="kw1">RETURNS</span> <span class="kw1">VARCHAR</span><span class="br0">&#40;</span><span class="nu0">8000</span><span class="br0">&#41;</span>
<span class="kw1">AS</span>
<span class="kw1">BEGIN</span>
&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;<span class="kw1">DECLARE</span> @BookList <span class="kw1">VARCHAR</span><span class="br0">&#40;</span><span class="nu0">8000</span><span class="br0">&#41;</span>
&nbsp;<span class="kw1">SELECT</span> @BookList <span class="sy0">=</span><span class="br0">&#40;</span>
&nbsp;
&nbsp; &nbsp; &nbsp;<span class="kw1">SELECT</span> &nbsp;BookName <span class="sy0">+</span> <span class="st0">', '</span> <span class="kw1">AS</span> <span class="br0">&#91;</span><span class="kw1">TEXT</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#93;</span>
&nbsp;
&nbsp; &nbsp; &nbsp;<span class="kw1">FROM</span> &nbsp; &nbsp;Books
&nbsp; &nbsp; &nbsp;<span class="kw1">WHERE</span> AuthorID <span class="sy0">=</span> @AuthorID
&nbsp; &nbsp; &nbsp;<span class="sy0">AND</span> BookName <span class="kw1">IS</span> <span class="sy0">NOT</span> <span class="sy0">NULL</span>
&nbsp; &nbsp; &nbsp;<span class="kw1">ORDER</span> <span class="kw1">BY</span> BookName
&nbsp;
&nbsp; &nbsp; &nbsp;<span class="kw1">FOR</span> XML <span class="kw1">PATH</span><span class="br0">&#40;</span><span class="st0">''</span><span class="br0">&#41;</span> <span class="br0">&#41;</span>
&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;
<span class="kw1">RETURN</span> <span class="kw1">LEFT</span><span class="br0">&#40;</span>@BookList,<span class="br0">&#40;</span><span class="kw2">LEN</span><span class="br0">&#40;</span>@BookList<span class="br0">&#41;</span> <span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
<span class="kw1">END</span>
GO</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE FUNCTION fnGetBooks (@AuthorID INT)
 
RETURNS VARCHAR(8000)
AS
BEGIN
       
 DECLARE @BookList VARCHAR(8000)
 SELECT @BookList =(
 
     SELECT  BookName + ', ' AS [TEXT()]
 
     FROM    Books
     WHERE AuthorID = @AuthorID
     AND BookName IS NOT NULL
     ORDER BY BookName
 
     FOR XML PATH('') )
       
 
RETURN LEFT(@BookList,(LEN(@BookList) -1))
END
GO</pre></div></div>

<p>Trying to run that will give you the same error. Do you see the problem? First I determined what 0x0028 was, you can easy do this by running the following query</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw1">CHAR</span><span class="br0">&#40;</span>0x0028<span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT CHAR(0x0028)</pre></div></div>

<p>As you can see, that is the left parentheses (<br />
Interesting but not really helpful, I know I wrote stuff that uses FOR XML PATH myself in the past. I ran the following query to give me a list of objects that use FOR XML PATH</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> 
<span class="kw1">FROM</span> sys.<span class="me1">objects</span>
<span class="kw1">WHERE</span> OBJECT_DEF<span class="sy0">IN</span>ITION<span class="br0">&#40;</span><span class="kw2">object_id</span><span class="br0">&#41;</span> <span class="sy0">LIKE</span> <span class="st0">'%FOR%%XML%%PATH%'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * 
FROM sys.objects
WHERE OBJECT_DEFINITION(object_id) LIKE '%FOR%%XML%%PATH%'</pre></div></div>

<p>Then I looked at some of those functions, the only thing I noticed is that TEXT was lowercase</p>
<p>Instead of</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1">&nbsp;<span class="kw1">SELECT</span> &nbsp;BookName <span class="sy0">+</span> <span class="st0">', '</span> <span class="kw1">AS</span> <span class="br0">&#91;</span><span class="kw1">TEXT</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#93;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse"> SELECT  BookName + ', ' AS [TEXT()]</pre></div></div>

<p>It was</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1">&nbsp;<span class="kw1">SELECT</span> &nbsp;BookName <span class="sy0">+</span> <span class="st0">', '</span> <span class="kw1">AS</span> <span class="br0">&#91;</span><span class="kw1">text</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#93;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse"> SELECT  BookName + ', ' AS [text()]</pre></div></div>

<p>Once you make the change, the error will disappear. My suspicion is that some code formatting tool made it uppercase, perhaps the programmer copied and pasted it into some window and then packaged the output&#8230;I will have to follow up on that one</p>
<p>If you are interested what that function is used for, take a look at <a href="/index.php/DataMgmt/DataDesign/the-ten-most-asked-sql-server-questions--1#10">Concatenate Values From Multiple Rows Into One Column</a></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/webdev/business-intelligence/dealing-with-the-column-name/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>SQL Advent 2012 Day 4: Triggers, what to do, what not to do</title>
		<link>/index.php/datamgmt/dbprogramming/triggers-what-to-do-what/</link>
		<comments>/index.php/datamgmt/dbprogramming/triggers-what-to-do-what/#comments</comments>
		<pubDate>Tue, 04 Dec 2012 10:04:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Business Intelligence]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[ddl triggers]]></category>
		<category><![CDATA[dml triggers]]></category>
		<category><![CDATA[rdbms]]></category>
		<category><![CDATA[sql]]></category>
		<category><![CDATA[sql server 2008]]></category>
		<category><![CDATA[sql server 2012]]></category>
		<category><![CDATA[t-sql]]></category>
		<category><![CDATA[triggers]]></category>

		<guid isPermaLink="false">/index.php/2012/12/triggers-what-to-do-what/</guid>
		<description><![CDATA[This is day four of the SQL Advent 2012 series of blog posts. Today we are going to look at triggers. Triggers are a great way to keep your database in a consistent state. There are two types of triggers, DML triggers and DLL triggers. DML triggers  res&#8230;]]></description>
				<content:encoded><![CDATA[<p>This is day four of the <a href="/index.php/DataMgmt/DBProgramming/sql-advent-2012-here-is">SQL Advent 2012 series</a> of blog posts. Today we are going to look at triggers. Triggers are a great way to keep your database in a consistent state. There are two types of triggers, DML triggers and DLL triggers. DML triggers  respond to Data Manipulation Statements (Insert, Delete, Update) DDL triggers respond to Data Definition Language events. </p>
<p>Some things that DML triggers are used for:</p>
<ul>
<li>Keeps your databases from having wrong data by doing checks that can&#8217;t be handled with constraints</li>
<li>Filling in values that are not supplied and can&#8217;t be handled through default constraints since these don&#8217;t fire on updates </li>
<li>Calculation summary values and updates the summary table with that value</li>
<li>Used as a mechanism to maintain an audit trail for DML statements</li>
</ul>
<p>Some things that DDL triggers are used for:</p>
<ul>
<li>Automatically add columns to a table if they were not added, for example LastUpdated and InsertedBy columns</li>
<li>Notify a DBA when a database has been created, dropped or altered</li>
<li>Used as a mechanism to maintain an audit trail for DDL statements, capture every time an object has been created, dropped or altered and by who</li>
</ul>
<p>Most common mistake people make when first starting writing triggers is that they write it in such a way that it will only work if you insert/update/delete one row at a time. A trigger fires per batch not per row, you have to take this into consideration otherwise your DML statements will blow up. How to do this is explained in this post <a href="/index.php/DataMgmt/DBProgramming/MSSQLServer/best-practice-coding-sql-server-triggers">Best Practice: Coding SQL Server triggers for multi-row operations</a>, there is no point recreating that post here.</p>
<p>Another problem that I see is that some people think a trigger is SQL Server&#8217;s version of crontab, you will see code that sends email, kicks off jobs, runs stored procedures. This is the wrong approach, a trigger should be lean and mean, it should execute as fast as possible, if you need to do some additional things then dump some data from the trigger into a processing table and then use that table to do your additional tasks. Don&#8217;t use triggers as a messaging system either, SQL Server comes with Service Broker, use that instead. Triggers might look like hammers to some people but I guarantee you not everything is a nail&#8230;.</p>
<p>You could end up with a real difficult thing to debug, one trigger that kicks off other triggers, now have fun debugging the trigger hell you got yourself into&#8230;.or worse debug this mess if you inherited this&#8230;.this is like the GOTO spaghetti code of databases.</p>
<p>Since triggers work besides the scenes you might spend hours debugging something only to find out that a trigger modified the value</p>
<p>One thing I always find interesting is when someone sees two <em>n rows affected</em> statements when they only did one insert, you know a person like that has not been exposed to triggers yet</p>
<p>Some people will say that you don&#8217;t need triggers for anything and that they do more harm than good, I myself don&#8217;t agree with that, triggers have a place but they should not be abused and overused, the same can be said of views</p>
<p>What is your opinion, are triggers needed or are they not needed?</p>
<p>That is all for day four of the <a href="/index.php/DataMgmt/DBProgramming/sql-advent-2012-here-is">SQL Advent 2012 series</a>, come back tomorrow for the next one, you can also check out all the posts from last year here: <a href="/index.php/DataMgmt/DataDesign/sql-advent-2011-recap">SQL Advent 2011 Recap</a></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/dbprogramming/triggers-what-to-do-what/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>SQL Advent 2012 Day 3: Sargable Queries</title>
		<link>/index.php/datamgmt/dbprogramming/sargable-queries/</link>
		<comments>/index.php/datamgmt/dbprogramming/sargable-queries/#comments</comments>
		<pubDate>Mon, 03 Dec 2012 13:44:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Business Intelligence]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[indexing]]></category>
		<category><![CDATA[performance tuning]]></category>
		<category><![CDATA[rdbms]]></category>
		<category><![CDATA[sargable]]></category>
		<category><![CDATA[sql]]></category>
		<category><![CDATA[sql server 2008]]></category>
		<category><![CDATA[sql server 2012]]></category>
		<category><![CDATA[t-sql]]></category>

		<guid isPermaLink="false">/index.php/2012/12/sargable-queries/</guid>
		<description><![CDATA[This is day three of the SQL Advent 2012 series of blog posts. Today we are going to look at sargable queries. You might ask yourself, what is this weird term sargable. Sargable  comes from searchable argument, sometimes also referred as Search ARGument&#8230;]]></description>
				<content:encoded><![CDATA[<p>This is day three of the <a href="/index.php/DataMgmt/DBProgramming/sql-advent-2012-here-is">SQL Advent 2012 series</a> of blog posts. Today we are going to look at sargable queries. You might ask yourself, what is this weird term sargable. Sargable  comes from searchable argument, sometimes also referred as <span class="MT_red">S</span>earch <span class="MT_red">ARG</span>ument <span class="MT_red">ABLE</span>. What that means is that the query will be able to use an index, a seek will be performed instead of a scan. In general any time you have a function wrapped around a column, an index won&#8217;t be used</p>
<p>Some examples that are not sargable </p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">WHERE</span> <span class="kw1">LEFT</span><span class="br0">&#40;</span>Name,<span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="st0">'S'</span>
<span class="kw1">WHERE</span> <span class="kw1">Year</span><span class="br0">&#40;</span>SomeDate<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="nu0">2012</span>
<span class="kw1">WHERE</span> OrderID <span class="sy0">*</span> <span class="nu0">3</span> <span class="sy0">=</span> <span class="nu0">33000</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">WHERE LEFT(Name,1) = 'S'
WHERE Year(SomeDate) = 2012
WHERE OrderID * 3 = 33000</pre></div></div>

<p>Those three should be rewritten like this in order to become sargable </p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">WHERE</span> Name <span class="sy0">LIKE</span> <span class="st0">'S%'</span>
<span class="kw1">WHERE</span> SomeDate <span class="sy0">&gt;=</span> <span class="st0">'20120101'</span> <span class="sy0">AND</span> SomeDate <span class="sy0">&lt;</span> <span class="st0">'20130101'</span>
<span class="kw1">WHERE</span> OrderID <span class="sy0">=</span> <span class="nu0">33000</span><span class="sy0">/</span><span class="nu0">3</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">WHERE Name LIKE 'S%'
WHERE SomeDate &gt;= '20120101' AND SomeDate &lt; '20130101'
WHERE OrderID = 33000/3</pre></div></div>

<p>Let&#8217;s create a table, insert some data so that we can look at the execution plan<br />
Create this simple table</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> Test<span class="br0">&#40;</span>SomeID <span class="kw1">varchar</span><span class="br0">&#40;</span><span class="nu0">100</span><span class="br0">&#41;</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE Test(SomeID varchar(100))</pre></div></div>

<p>Let&#8217;s insert some data that will start with a letter followed by some digits</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
</pre></td><td class="de1"><pre class="de1"><span class="kw1">INSERT</span> Test
<span class="kw1">SELECT</span> <span class="kw1">LEFT</span><span class="br0">&#40;</span>v2.<span class="me1">type</span>,<span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">+</span><span class="kw1">RIGHT</span><span class="br0">&#40;</span><span class="st0">'0000'</span> <span class="sy0">+</span> <span class="kw1">CONVERT</span><span class="br0">&#40;</span><span class="kw1">varchar</span><span class="br0">&#40;</span><span class="nu0">4</span><span class="br0">&#41;</span>,v1.<span class="me1">number</span><span class="br0">&#41;</span>,<span class="nu0">4</span><span class="br0">&#41;</span> 
<span class="kw1">FROM</span> master..<span class="me1">spt_values</span> v1
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> <span class="br0">&#40;</span><span class="kw1">SELECT</span> <span class="kw1">DISTINCT</span> <span class="kw1">LEFT</span><span class="br0">&#40;</span>type,<span class="nu0">1</span><span class="br0">&#41;</span> <span class="kw1">AS</span> type 
<span class="kw1">FROM</span> master..<span class="me1">spt_values</span><span class="br0">&#41;</span> v2
<span class="kw1">WHERE</span> v1.<span class="me1">type</span> <span class="sy0">=</span> <span class="st0">'p'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">INSERT Test
SELECT LEFT(v2.type,1) +RIGHT('0000' + CONVERT(varchar(4),v1.number),4) 
FROM master..spt_values v1
CROSS JOIN (SELECT DISTINCT LEFT(type,1) AS type 
FROM master..spt_values) v2
WHERE v1.type = 'p'</pre></div></div>

<p>That insert should have generated 32768 rows</p>
<p>Now create this index on that table</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">CLUSTERED</span> <span class="kw1">INDEX</span> cx_test <span class="kw1">ON</span> Test<span class="br0">&#40;</span>SomeID<span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE CLUSTERED INDEX cx_test ON Test(SomeID)</pre></div></div>

<p>Let&#8217;s take a look at the execution plan, hit CTRL + M, this will add the execution plan once the query is done running</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> Test
<span class="kw1">WHERE</span> SomeID <span class="sy0">LIKE</span> <span class="st0">'s%'</span>
&nbsp;
<span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> Test
<span class="kw1">WHERE</span> <span class="kw1">LEFT</span><span class="br0">&#40;</span>SomeID,<span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="st0">'s'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * FROM Test
WHERE SomeID LIKE 's%'

SELECT * FROM Test
WHERE LEFT(SomeID,1) = 's'</pre></div></div>

<p>Here is what the plans looks like</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Denis/Excecutionplan.PNG?mtime=1354498760"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Denis/Excecutionplan.PNG?mtime=1354498760" width="447" height="295" /></a></div>
<p>As you can see it is 9% versus 91% between the two queries, that is a big difference<br />
Hit CTRL + M again to disable the inclusion of the plan</p>
<p>Run this codeblock, it will give you the plans in a text format</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SET</span> SHOWPLAN_TEXT <span class="kw1">ON</span>
GO
&nbsp;
<span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> Test
<span class="kw1">WHERE</span> SomeID <span class="sy0">LIKE</span> <span class="st0">'s%'</span>
&nbsp;
<span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> Test
<span class="kw1">WHERE</span> <span class="kw1">LEFT</span><span class="br0">&#40;</span>SomeID,<span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="st0">'s'</span>
GO
&nbsp;
<span class="kw1">SET</span> SHOWPLAN_TEXT <span class="kw1">OFF</span>
GO</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SET SHOWPLAN_TEXT ON
GO

SELECT * FROM Test
WHERE SomeID LIKE 's%'

SELECT * FROM Test
WHERE LEFT(SomeID,1) = 's'
GO

SET SHOWPLAN_TEXT OFF
GO</pre></div></div>

<p>Here are the two plans</p>
<blockquote><p>|&#8211;Clustered Index Seek(OBJECT:([master].[dbo].[Test].[cx_test]),<br />
  SEEK:([master].[dbo].[Test].[SomeID] >= &#8216;R√æ&#8217; AND [master].[dbo].[Test].[SomeID] < 'T'),  
  WHERE:([master].[dbo].[Test].[SomeID] like 's%') ORDERED FORWARD)

    |--Clustered Index Scan(OBJECT:([master].[dbo].[Test].[cx_test]), 
	WHERE:(substring([master].[dbo].[Test].[SomeID],(1),(1))='s'))
</p></blockquote>
<p>As you can see the top one while looking more complicated is actually giving you a seek</p>
<h2>Making a case sensitive search sargable</h2>
<p>Now let&#8217;s take a look at how we can make a case sensitive search sargable as well<br />
In order to do a search and make it case sensitive, you have to have a case sensitive collation, if your table is not created with a case sensitive collation then you can supply it as part of the query</p>
<p>Here is an example to demonstrate what I mean</p>
<p>This is a simple table created without a collation</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> TempCase1 <span class="br0">&#40;</span>Val <span class="kw1">CHAR</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase1 <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'A'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase1 <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'a'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE TempCase1 (Val CHAR(1))
INSERT TempCase1 VALUES('A')
INSERT TempCase1 VALUES('a')</pre></div></div>

<p>Running this select statement will return both rows </p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> TempCase1
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'A'</span> </pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * FROM TempCase1
WHERE Val = 'A' </pre></div></div>

<p>Val<br />
&#8212;&#8211;<br />
A<br />
a</p>
<p>Now create the same kind of table but with a case sensitive collation</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> TempCase2 <span class="br0">&#40;</span>Val <span class="kw1">CHAR</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="kw1">COLLATE</span> SQL_Latin1_General_CP1_CS_AS<span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase2 <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'A'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase2 <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'a'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE TempCase2 (Val CHAR(1) COLLATE SQL_Latin1_General_CP1_CS_AS)
INSERT TempCase2 VALUES('A')
INSERT TempCase2 VALUES('a')</pre></div></div>

<p>Run the same query</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> TempCase2
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'A'</span> </pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * FROM TempCase2
WHERE Val = 'A' </pre></div></div>

<p>Val<br />
&#8212;&#8211;<br />
A</p>
<p>As you can see you only get the one row now that matches the case</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> TempCase1
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'A'</span> <span class="kw1">COLLATE</span> SQL_Latin1_General_CP1_CS_AS</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * FROM TempCase1
WHERE Val = 'A' COLLATE SQL_Latin1_General_CP1_CS_AS</pre></div></div>

<p>Val<br />
&#8212;&#8211;<br />
A<br />
a</p>
<p>Now let&#8217;s take a look at how we can make the case sensitive search sargable</p>
<p>First create this table and insert some data</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> TempCase <span class="br0">&#40;</span>Val <span class="kw1">CHAR</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
&nbsp;
<span class="kw1">INSERT</span> TempCase <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'A'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'B'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'C'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'D'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'E'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'F'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'G'</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> TempCase <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="st0">'H'</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE TempCase (Val CHAR(1))
 
INSERT TempCase VALUES('A')
INSERT TempCase VALUES('B')
INSERT TempCase VALUES('C')
INSERT TempCase VALUES('D')
INSERT TempCase VALUES('E')
INSERT TempCase VALUES('F')
INSERT TempCase VALUES('G')
INSERT TempCase VALUES('H')</pre></div></div>

<p>Now we will insert some lowercase characters</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">INSERT</span> TempCase
<span class="kw1">SELECT</span> <span class="kw2">LOWER</span><span class="br0">&#40;</span>Val<span class="br0">&#41;</span> <span class="kw1">FROM</span> TempCase</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">INSERT TempCase
SELECT LOWER(Val) FROM TempCase</pre></div></div>

<p>Now we will create our real table which will have 65536 rows</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> CaseSensitiveSearch <span class="br0">&#40;</span>Val <span class="kw1">VARCHAR</span><span class="br0">&#40;</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE CaseSensitiveSearch (Val VARCHAR(50))</pre></div></div>

<p>We will do a couple of cross joins to generate the data for our queries</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
</pre></td><td class="de1"><pre class="de1"><span class="kw1">INSERT</span> CaseSensitiveSearch
<span class="kw1">SELECT</span> t1.<span class="me1">val</span> <span class="sy0">+</span> t2.<span class="me1">val</span> <span class="sy0">+</span> t3.<span class="me1">val</span> <span class="sy0">+</span> t4.<span class="me1">val</span>
<span class="kw1">FROM</span> TempCase t1
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> TempCase t2
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> TempCase t3
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> TempCase t4</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">INSERT CaseSensitiveSearch
SELECT t1.val + t2.val + t3.val + t4.val
FROM TempCase t1
CROSS JOIN TempCase t2
CROSS JOIN TempCase t3
CROSS JOIN TempCase t4</pre></div></div>

<p>Create an index on the table</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">INDEX</span> IX_SearchVal <span class="kw1">ON</span> CaseSensitiveSearch<span class="br0">&#40;</span>Val<span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE INDEX IX_SearchVal ON CaseSensitiveSearch(Val)</pre></div></div>

<p>Just like before, if we run this we will get back the exact value we passed in and also all the upper case and lower case variations</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> CaseSensitiveSearch
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'ABCD'</span> </pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * FROM CaseSensitiveSearch
WHERE Val = 'ABCD' </pre></div></div>

<p>Here are the results of that query<br />
Val<br />
&#8212;&#8211;<br />
AbCd<br />
ABcd<br />
Abcd<br />
ABCd<br />
aBCd<br />
abCd<br />
aBcd<br />
abcd<br />
abCD<br />
aBcD<br />
abcD<br />
aBCD<br />
ABCD<br />
AbCD<br />
ABcD<br />
AbcD</p>
<p>If you add the collation to the query, you will get only what matches your value</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> CaseSensitiveSearch
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'ABCD'</span> <span class="kw1">COLLATE</span> SQL_Latin1_General_CP1_CS_AS</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * FROM CaseSensitiveSearch
WHERE Val = 'ABCD' COLLATE SQL_Latin1_General_CP1_CS_AS</pre></div></div>

<p>Here is the result, it maches what was passed in<br />
Val<br />
&#8212;<br />
ABCD</p>
<p>The problem with the query above is that it will cause a scan. So what can we do, how can we make it perform better?  It is simple combine the two queries<br />
First grab all case sensitive and case insensitive values and then after that filter out the case insensitive values</p>
<p>Here is what that query will look like</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> CaseSensitiveSearch
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'ABCD'</span> <span class="kw1">COLLATE</span> SQL_Latin1_General_CP1_CS_AS
<span class="sy0">AND</span> Val <span class="sy0">LIKE</span> <span class="st0">'ABCD'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * FROM CaseSensitiveSearch
WHERE Val = 'ABCD' COLLATE SQL_Latin1_General_CP1_CS_AS
AND Val LIKE 'ABCD'</pre></div></div>

<p>AND Val LIKE &#8216;ABCD&#8217; will result in a seek, now when it also does the Val = &#8216;ABCD&#8217; COLLATE SQL_Latin1_General_CP1_CS_AS part, it only returns the row that matches your value</p>
<p>If you run both queries, you can look at the plan difference (hit CTRL + M so that the plan is included)</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> CaseSensitiveSearch
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'ABCD'</span> <span class="kw1">COLLATE</span> SQL_Latin1_General_CP1_CS_AS
&nbsp;
&nbsp;
&nbsp;
<span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> CaseSensitiveSearch
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'ABCD'</span> <span class="kw1">COLLATE</span> SQL_Latin1_General_CP1_CS_AS
<span class="sy0">AND</span> Val <span class="sy0">LIKE</span> <span class="st0">'ABCD'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * FROM CaseSensitiveSearch
WHERE Val = 'ABCD' COLLATE SQL_Latin1_General_CP1_CS_AS



SELECT * FROM CaseSensitiveSearch
WHERE Val = 'ABCD' COLLATE SQL_Latin1_General_CP1_CS_AS
AND Val LIKE 'ABCD'</pre></div></div>

<p>Here is the plan</p>
<div class="image_block"><a href="/wp-content/uploads/blogs/DataMgmt/Denis/ExcecutionPlan2008.PNG?mtime=1354548699"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Denis/ExcecutionPlan2008.PNG?mtime=1354548699" width="903" height="364" /></a></div>
<p>As you can see, there is a big difference between the two</p>
<p>Here is the plan in text as well</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SET</span> SHOWPLAN_TEXT <span class="kw1">ON</span>
GO
&nbsp;
<span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> CaseSensitiveSearch
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'ABCD'</span> <span class="kw1">COLLATE</span> SQL_Latin1_General_CP1_CS_AS
&nbsp;
&nbsp;
&nbsp;
<span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">FROM</span> CaseSensitiveSearch
<span class="kw1">WHERE</span> Val <span class="sy0">=</span> <span class="st0">'ABCD'</span> <span class="kw1">COLLATE</span> SQL_Latin1_General_CP1_CS_AS
<span class="sy0">AND</span> Val <span class="sy0">LIKE</span> <span class="st0">'ABCD'</span>
&nbsp;
GO
&nbsp;
<span class="kw1">SET</span> SHOWPLAN_TEXT <span class="kw1">OFF</span>
GO</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SET SHOWPLAN_TEXT ON
GO
 
SELECT * FROM CaseSensitiveSearch
WHERE Val = 'ABCD' COLLATE SQL_Latin1_General_CP1_CS_AS



SELECT * FROM CaseSensitiveSearch
WHERE Val = 'ABCD' COLLATE SQL_Latin1_General_CP1_CS_AS
AND Val LIKE 'ABCD'

GO
 
SET SHOWPLAN_TEXT OFF
GO</pre></div></div>

<blockquote><p>  |&#8211;Table Scan(OBJECT:([tempdb].[dbo].[CaseSensitiveSearch]),<br />
   WHERE:(CONVERT_IMPLICIT(varchar(50),[tempdb].[dbo].[CaseSensitiveSearch].[Val],0)=CONVERT(varchar(8000),[@1],0)))</p>
<p>    |&#8211;Index Seek(OBJECT:([tempdb].[dbo].[CaseSensitiveSearch].[IX_SearchVal]), SEEK:([tempdb].[dbo].[CaseSensitiveSearch].[Val] >= &#8216;ABCD&#8217;<br />
     AND [tempdb].[dbo].[CaseSensitiveSearch].[Val] <= 'ABCD'), 
      WHERE:(CONVERT_IMPLICIT(varchar(50),[tempdb].[dbo].[CaseSensitiveSearch].[Val],0)='ABCD' AND [tempdb].[dbo].[CaseSensitiveSearch].[Val] like 'ABCD') ORDERED FORWARD)</p></blockquote>
<p>Also take a look at <a href="/index.php/DataMgmt/DataDesign/only-in-a-database-can-you-get-1000-impr">Only In A Database Can You Get 1000% + Improvement By Changing A Few Lines Of Code</a> to see how this works with dates</p>
<p>That is all for day three of the SQL Advent 2012 series, come back tomorrow for the next one, you can also check out all the posts from last year here: <a href="/index.php/DataMgmt/DataDesign/sql-advent-2011-recap">SQL Advent 2011 Recap</a></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/dbprogramming/sargable-queries/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
	</channel>
</rss>
