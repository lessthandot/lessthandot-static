<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>sql azure &#8211; LessthanDot</title>
	<atom:link href="/index.php/tag/sql-azure/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>A Technical Community for IT Professionals</description>
	<lastBuildDate>Sat, 09 Mar 2019 12:50:36 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.1</generator>
	<item>
		<title>Distributed Storage: How SQL Azure Replicas Work</title>
		<link>/index.php/architect/distributed-storage-how-sql-azure-replicas-work/</link>
		<comments>/index.php/architect/distributed-storage-how-sql-azure-replicas-work/#comments</comments>
		<pubDate>Wed, 18 Nov 2015 14:36:12 +0000</pubDate>
		<dc:creator><![CDATA[Eli Weinstock-Herman (tarwn)]]></dc:creator>
				<category><![CDATA[Architecture, Design and Strategy]]></category>
		<category><![CDATA[Azure]]></category>
		<category><![CDATA[Data Management]]></category>
		<category><![CDATA[distributed systems]]></category>
		<category><![CDATA[sql azure]]></category>

		<guid isPermaLink="false">/?p=4228</guid>
		<description><![CDATA[One of the benefits of Microsoft SQL Azure over an on-premises or VM installation is built-in resiliency. In a typical on-premises/VM installation your database lives on a single server, with all the single points of failure that brings to mind. SQL Azure, on the other hand, always has 3 or more replicas assigned for each [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>One of the benefits of Microsoft SQL Azure over an on-premises or VM installation is built-in resiliency. In a typical on-premises/VM installation your database lives on a single server, with all the single points of failure that brings to mind. SQL Azure, on the other hand, always has 3 or more replicas assigned for each database. This allows it to weather issues like network glitches and commodity hardware failures with no administration and little to no downtime.</p>
<div style="margin: 1em 3em; padding: 2em; font-size: 110%; border: 1px solid #dddddd; background-color: #eeeeee; border-radius: 6px;">There are interactive simulations below! Skip ahead if you just want to play with them, read through if you want more of the details <img src="https://s.w.org/images/core/emoji/2/72x72/1f642.png" alt="ðŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" /></div>
<p>Finding good, detailed articles about this has been difficult. Here&#8217;s a couple I found:</p>
<ul>
<li><a href="https://azure.microsoft.com/en-us/blog/fault-tolerance-in-windows-azure-sql-database/">Fault-tolerance in Windows Azure SQL Database</a></li>
<li><a href="http://social.technet.microsoft.com/wiki/contents/articles/1695.inside-microsoft-azure-sql-database/revision/33.aspx">Inside Microsoft Azure SQL Database</a> (retired article &#8211; this is a revision from prior to it being taken down)</li>
</ul>
<p>What really interested me was the database communications. How do reads flow into the database when there&#8217;s 3 of them? How do writes occur when one of my database replicas is down? How does a replica catch back up when it is available again?</p>
<p>I learn well from reading, but had to reread the articles a few times over the years before the information really stuck. So this post is an attempt to approach the topic from another direction, with active simulations of how this communications works in SQL Azure.</p>
<p><i>Note: When the two disagree, I&#8217;ll rely on the slight less out of date top article. When my practical (aka, support tickets) experience disagrees with both, I&#8217;ll point it out.</i></p>
<p><i>Note 2: I suspect the simulations below will make this a mobile-unfriendly post, sorry.</i></p>
<h1>Key Details of SQL Azure</h1>
<p>Before we start answering the questions above, lets extract some details from those dense articles to set the stage. </p>
<p>There are actually several layers of systems involved in SQL Azure, this post is going to focus just on the database operations. I&#8217;ll point out when the &#8220;fabric&#8221; is involved, but it won&#8217;t be part of the simulations. That being said, here&#8217;s the key details for the database:</p>
<ul>
<li> There are a minimum of 3 database replicas at all times</li>
<li>All incoming traffic goes to the Primary replica (elected by the &#8220;fabric&#8221;)</li>
<li>Replicas exist on different physical servers (created/managed by the &#8220;fabric&#8221;)</li>
<li>Database Writes require a quorum of 2 of the 3 replicas acknowledging the write in order to COMMIT</li>
<li>Database Reads return directly from the Primary replica</li>
<li>There is support for both transactional and full restores</li>
</ul>
<p>Each &#8220;data node&#8221; in the network includes the SQL Server processes involved in the items above as well asservices for failure detection, re-establishing nodes after failure, throttling, and so on. I won&#8217;t be diving into those today, this is all about the database replica.</p>
<p>Some Warnings:</p>
<ul>
<li>As far as I know, Azure SQL does not use HTTP codes internally. I used them in the simulations below as I thought they would be more recognizable then me making something up</li>
<li>SQL Server is not limited to key/value or single statement operations, this is a simplification I made so I could focus on the mechanics of the communications instead of diving into the MSSQL storage engine</li>
</ul>
<h2>How do writes work?</h2>
<p>Writes in SQL Azure come through a TDS gateway that, transparent to us, passes our queries to the Primary replica. The replica determines what the change will be from our operation, assigns a Change Sequence Number (CSN) to it, then replicates it to the secondary replicas. The Primary replica only commits the changes after it has received at least one acknowledgement back from the secondaries, ensuring the data now is now on at least two replicas (the Primary and one secondary). </p>
<div style="margin: 1em 3em; padding: 1em; text-align: center; border: 1px solid #dddddd; background-color: #eeeeee; border-radius: 6px;">Press the &#8220;Run&#8221; button below to start sending writes from the &#8220;gateway&#8221; into the replicas. </div>
<p><iframe src="http://tarwn.github.io/DistributedSamples/Javascript/blog/azure_w.html" style="width: 800px; height: 600px; border: 2px solid #eeeeee"></iframe></p>
<p>What you&#8217;re seeing is a simulation of the writes I described above. Each replica has a set of data that has been stored and a short transaction log and indicates whether it is the &#8220;PRIMARY&#8221; or &#8220;secondary&#8221; in it&#8217;s title bar. </p>
<p>The &#8220;gateway&#8221; in the top left sends each write to the PRIMARY replica. The PRIMARY replica calculates the storage change of the write, assigns it a CSN, and sends it to the two secondary replicas. These secondaries apply the change locally and send back an acknowledgement, at which point the PRIMARY commits the change (more on this in a moment). Once the PRIMARY commits the change, it returns a success response back to the person that sent that particular INSERT or UPDATE statement.</p>
<p>Keep in mind, this is a simulation. The model for the COMMIT above is based on what I found in the articles above, but is probably not quite right (and I would love it if someone has more definitive information about this so i could improve it).</p>
<h2>How do reads work?</h2>
<p>Reads are easy. Since the TDS gateway directs all queries to the Primary replica and it always has the most up to date data, it can respond with the values it has locally without seeking a quorum from the other replicas. </p>
<div style="margin: 1em 3em; padding: 1em; text-align: center; border: 1px solid #dddddd; background-color: #eeeeee; border-radius: 6px;">Press the &#8220;Run&#8221; button to send some quick writes and then watch how reads work.</div>
<p><iframe src="http://tarwn.github.io/DistributedSamples/Javascript/blog/azure_r.html" style="width: 800px; height: 600px; border: 2px solid #eeeeee"></iframe></p>
<p>As &#8220;Read&#8221; messages come in from the gateway, the PRIMARY replica looks the value up locally and returns it directly. </p>
<p>In the real SQL Azure replicas, this means that the PRIMARY replica has more work to do then the secondaries. This is where the &#8220;fabric&#8221; behind the scenes becomes critical, as it is responsible for trying to maintain a good balance of primary (read and write load) and secondaries (writes) across each server. When a new replica is created or a new PRIMARY is elected from the existing replicas, the &#8220;fabric&#8221; has to adjust things behind the scenes to balance out the work.</p>
<h2>Weathering Outages</h2>
<p>The point of the 3 node replica setup is to get high levels of resiliency from shared commodity hardware. If an outage is short enough, a transaction log update from whichever replica has the latest log can catch a restoring replica up to date. If the log has been exhausted, a full update can catch up a replica. Eventually, if the server or replica is unavailable long enough, the fabric will provision a new replica to replace it (not implemented in the simulation).</p>
<p>To help show both short outage cases, the simulated replicas only keep their last 4 transactions. This way a replica missing only a couple transactions will restore from transactions but a replica offline for more than 4 transactions will require a full restore.</p>
<div style="margin: 1em 3em; padding: 1em; text-align: center; border: 1px solid #dddddd; background-color: #eeeeee; border-radius: 6px;">Press the &#8220;Run&#8221; button to watch a shorter and longer outage while writing.</div>
<p><iframe src="http://tarwn.github.io/DistributedSamples/Javascript/blog/azure_o.html" style="width: 800px; height: 600px; border: 2px solid #eeeeee"></iframe></p>
<p>This is running a scripted loop of operations to show both restore cases. The script presses the turbo button during write transactions so we can skip ahead to the restore operations. When a replica&#8217;s border turns red, this means it has gone offline.</p>
<p>1) We prime the network with a couple writes, take replica &#8220;B&#8221; offline, send a couple more writes, then bring replica &#8220;B&#8221; back online. This results in a restore from transaction log.<br />
2) After a couple more writes, we take replica &#8220;B&#8221; offline again, wait for 5 more writes to occur, then bring replica &#8220;B&#8221; back online. This results in a full restore.</p>
<p>When a replica comes online, it sends a restore request to the other replicas and identifies the latest CSN it applied. If the other replicas have that CSN in their log, they send back the log and the restoring replica can use the latest of those two logs to catch up. if neither of the replicas can send back a log, then the restoring replica asks for a full restore. This isn&#8217;t heavily detailed in the documentation, so this is another place that matches the document but may not quite match the reality.</p>
<p>When the PRIMARY replica goes down, the documentation outlines monitoring that occurs that causes the &#8220;fabric&#8221; to elect a new PRIMARY replica. From my own experience, one or more types of failures are actually monitored on a 5-10 minute poll and this will result in a short outage (remainder of the 5-10 minute poll loop) before it is noticed and the &#8220;fabric&#8221; elects a new PRIMARY from the remaining secondaries.</p>
<p>For longer replica outages, not included in this simulation, the &#8220;fabric&#8221; will provision a new replica from a full restore and add it to the cluster as a new secondary, replacing the bad node. </p>
<p>Now that we have Writes, Reads, and an IT Person stumbling over power cords, it&#8217;s time to put it all together and play a little.</p>
<h2>Putting it all together</h2>
<p>Here we have a functioning network and 3 buttons. One button starts a stream of random reads and writes, the next unleashes our stumbling IT person to wander aimlessly around and stumble over power cords, and the third allows you to toggle between slower and faster message travel times.</p>
<div style="margin: 1em 3em; padding: 1em; text-align: center; border: 1px solid #dddddd; background-color: #eeeeee; border-radius: 6px;">Start sending random writes, reads, and outages!</div>
<p><iframe src="http://tarwn.github.io/DistributedSamples/Javascript/blog/azure_i.html" style="width: 800px; height: 600px; border: 2px solid #eeeeee"></iframe></p>
<p>One thing you may notice is that the outages are no longer confined to a single replica, now even the primary can go down.</p>
<p>There is a more extensive example here: <a href="http://tarwn.github.io/DistributedSamples/Javascript/azureSql.html">Azure SQL Simulation Console</a></p>
<p>This adds tracking expected versus actual responses, stale data, outage stats, and SLAs as well as the ability to add additional replicas to the cluster.</p>
<h2>Where the Simulation Is Wrong(ish)</h2>
<p>There are a few things that either did not match reality or for which I couldn&#8217;t find good enough information. Feedback would be awesome for these. There are also a few places where I simplified concepts that were outside the scope of talking about the communications and restore processes, if their absence is a problem, let me know and I&#8217;ll try to extend the models.</p>
<p>Things I simplified:</p>
<ul>
<li>Monitoring: I didn&#8217;t model the fabric or neighbor-based monitoring, instead servers will magically come back online every time and monitoring is performed by the generic &#8220;network&#8221; simulation.</li>
<li>Writes/Commits: I simplified this to single insert commits</li>
<li>HTTP Error Messages: I used HTTP status codes in messages because I don&#8217;t know the internal communications and it seemed good/simple enough</li>
</ul>
<p>Things I got wrong:</p>
<ul>
<li>Commits: While I tried to match the explained process, it is not wholly accurate and there is definitely a bug when a commit comes in with an Online Primary, a restoring Secondary, and an Offline secondary. It will be queued up for commit on the secondary but aborted on the primary due to lack of quorum, leading to a secondary that has bad data (and possibly both secondaries, if the other comes online before the next write occurs).</li>
<li>The Full Restore logic &#8211; this was an extrapolated guess from the documentation</li>
<li>SQL Transactions and multi-step operations &#8211; these aren&#8217;t implemented purely, but didn&#8217;t seem to add much value from the perspective of showing how the distributed logic works</li>
</ul>
<p>See anything else? I would love to know so I could improve the models, let me know.</p>
<style>
.post-area li{
    padding: 4px;
}
.post-area ul{
    padding-bottom: 8px;
}
</style>
]]></content:encoded>
			<wfw:commentRss>/index.php/architect/distributed-storage-how-sql-azure-replicas-work/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
		</item>
		<item>
		<title>SQL Azure How To Rebuild A Clustered Index</title>
		<link>/index.php/datamgmt/datadesign/sql-azure-how-to-rebuild/</link>
		<comments>/index.php/datamgmt/datadesign/sql-azure-how-to-rebuild/#respond</comments>
		<pubDate>Thu, 03 May 2012 23:52:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[azure]]></category>
		<category><![CDATA[cloud computing]]></category>
		<category><![CDATA[fragmentation]]></category>
		<category><![CDATA[sql azure]]></category>

		<guid isPermaLink="false">/index.php/2012/05/sql-azure-how-to-rebuild/</guid>
		<description><![CDATA[In yesterday's post A couple of things to be aware of when working with tables in SQL Azure I showed you some things to be aware of in regards to tables. Today let's talk about how to rebuild an index

Let's say you have a table with a clustered index&#8230;]]></description>
				<content:encoded><![CDATA[<p>In yesterday&#8217;s post <a href="/index.php/DataMgmt/DataDesign/a-couple-of-things-to">A couple of things to be aware of when working with tables in SQL Azure</a> I showed you some things to be aware of in regards to tables. Today let&#8217;s talk about how to rebuild an index</p>
<p>Let&#8217;s say you have a table with a clustered index on a uniqueidentifier column, you know that you have to use newid() instead of newsequentialid() since newsequentialid() is not supported. Clustering with newid() is not recommended because you will get page splits. Let&#8217;s take a look at how we can recreate the index</p>
<p>First create the following table with a clustered index</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> Test<span class="br0">&#40;</span>bla <span class="kw1">uniqueidentifier</span> <span class="kw1">default</span> newid<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
&nbsp;
<span class="kw1">CREATE</span> <span class="kw1">CLUSTERED</span> <span class="kw1">INDEX</span> ix_Test_bla <span class="kw1">on</span> Test<span class="br0">&#40;</span>bla<span class="br0">&#41;</span>
GO</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE Test(bla uniqueidentifier default newid())

CREATE CLUSTERED INDEX ix_Test_bla on Test(bla)
GO</pre></div></div>

<p>Now run the following block of code</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="de1"><pre class="de1">;<span class="kw1">WITH</span> CTE <span class="kw1">AS</span> <span class="br0">&#40;</span><span class="kw1">SELECT</span> <span class="nu0">1</span> <span class="kw1">AS</span> A 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">2</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">3</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">4</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">5</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">6</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> Test
<span class="kw1">SELECT</span> newid<span class="br0">&#40;</span><span class="br0">&#41;</span> 
<span class="kw1">FROM</span> CTE a
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> CTE b
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> CTE c
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> CTE d
GO <span class="nu0">5</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">;WITH CTE AS (SELECT 1 AS A 
			UNION ALL SELECT 2 
			UNION ALL SELECT 3 
			UNION ALL SELECT 4 
			UNION ALL SELECT 5
			UNION ALL SELECT 6)
INSERT Test
SELECT newid() 
FROM CTE a
CROSS JOIN CTE b
CROSS JOIN CTE c
CROSS JOIN CTE d
GO 5</pre></div></div>

<p>Beginning execution loop</p>
<p>(1296 row(s) affected)</p>
<p>(1296 row(s) affected)</p>
<p>(1296 row(s) affected)</p>
<p>(1296 row(s) affected)</p>
<p>(1296 row(s) affected)<br />
Batch execution completed 5 times.</p>
<p>Let&#8217;s see how fragmented the index is</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw2">Object_name</span><span class="br0">&#40;</span>s.<span class="kw2">object_id</span><span class="br0">&#41;</span> <span class="kw1">as</span> Tablename,s.<span class="me1">name</span> <span class="kw1">as</span> Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
<span class="kw1">FROM</span> sys.<span class="me1">dm_db_index_physical_stats</span> <span class="br0">&#40;</span><span class="kw2">DB_ID</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, <span class="sy0">NULL</span>, <span class="sy0">NULL</span> , <span class="sy0">NULL</span>, N<span class="st0">'LIMITED'</span><span class="br0">&#41;</span> d
join sys.<span class="me1">indexes</span> s <span class="kw1">on</span> d.<span class="kw2">object_id</span> <span class="sy0">=</span> s.<span class="kw2">object_id</span>
and d.<span class="me1">index_id</span> <span class="sy0">=</span> s.<span class="me1">index_id</span>
and s.<span class="me1">name</span> <span class="sy0">=</span> <span class="st0">'ix_Test_bla'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT Object_name(s.object_id) as Tablename,s.name as Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
FROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, N'LIMITED') d
join sys.indexes s on d.object_id = s.object_id
and d.index_id = s.index_id
and s.name = 'ix_Test_bla'</pre></div></div>

<p>
<pre>Tablename	Indexname	index_type_desc	avg_fragmentation_in_percent	page_count
Test	        ix_Test_bla	CLUSTERED INDEX	34.4827586206897                 58</pre>
<p>Now it is time to &#8216;fix&#8217; the index, we can either defragment/reorganize or rebuild the index</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">ALTER</span> <span class="kw1">INDEX</span> ix_Test_bla <span class="kw1">ON</span> <span class="br0">&#91;</span>dbo<span class="br0">&#93;</span>.<span class="br0">&#91;</span>Test<span class="br0">&#93;</span> RE<span class="sy0">OR</span>GANIZE</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">ALTER INDEX ix_Test_bla ON [dbo].[Test] REORGANIZE</pre></div></div>

<p><em>Msg 40517, Level 16, State 1, Line 1<br />
Keyword or statement option &#8216;REORGANIZE&#8217; is not supported in this version of SQL Server.</em></p>
<p>Okay, so SQL Azure does not support reorganizing the index<br />
What if we drop the index and then create it again?</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">DROP</span> <span class="kw1">INDEX</span> <span class="br0">&#91;</span>ix_Test_bla<span class="br0">&#93;</span> <span class="kw1">ON</span> <span class="br0">&#91;</span>dbo<span class="br0">&#93;</span>.<span class="br0">&#91;</span>Test<span class="br0">&#93;</span> 
GO</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">DROP INDEX [ix_Test_bla] ON [dbo].[Test] 
GO</pre></div></div>

<p><em>Msg 40054, Level 16, State 2, Line 1<br />
Tables without a clustered index are not supported in this version of SQL Server. Please create a clustered index and try again.<br />
The statement has been terminated.</em></p>
<p>Mmmm, not supported either, let&#8217;s try creating the index with the drop_existing clause</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">CLUSTERED</span> <span class="kw1">INDEX</span> <span class="br0">&#91;</span>ix_Test_bla<span class="br0">&#93;</span> <span class="kw1">ON</span> <span class="br0">&#91;</span>dbo<span class="br0">&#93;</span>.<span class="br0">&#91;</span>Test<span class="br0">&#93;</span>
<span class="br0">&#40;</span>
&nbsp; &nbsp; <span class="br0">&#91;</span>bla<span class="br0">&#93;</span> <span class="kw1">ASC</span>
<span class="br0">&#41;</span><span class="kw1">WITH</span> <span class="br0">&#40;</span>DROP_EXIST<span class="sy0">IN</span>G <span class="sy0">=</span> <span class="kw1">ON</span><span class="br0">&#41;</span>
GO</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE CLUSTERED INDEX [ix_Test_bla] ON [dbo].[Test]
(
	[bla] ASC
)WITH (DROP_EXISTING = ON)
GO</pre></div></div>

<p>That worked, let&#8217;s check fragmentation again</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw2">Object_name</span><span class="br0">&#40;</span>s.<span class="kw2">object_id</span><span class="br0">&#41;</span> <span class="kw1">as</span> Tablename,s.<span class="me1">name</span> <span class="kw1">as</span> Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
<span class="kw1">FROM</span> sys.<span class="me1">dm_db_index_physical_stats</span> <span class="br0">&#40;</span><span class="kw2">DB_ID</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, <span class="sy0">NULL</span>, <span class="sy0">NULL</span> , <span class="sy0">NULL</span>, N<span class="st0">'LIMITED'</span><span class="br0">&#41;</span> d
join sys.<span class="me1">indexes</span> s <span class="kw1">on</span> d.<span class="kw2">object_id</span> <span class="sy0">=</span> s.<span class="kw2">object_id</span>
and d.<span class="me1">index_id</span> <span class="sy0">=</span> s.<span class="me1">index_id</span>
and s.<span class="me1">name</span> <span class="sy0">=</span> <span class="st0">'ix_Test_bla'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT Object_name(s.object_id) as Tablename,s.name as Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
FROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, N'LIMITED') d
join sys.indexes s on d.object_id = s.object_id
and d.index_id = s.index_id
and s.name = 'ix_Test_bla'</pre></div></div>

<p>
<pre>Tablename	Indexname	index_type_desc	avg_fragmentation_in_percent	page_count
Test	        ix_Test_bla	CLUSTERED INDEX	4.76190476190476                21</pre>
<p>Mmmm, didn&#8217;t get rid of all the fragmentation. What happens if we try to do the same again?</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">CLUSTERED</span> <span class="kw1">INDEX</span> <span class="br0">&#91;</span>ix_Test_bla<span class="br0">&#93;</span> <span class="kw1">ON</span> <span class="br0">&#91;</span>dbo<span class="br0">&#93;</span>.<span class="br0">&#91;</span>Test<span class="br0">&#93;</span>
<span class="br0">&#40;</span>
&nbsp; &nbsp; <span class="br0">&#91;</span>bla<span class="br0">&#93;</span> <span class="kw1">ASC</span>
<span class="br0">&#41;</span><span class="kw1">WITH</span> <span class="br0">&#40;</span>DROP_EXIST<span class="sy0">IN</span>G <span class="sy0">=</span> <span class="kw1">ON</span><span class="br0">&#41;</span>
GO</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE CLUSTERED INDEX [ix_Test_bla] ON [dbo].[Test]
(
	[bla] ASC
)WITH (DROP_EXISTING = ON)
GO</pre></div></div>


<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw2">Object_name</span><span class="br0">&#40;</span>s.<span class="kw2">object_id</span><span class="br0">&#41;</span> <span class="kw1">as</span> Tablename,s.<span class="me1">name</span> <span class="kw1">as</span> Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
<span class="kw1">FROM</span> sys.<span class="me1">dm_db_index_physical_stats</span> <span class="br0">&#40;</span><span class="kw2">DB_ID</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, <span class="sy0">NULL</span>, <span class="sy0">NULL</span> , <span class="sy0">NULL</span>, N<span class="st0">'LIMITED'</span><span class="br0">&#41;</span> d
join sys.<span class="me1">indexes</span> s <span class="kw1">on</span> d.<span class="kw2">object_id</span> <span class="sy0">=</span> s.<span class="kw2">object_id</span>
and d.<span class="me1">index_id</span> <span class="sy0">=</span> s.<span class="me1">index_id</span>
and s.<span class="me1">name</span> <span class="sy0">=</span> <span class="st0">'ix_Test_bla'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT Object_name(s.object_id) as Tablename,s.name as Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
FROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, N'LIMITED') d
join sys.indexes s on d.object_id = s.object_id
and d.index_id = s.index_id
and s.name = 'ix_Test_bla'</pre></div></div>

<p>
<pre>Tablename	Indexname	index_type_desc	avg_fragmentation_in_percent	page_count
Test	        ix_Test_bla	CLUSTERED INDEX	9.52380952380952                 21</pre>
<p>Still didn&#8217;t get rid of all fragmentation<br />
Let&#8217;s try something else, first we are going to add some more data</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="de1"><pre class="de1">;<span class="kw1">WITH</span> CTE <span class="kw1">AS</span> <span class="br0">&#40;</span><span class="kw1">SELECT</span> <span class="nu0">1</span> <span class="kw1">AS</span> A 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">2</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">3</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">4</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">5</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">UNION</span> <span class="sy0">ALL</span> <span class="kw1">SELECT</span> <span class="nu0">6</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> Test
<span class="kw1">SELECT</span> newid<span class="br0">&#40;</span><span class="br0">&#41;</span> 
<span class="kw1">FROM</span> CTE a
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> CTE b
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> CTE c
<span class="sy0">CROSS</span> <span class="sy0">JOIN</span> CTE d
go <span class="nu0">5</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">;WITH CTE AS (SELECT 1 AS A 
			UNION ALL SELECT 2 
			UNION ALL SELECT 3 
			UNION ALL SELECT 4 
			UNION ALL SELECT 5
			UNION ALL SELECT 6)
INSERT Test
SELECT newid() 
FROM CTE a
CROSS JOIN CTE b
CROSS JOIN CTE c
CROSS JOIN CTE d
go 5</pre></div></div>

<p>Let&#8217;s check fragmentation</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw2">Object_name</span><span class="br0">&#40;</span>s.<span class="kw2">object_id</span><span class="br0">&#41;</span> <span class="kw1">as</span> Tablename,s.<span class="me1">name</span> <span class="kw1">as</span> Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
<span class="kw1">FROM</span> sys.<span class="me1">dm_db_index_physical_stats</span> <span class="br0">&#40;</span><span class="kw2">DB_ID</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, <span class="sy0">NULL</span>, <span class="sy0">NULL</span> , <span class="sy0">NULL</span>, N<span class="st0">'LIMITED'</span><span class="br0">&#41;</span> d
join sys.<span class="me1">indexes</span> s <span class="kw1">on</span> d.<span class="kw2">object_id</span> <span class="sy0">=</span> s.<span class="kw2">object_id</span>
and d.<span class="me1">index_id</span> <span class="sy0">=</span> s.<span class="me1">index_id</span>
and s.<span class="me1">name</span> <span class="sy0">=</span> <span class="st0">'ix_Test_bla'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT Object_name(s.object_id) as Tablename,s.name as Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
FROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, N'LIMITED') d
join sys.indexes s on d.object_id = s.object_id
and d.index_id = s.index_id
and s.name = 'ix_Test_bla'</pre></div></div>

<p>
<pre>Tablename	Indexname	index_type_desc	avg_fragmentation_in_percent	page_count
Test	        ix_Test_bla	CLUSTERED INDEX	72.8395061728395                 81</pre>
<p>Oh yeah, that is real bad</p>
<p>Now let&#8217;s rebuild the index instead</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">ALTER</span> <span class="kw1">INDEX</span> ix_Test_bla <span class="kw1">ON</span> <span class="br0">&#91;</span>dbo<span class="br0">&#93;</span>.<span class="br0">&#91;</span>Test<span class="br0">&#93;</span> REBUILD</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">ALTER INDEX ix_Test_bla ON [dbo].[Test] REBUILD</pre></div></div>

<p>Check fragmentation again</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
6
7
8
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="kw2">Object_name</span><span class="br0">&#40;</span>s.<span class="kw2">object_id</span><span class="br0">&#41;</span> <span class="kw1">as</span> Tablename,s.<span class="me1">name</span> <span class="kw1">as</span> Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
<span class="kw1">FROM</span> sys.<span class="me1">dm_db_index_physical_stats</span> <span class="br0">&#40;</span><span class="kw2">DB_ID</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, <span class="sy0">NULL</span>, <span class="sy0">NULL</span> , <span class="sy0">NULL</span>, N<span class="st0">'LIMITED'</span><span class="br0">&#41;</span> d
join sys.<span class="me1">indexes</span> s <span class="kw1">on</span> d.<span class="kw2">object_id</span> <span class="sy0">=</span> s.<span class="kw2">object_id</span>
and d.<span class="me1">index_id</span> <span class="sy0">=</span> s.<span class="me1">index_id</span>
and s.<span class="me1">name</span> <span class="sy0">=</span> <span class="st0">'ix_Test_bla'</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT Object_name(s.object_id) as Tablename,s.name as Indexname
,index_type_desc
,avg_fragmentation_in_percent
,page_count
FROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, N'LIMITED') d
join sys.indexes s on d.object_id = s.object_id
and d.index_id = s.index_id
and s.name = 'ix_Test_bla'</pre></div></div>

<p>
<pre>Tablename	Indexname	index_type_desc	avg_fragmentation_in_percent	page_count
Test	        ix_Test_bla	CLUSTERED INDEX	0                               41</pre>
<p>And just like that all the fragmentation is gone&#8230;..good times</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/sql-azure-how-to-rebuild/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>A couple of things to be aware of when working with tables in SQL Azure</title>
		<link>/index.php/datamgmt/datadesign/a-couple-of-things-to/</link>
		<comments>/index.php/datamgmt/datadesign/a-couple-of-things-to/#comments</comments>
		<pubDate>Wed, 02 May 2012 23:25:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[azure]]></category>
		<category><![CDATA[sql azure]]></category>
		<category><![CDATA[the cloud]]></category>

		<guid isPermaLink="false">/index.php/2012/05/a-couple-of-things-to/</guid>
		<description><![CDATA[I was messing around with SQL Azure today and noticed a couple of things that are not supported compared to the regular version of SQL Server in regards to tables. I will list these in this post.

All the code has been tested against the following ver&#8230;]]></description>
				<content:encoded><![CDATA[<p>I was messing around with SQL Azure today and noticed a couple of things that are not supported compared to the regular version of SQL Server in regards to tables. I will list these in this post.</p>
<p>All the code has been tested against the following version of SQL Azure as returned by @@version</p>
<p>Microsoft SQL Azure (RTM) &#8211; 11.0.1892.4<br />
Apr 24 2012 10:21:54 Copyright (c) Microsoft Corporation</p>
<p>
<h2>1) Tables have to have a clustered index if you want to insert data into those tables</h2>
<p>There is actually no problem creating a table without a clustered index (heap)<br />
If you run this code</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> Test<span class="br0">&#40;</span>bla <span class="kw1">uniqueidentifier</span> <span class="kw1">default</span> newid<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE Test(bla uniqueidentifier default newid())</pre></div></div>

<p>And then refresh and expand the tables folder, you will see the following</p>
<p><a href="/wp-content/uploads/blogs/DataMgmt/Denis/AzureTable.PNG?mtime=1336007070"><img alt="" src="/wp-content/uploads/blogs/DataMgmt/Denis/AzureTable.PNG?mtime=1336007070" width="422" height="356" /></a></p>
<p>Now run the following</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">INSERT</span> Test <span class="kw1">DEFAULT</span> <span class="kw1">VALUES</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">INSERT Test DEFAULT VALUES</pre></div></div>

<p>And here is the error<br />
<em>Msg 40054, Level 16, State 1, Line 1<br />
Tables without a clustered index are not supported in this version of SQL Server. Please create a clustered index and try again.</em></p>
<p>Adding a clustered index and running the insert again fixes this</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">CLUSTERED</span> <span class="kw1">INDEX</span> ix_Test_bla <span class="kw1">on</span> Test<span class="br0">&#40;</span>bla<span class="br0">&#41;</span>
GO
&nbsp;
<span class="kw1">INSERT</span> Test <span class="kw1">DEFAULT</span> <span class="kw1">VALUES</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE CLUSTERED INDEX ix_Test_bla on Test(bla)
GO

INSERT Test DEFAULT VALUES</pre></div></div>

<p>The problem is that until you try to insert data in your tables, you won&#8217;t see this error, at that point it might be too late and your application will fail</p>
<p>To list all the tables in your database without a clustered index, you can use this code</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
3
4
5
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> t.<span class="me1">name</span> 
<span class="kw1">FROM</span> sys.<span class="me1">tables</span> t
<span class="kw1">WHERE</span> <span class="sy0">NOT</span> <span class="sy0">EXISTS</span> <span class="br0">&#40;</span>&nbsp; <span class="kw1">SELECT</span> <span class="nu0">1</span> &nbsp;<span class="kw1">FROM</span> sys.<span class="me1">indexes</span> i
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">WHERE</span> i.<span class="me1">type_desc</span> <span class="sy0">=</span> <span class="st0">'CLUSTERED'</span> 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">AND</span> i.<span class="kw2">object_id</span> <span class="sy0">=</span> t.<span class="kw2">object_id</span> <span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT t.name 
FROM sys.tables t
WHERE NOT EXISTS (	SELECT 1  FROM sys.indexes i
					WHERE i.type_desc = 'CLUSTERED' 
					AND i.object_id = t.object_id )</pre></div></div>

<p>BTW, temporary tables can be created without a  clustered index, this runs without a problem</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
2
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> #bla<span class="br0">&#40;</span>id <span class="kw1">int</span><span class="br0">&#41;</span>
<span class="kw1">INSERT</span> #bla <span class="kw1">VALUES</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE #bla(id int)
INSERT #bla VALUES(1)</pre></div></div>

<p>
<h2>2) Global temporary tables are not supported</h2>
<p>If you try to create the following global temporary table, you will get an error</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> ##bla<span class="br0">&#40;</span>id <span class="kw1">int</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE ##bla(id int)</pre></div></div>

<p><em>Msg 40516, Level 15, State 1, Line 2<br />
Global temp objects are not supported in this version of SQL Server.</em></p>
<p>I admit that I have only used a global temporary table once or twice in the last 10+ years or so, I don&#8217;t think this is a big deal</p>
<p>
<h2>3) Select Into is not supported</h2>
<p>You cannot use select into either in SQL Azure</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">SELECT</span> <span class="sy0">*</span> <span class="kw1">INTO</span> Testb <span class="kw1">from</span> Test</pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">SELECT * INTO Testb from Test</pre></div></div>

<p>Here is the error<br />
<em>Msg 40510, Level 16, State 1, Line 1<br />
Statement &#8216;SELECT INTO&#8217; is not supported in this version of SQL Server.</em></p>
<p>I don&#8217;t think this is a big deal either, sure you will have to list all the columns and create the table first before inserting, this could be a pain in the neck but it is not the end of the world</p>
<p>
<h2>4) Newsequentialid() is not supported</h2>
<p>Remember this table from before</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> Test2<span class="br0">&#40;</span>bla <span class="kw1">uniqueidentifier</span> <span class="kw1">default</span> newid<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE Test2(bla uniqueidentifier default newid())</pre></div></div>

<p>Try making that default newsequentialid() instead of newid()</p>

<div class="bwp-syntax-block clearfix">
<div class="bwp-syntax-toolbar"><div class="bwp-syntax-control"><a href="javascript:;" class="bwp-syntax-source-switch" title="View Source Code"></a></div></div>
<div class="bwp-syntax-wrapper clearfix bwp-syntax-simple"><table class="tsql"><thead><tr><td colspan="2"  class="head">T-SQL</td></tr></thead><tbody><tr class="li1"><td class="ln"><pre class="de1">1
</pre></td><td class="de1"><pre class="de1"><span class="kw1">CREATE</span> <span class="kw1">TABLE</span> Testb<span class="br0">&#40;</span>bla <span class="kw1">uniqueidentifier</span> <span class="kw1">default</span> newsequentialid<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span></pre></td></tr></tbody></table></div>
<div class="bwp-syntax-source"><pre class="no-parse">CREATE TABLE Testb(bla uniqueidentifier default newsequentialid())</pre></div></div>

<p>Here is the error message<br />
<em>Msg 40511, Level 15, State 1, Line 1<br />
Built-in function &#8216;newsequentialid&#8217; is not supported in this version of SQL Server.</em></p>
<p>In this case, you will probably need to go with newid() instead of newsequentialid(), not a big change</p>
<p>
<h2>Conclusion</h2>
<p>Overall I don&#8217;t think that these are major issues and should be fairly easy to either change the design or change the code to get around these limitations in this version of SQL Azure</p>
<p>What do you think, big pain in the neck or no big deal?</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/a-couple-of-things-to/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
		</item>
		<item>
		<title>New 100MB database option and lower pricing across the board for SQL Azure</title>
		<link>/index.php/datamgmt/datadesign/new-100mb-database-option-and/</link>
		<comments>/index.php/datamgmt/datadesign/new-100mb-database-option-and/#respond</comments>
		<pubDate>Tue, 14 Feb 2012 15:37:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[azure]]></category>
		<category><![CDATA[cloud computing]]></category>
		<category><![CDATA[sql azure]]></category>

		<guid isPermaLink="false">/index.php/2012/02/new-100mb-database-option-and/</guid>
		<description><![CDATA[The cloud just go a whole lot cheaper for SQL Azure customers


To meet evolving customer needs across both ends of the database size spectrum, Microsoft announced that they are lowering the price of SQL Azure and introducing a 100MB database option&#8230;]]></description>
				<content:encoded><![CDATA[<p>The cloud just got a whole lot cheaper for SQL Azure customers</p>
<p>To meet evolving customer needs across both ends of the database size spectrum, Microsoft announced that they are lowering the price of SQL Azure and introducing a 100MB database option at $5 per month.  Customers will realize 48% to 75% savings for databases larger than 1GB.  The 100MB DB option enables customers to get started using SQL Azure at half of the previous price</p>
<p>Here is what the pricing looks like, you can also see the percentage of the decrease</p>
<div class="tables">
<table>
<tr>
<th>GB</th>
<th>Previous Pricing</th>
<th>New Pricing</th>
<th>New Price/GB</th>
<th>Total % Decrease</th>
</tr>
<tr>
<td>5</td>
<td>$49.95</td>
<td>$25.99</td>
<td>$5.20</td>
<td>48%</td>
</tr>
<tr>
<td>10</td>
<td>$99.99</td>
<td>$45.99</td>
<td>$4.60</td>
<td>54%</td>
</tr>
<tr>
<td>25</td>
<td>$299.97</td>
<td>$75.99</td>
<td>$3.04</td>
<td>75%</td>
</tr>
<tr>
<td>50</td>
<td>$499.95</td>
<td>$125.99</td>
<td>$2.52</td>
<td>75%</td>
</tr>
<tr>
<td>100</td>
<td>$499.95</td>
<td>$175.99</td>
<td>$1.76</td>
<td>65%</td>
</tr>
<tr>
<td>150</td>
<td>$499.95*</td>
<td>$225.99</td>
<td>$1.51</td>
<td>55%</td>
</tr>
<table></table>
</table>
</div>
<p>*Previous prices 50GB and larger reflect price cap of $499.95 announced December 12, 2011.</p>
<p>As you can see some of these prices decreased by 75%, that is great news for customers.</p>
<p>More details can be found here: https://www.windowsazure.com/en-us/pricing/details/#database</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/new-100mb-database-option-and/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>SQL Azure Compatibility Assessment service released</title>
		<link>/index.php/datamgmt/datadesign/sql-azure-compatibility-assessment-service/</link>
		<comments>/index.php/datamgmt/datadesign/sql-azure-compatibility-assessment-service/#comments</comments>
		<pubDate>Wed, 04 Jan 2012 08:42:00 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[azure]]></category>
		<category><![CDATA[cloud computing]]></category>
		<category><![CDATA[sql azure]]></category>

		<guid isPermaLink="false">/index.php/2012/01/sql-azure-compatibility-assessment-service/</guid>
		<description><![CDATA[If you are considering moving your SQL Server databases to SQL Azure, you can use the SQL Azure Compatibility Assessment to check if your database schema is compatible with SQL Azure. This service is very easy to use and does not require an Azure accoun&#8230;]]></description>
				<content:encoded><![CDATA[<p>If you are considering moving your SQL Server databases to SQL Azure, you can use the SQL Azure Compatibility Assessment to check if your database schema is compatible with SQL Azure. This service is very easy to use and does not require an Azure account.</p>
<p>To use this service, you need a Live ID and a .dacpac extracted from your database, you do not need to have an Azure account or have Azure knowledge</p>
<p>In order to use the SQL Azure Compatibility Assessment you need to prepare a .dacpac of your database and go to the service portal: https://assess.sql.azure.com/ to use the service.</p>
<p>There is a 2 minute and 52 seconds video available here: http://www.microsoft.com/en-us/showcase/details.aspx?uuid=6302dccd-3a20-483e-8ec7-5ff5ad72c2c2</p>
<p>The SQL Azure Compatibility Assessment will give you a report of things that are not supported (like full text indexes) or things you need to fix (like adding a clustered index if you want to do inserts)</p>
<p>More information about SQL Azure Compatibility Assessment can be found in this TechNet wiki article: http://social.technet.microsoft.com/wiki/contents/articles/6246.aspx</p>
<p>Happy cloud computing  <img src="https://s.w.org/images/core/emoji/2/72x72/1f642.png" alt="ðŸ™‚" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/sql-azure-compatibility-assessment-service/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>SQL Azure CTP Testers Can Upgrade Their Accounts To Paid Commercial Subscriptions Starting Today</title>
		<link>/index.php/datamgmt/datadesign/sql-azure-ctp-testers-can-upgrade-their/</link>
		<comments>/index.php/datamgmt/datadesign/sql-azure-ctp-testers-can-upgrade-their/#respond</comments>
		<pubDate>Mon, 04 Jan 2010 17:17:39 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Administration]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[azure]]></category>
		<category><![CDATA[cloud computing]]></category>
		<category><![CDATA[sql azure]]></category>

		<guid isPermaLink="false">/index.php/2010/01/sql-azure-ctp-testers-can-upgrade-their/</guid>
		<description><![CDATA[According to a post on the SQL Azure Team Blog you can upgrade your CTP accounts to a paid commercial subscription starting today, below is an excerpt from that post Starting today you will be able to upgrade your Community Technology Preview (CTP) account to a paid commercial subscriptions. If you upgrade your CTP accounts [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>According to a post on the <a href="http://blogs.msdn.com/ssds/archive/2010/01/04/9943474.aspx">SQL Azure Team Blog</a> you can upgrade your CTP accounts to a paid commercial subscription starting today, below is an excerpt from that post</p>
<blockquote><p>Starting today you will be able to upgrade your Community Technology Preview (CTP) account to a paid commercial subscriptions. If you upgrade your CTP accounts during the month of January, 2010, all Windows Azure platform usage incurred during this month will be at no charge. You will also have full visibility during this month to your Windows Azure platform usage. Billing and SLAs for all commercial accounts will begin on February 1st, 2010</p></blockquote>
<p>Pricing is also announced, here is for example the Windows Azure Platform Introductory Special</p>
<p><em>
<p><strong>Included each month at no charge:</strong></p>
<ul>
<li>Windows Azure</li>
<ul>
<li>25 hours of a small compute instance</li>
<li>500 MB of storage</li>
<li>10,000 storage transactions</li>
</ul>
<li>SQL Azure</li>
<ul>
<li>1 Web Edition database (available for first 3 months only)</li>
</ul>
<li>AppFabric</li>
<ul>
<li>100,000 Access Control and Service Bus message operations*</li>
</ul>
<li>Data Transfers (per region**)</li>
<ul>
<li>500 MB in</li>
<li>500 MB out</li>
</ul>
</ul>
<p><strong>Standard Rates:</strong></p>
<p>Windows Azure</p>
<ul>
<li>Compute</li>
<ul>
<li>Small instance (default): $0.12 per hour</li>
<li>Medium instance: $0.24 per hour</li>
<li>Large instance: $0.48 per hour</li>
<li>Extra large instance: $0.96 per hour</li>
</ul>
<li>Storage</li>
<ul>
<li>$0.15 per GB stored per month</li>
<li>$0.01 per 10,000 storage transactions</li>
</ul>
<li>Content Delivery Network (CDN)</li>
<ul>
<li>Service currently available as a Community Technology Preview (CTP) at no charge</li>
</ul>
</ul>
<p>SQL Azure</p>
<ul>
<li>Web Edition â€“ Up to 1 GB relational database</li>
<ul>
<li>$9.99 per database per month</li>
</ul>
<li>Business Edition â€“ Up to 10 GB relational database</li>
<ul>
<li>$99.99 per database per month </li>
</ul>
</ul>
<p>AppFabric</p>
<ul>
<li>Access Control</li>
<ul>
<li>$0.15 per 100,000 message operations*</li>
</ul>
<li>Service Bus</li>
<ul>
<li>$0.15 per 100,000 message operations*</li>
</ul>
</ul>
<p>Data Transfers</p>
<ul>
<li>North America and Europe** regions</li>
<ul>
<li>$0.10 per GB in</li>
<li>$0.15 per GB out</li>
</ul>
<li>Asia Pacific** Region</li>
<ul>
<li>$0.30 per GB in</li>
<li>$0.45 per GB out</li>
</ul>
<li>Inbound data transfers during off-peak times through June 30, 2010 are at no charge.  Prices revert to our normal inbound data transfer rates after June 30, 2010.</li>
</ul>
<p> </em></p>
<p>You can get all the other pricing information here: http://www.microsoft.com/windowsazure/offers/</p>
<p>Now SQL Azure makes sense for some people and for some people it does not. In my case it does not since my databases are much bigger than what SQL Azure currently supports.</p>
<p>If you are thinking of migrating to SQL Azure I encourage you to listen to the following podcast on dotnetrocks: <a href="http://www.dotnetrocks.com/default.aspx?showNum=512">Huey and Wegner Migrate Us to SQL Azure</a>. in this podcast a lot of things that will not work in SQL Azure but do work in SQL Server will be examined.</p>
<p><strong>SQL Azure Migration Wizard </strong><br />
Before you migrate to SQL Azure for SQL Server I encourage you to check out the SQL Azure Migration Wizard. Here is what the SQL Azure Migration Wizard does</p>
<p>The SQL Azure Migration Wizard helps you migrate your local SQL Server 2005 / 2008 databases into SQL Azure. The wizard walks you through the selection of your SQL objects, creates SQL scripts suitable for SQL Azure, and allows you to migrate your data.</p>
<p><b>Project Details</b><br />The SQL Azure Migration Wizard (SQLAzureMW) gives you the options to analyzes, generates scripts, and migrate data (via BCP) from: </p>
<ol>
<li>SQL Server to SQL Azure</li>
<li>SQL Azure to  SQL Server</li>
<li>SQL Azure to SQL Azure</li>
</ol>
<p>It will also analyze SQL Profiler trace files and TSQL script for compatibility issues with SQL Azure. </p>
<ol>
<li>If your source is a SQL Server database, SQLAzureMW will list all of the object types (i.e. Tables, Stored Procedures, Views, etc.) and let you decide which ones you want analyzed / scripted. Using the â€œAdvancedâ€ options you can tell SQLAzureMW which compatibility checks to perform and if the data should be migrated.</li>
<li>If your source is a file containing TSQL, then you will be given the option to have SQLAzureMW check the TSQL for incompatibilities and fix where possible or just run the script without any compatibility checking.</li>
<li>You can specify a SQL Profiler trace file for analysis.</li>
</ol>
<p></p>
<p>You can download the SQL Azure Migration Wizard on CodePlex here: http://sqlazuremw.codeplex.com/</p>
<p>*** <strong>Remember, if you have a SQL related question try our <a href="http://forum.lessthandot.com/viewforum.php?f=17">Microsoft SQL Server Programming</a> forum or our <a href="http://forum.lessthandot.com/viewforum.php?f=22">Microsoft SQL Server Admin</a> forum</strong><ins></ins></p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/sql-azure-ctp-testers-can-upgrade-their/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Windows Azure, SQL Azure and .NET Services pricing announced</title>
		<link>/index.php/datamgmt/datadesign/windows-azure-sql-azure-and-net-services/</link>
		<comments>/index.php/datamgmt/datadesign/windows-azure-sql-azure-and-net-services/#comments</comments>
		<pubDate>Tue, 14 Jul 2009 12:55:42 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[.net services]]></category>
		<category><![CDATA[sql azure]]></category>
		<category><![CDATA[windows azure]]></category>

		<guid isPermaLink="false">/index.php/2009/07/windows-azure-sql-azure-and-net-services/</guid>
		<description><![CDATA[Microsoft announced pricing for Azure. Today, during the Microsoft Worldwide Partner Conference 2009 Microsoft announced the business and partner model for the Windows Azure platform including service level agreements and support programs. Windows Azure, SQL Azure and .NET Services will be commercially available at the Professional Developer Conference 2009 and Microsoft hopes you will continue [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>Microsoft announced pricing for Azure.</p>
<p>Today, during the Microsoft Worldwide Partner Conference 2009 Microsoft announced the business and partner model for the Windows Azure platform including service level agreements and support programs.</p>
<p>Windows Azure, SQL Azure and .NET Services will be commercially available at the Professional Developer Conference 2009 and Microsoft  hopes you will continue building on the Community Technology Preview (CTP) at no cost today.    </p>
<p>Upon commercial availability Microsoft  will offer Windows Azure through a consumption-based pricing model, allowing partners and customers to pay only for the services that they consume.</p>
<p><strong>Windows Azure:</strong><br />
 Compute @  $0.12 / hour<br />
 Storage @ $0.15 / GB stored<br />
 Storage Transactions @ $0.01 / 10K</p>
<p><strong>SQL Azure:</strong><br />
 Web Edition â€“ Up to 1 GB relational database @ $9.99<br />
 Business Edition â€“ Up to 10 GB relational database @ $99.99 </p>
<p><strong>.NET Services:</strong><br />
 Messages @ $0.15/100K message operations , including Service Bus messages and Access Control tokens</p>
<p>Bandwidth across all three services will be charged at $0.10 in / $0.15 out / GB</p>
<p>You can read more here: http://blogs.msdn.com/windowsazure/archive/2009/07/14/confirming-commercial-availability-and-announcing-business-model.aspx</p>
<p>Brent Ozar also has a nice post here: http://www.brentozar.com/archive/2009/07/sql-azure-pricing-10-for-1gb-100-for-10gb/</p>
<p>So how long before you move to the cloud?</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/windows-azure-sql-azure-and-net-services/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
	</channel>
</rss>
