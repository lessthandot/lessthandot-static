<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>data modeling &#8211; LessthanDot</title>
	<atom:link href="/index.php/tag/data-modeling/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>A Technical Community for IT Professionals</description>
	<lastBuildDate>Sat, 09 Mar 2019 12:50:36 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.1</generator>
	<item>
		<title>Modeling the Agile Data Warehouse with Data Vault – Review</title>
		<link>/index.php/datamgmt/datadesign/modeling-the-agile-data-warehouse-with-data-vault-review-2/</link>
		<comments>/index.php/datamgmt/datadesign/modeling-the-agile-data-warehouse-with-data-vault-review-2/#respond</comments>
		<pubDate>Thu, 17 Jul 2014 11:18:38 +0000</pubDate>
		<dc:creator><![CDATA[Koen Verbeeck]]></dc:creator>
				<category><![CDATA[Book Review]]></category>
		<category><![CDATA[Business Intelligence]]></category>
		<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[agile]]></category>
		<category><![CDATA[data modeling]]></category>
		<category><![CDATA[data vault]]></category>
		<category><![CDATA[data warehouse]]></category>
		<category><![CDATA[syndicated]]></category>

		<guid isPermaLink="false">/?p=2842</guid>
		<description><![CDATA[A few months ago I followed an introductory course about the data vault modeling technique for data warehouses at a local training provider. As part of the training, I received the book Modeling the Agile Data Warehouse with Data Vault written by Hans Hultgren who also is an instructor for the official data vault certification. [&#8230;]]]></description>
				<content:encoded><![CDATA[<p style="text-align: justify">A few months ago I followed an introductory course about <a href="http://en.wikipedia.org/wiki/Data_Vault_Modeling">the data vault modeling</a> technique for data warehouses at a <a href="https://www.infosupport.com/">local training provider</a>. As part of the training, I received the book <a href="http://www.amazon.com/Modeling-Agile-Warehouse-Vault-Volume/dp/061572308X/ref=tmm_pap_title_0?ie=UTF8&amp;qid=1405584375&amp;sr=8-2">Modeling the Agile Data Warehouse with Data Vault</a> written by <a href="http://hanshultgren.wordpress.com/">Hans Hultgren</a> who also is an instructor for the official data vault certification. This blog post is a review of this book; I will not introduce the concepts of data vault modeling.</p>
<p style="text-align: justify"><a href="/wp-content/uploads/2014/07/datavault.jpg"><img class="alignnone wp-image-2841 size-medium" src="/wp-content/uploads/2014/07/datavault-200x300.jpg" alt="datavault" width="200" height="300" srcset="/wp-content/uploads/2014/07/datavault-200x300.jpg 200w, /wp-content/uploads/2014/07/datavault.jpg 231w" sizes="(max-width: 200px) 100vw, 200px" /></a></p>
<p style="text-align: justify">First of all I am glad I received this book for “free” (read: it was most likely included in the price of the training), because the book has a list price of a whopping $95 (Amazon fortunately gives a steep discount on the paperback edition). No, the 434-page book is not made of pure gold, as you might think, but there are quite a lot of pages in color. There are 212 figures in color in the book, so I guess this contributes to the total price, but <a href="http://www.amazon.com/Information-Dashboard-Design-At---Glance/dp/1938377001/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1405585061&amp;sr=1-1&amp;keywords=information+dashboard+design&amp;dpPl=1">Information Dashboard Design</a> is also in color and has a list price of $40, less than half of the data vault book. This is of course only relevant to printed copies, where they have to cut down trees and use quite some ink, but the Kindle edition is even more expensive and is yours for a mere $84.09. Sense, it makes none. To top it off, the book unfortunately has a bit of an amateur look-‘n-feel. The cover art and the pictures used at the start of each section aren’t exactly world class. Anyway, you can’t judge a book by its cover, so we’ll take a look at the content itself.</p>
<p style="text-align: justify">I have to say, this books reads like a breeze. I finished the book in a couple of days, despite being over 400 hundred pages. This is due to the writing style of the author but also because there are 31 (!) chapters in this book. That’s about 14 pages average for one chapter only. But as I said before, there are 212 figures and each chapter has its own title page (so 31 pages less to read) and usually some white space at the end. Because each chapter finished so quickly, you have the feeling you advance really fast through the book. There are a few spelling mistakes and typos here and there, but nothing too worse. The only thing that irritated me some times is the way the author emphasizes words. A hint: he emphasizes a lot. In almost every paragraph, there is something underlined, in italic or in bold or every possible combination of those three. This gives you the feeling you are reading a high-school text book or a supermarket tabloid. And <a href="http://practicaltypography.com/underlining.html">underlining is not done</a> (yes, I am painfully aware that the URL hyperlink is underlined). Any decent editor should have paid attention to that. Another point is that the author frequently repeats itself. I guess this is because he really wants to make a point (how fantastic data vault is compared with 3NF and dimensional modeling in some aspects), but after a few times I already got the point. No need in repeating it in almost every chapter. This is also the case for figures. There’s this one particular figure that I’ve encountered about 11 times throughout the book (sometimes in very slight variations). That is being thorough all right.</p>
<p style="text-align: justify">OK, so there may be some improvements possible for form and layout, but what about the data vault stuff itself? Well, it is explained pretty well. If you have had no exposure to data vault yet, this book will teach you a solid understanding of its principles (I consider myself to this category of readers). I guess if you are a more advanced data vault modeler, there is some nuggets here and there to pick up or you can use the book as a reference.</p>
<p style="text-align: justify">The first section (Data Vault Ensemble, which teaches you why data vault is what it is) and the third section (Working with Data Vault) really dive into data vault and how you should design such a model, but there’s a large section in the middle – Data Warehousing and Business Intelligence – which is a bunch of loosely tied chapters about a variety of subjects. Some of these chapters are in my opinion not needed to explain data vault or agile modeling. They are filler and can easily be omitted from the book. It would have made the book at least 100 pages thinner (and probably a bit cheaper in price). At the back cover Hans says “This is a guide to data vault modeling and at the same time an exploration of the broader concepts surrounding data warehousing &amp; business intelligence today”, so I should not have been that surprised about those chapters, but on the other hand, if the book contains the words “agile data warehouse” and “data vault”, I expect a deep dive into both subjects. The problem is that because of all those <em>broader concepts</em>, these two subjects don’t get the attention they deserve. Especially the agile part. From time to time the author mentions agile and how data vault can quickly adapt to changes and how fast it can be loaded because of parallelism and how agile all of this is, but it never goes any deeper. There is no treatment on how to develop the data vault in an agile project setting. How to deal with scrum or sprints or whatever. None of that. But I can still live with it, I read the book to learn more about data vault and the book succeeded in that goal. It seems the word agile is just thrown into the title to serve as link bait.</p>
<p style="text-align: justify">However, I would have liked some more detailed examples. Most of the time it is a really easy example about customers and customers classes and in some cases there is also a sale, products and employees involved, but nothing more complicated than that. This is in my opinion the biggest downside of the book. I really would have liked to see for example a whole transactional process modeled in 3NF, how it is ported into data vault and how at the end the (dimensional) data marts are generated. The book stays too basic. The last chapter of the book – titled Comparison Example – shows some tables with actual rows and data and how they are transformed. I was looking forward to that chapter while reading through the book because I hoped it would finally give a thorough hands-on example. Alas, it was the same customer table used in any other example. This book is not enough hands-on. I guess you have to follow the (paid) courses to get more hands-on material.</p>
<p style="text-align: justify">The conclusion. I may have sounded a bit harsh in the previous paragraphs, but don’t get me wrong. I liked reading the book and I definitely learned a lot about data vault. I just wished the book got more hands-on examples (and maybe a decent editor). I do recommend this book to everyone who wants a solid introduction to data vault (there are not that many alternatives to be honest).</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/modeling-the-agile-data-warehouse-with-data-vault-review-2/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Interview With Louis Davidson Author of Pro SQL Server 2008 Relational Database Design and Implementation</title>
		<link>/index.php/datamgmt/datadesign/interview-with-louis-davidson-author-of/</link>
		<comments>/index.php/datamgmt/datadesign/interview-with-louis-davidson-author-of/#comments</comments>
		<pubDate>Thu, 18 Sep 2008 22:23:24 +0000</pubDate>
		<dc:creator><![CDATA[SQLDenis]]></dc:creator>
				<category><![CDATA[Data Modelling and Design]]></category>
		<category><![CDATA[Database Administration]]></category>
		<category><![CDATA[Database Programming]]></category>
		<category><![CDATA[Microsoft SQL Server]]></category>
		<category><![CDATA[Microsoft SQL Server Admin]]></category>
		<category><![CDATA[book]]></category>
		<category><![CDATA[data modeling]]></category>
		<category><![CDATA[database design]]></category>
		<category><![CDATA[interview]]></category>
		<category><![CDATA[sql server 2008]]></category>

		<guid isPermaLink="false">/index.php/2008/09/interview-with-louis-davidson-author-of/</guid>
		<description><![CDATA[Pro SQL Server 2008 Relational Database Design and Implementation is one of those books that should be in the hands of every SQL Server developer. There are tons of SQL Server programming books around but none of them covers the fundamentals of a good S&#8230;]]></description>
				<content:encoded><![CDATA[<p><a href="http://www.amazon.com/gp/product/143020866X/002-3562882-4309664?ie=UTF8&amp;tag=sql08-20&amp;linkCode=xm2&amp;camp=1789&amp;creativeASIN=143020866X">Pro SQL Server 2008 Relational Database Design and Implementation</a> is one of those books that should be in the hands of every SQL Server developer. There are tons of SQL Server programming books around but none of them covers the fundamentals of a good SQL Server database, the design. If your design is &#8216;broken&#8217; then it is a lot harder to fix it down the road, design is probably the number one reason people have all kinds of problems with their databases. </p>
<p>I have both the 2000 and 2005 edition of the Pro SQL Server 2008 Relational Database Design and Implementation so I was very excited when I noticed that Louis had finished his latest version. I contacted him to see if he would be willing to do an interview and as you can see he did. Make sure to read the whole interview because there is a way to win a copy.</p>
<p><strong>Is the book geared towards a beginner/intermediate level user or do you have to be an advanced user to really utilize the information in this book?</strong></p>
<p>Well, yes and no.  Certainly not &#8220;beginner&#8221; in the completely uninitiated sense at all.  Like I wouldn&#8217;t give my wife or daughter the book and say &#8220;go for it.&#8221; (Neither of them being technically oriented enough to completely grasp my Logitech remote control at times.)  However, a beginner to database programming/design would not be a terrible thing, and I think that they could really get a quick feel for the theory.  I don&#8217;t cover T-SQL much at all, pretty much limited to writing triggers and some architecture advice.</p>
<p>I set the book up much like a college level course would be set up.  Theory first, then implementation, and finally a touch of programming. Of course, in college you are sort of a captive audience, so in some ways I wonder who might actually read the first chapter(s) of the book (if I could find out, I have a job offer for them though!)  Once I finally get over the whole process of writing the book, I hope to do some polls/focus groups on the book and see how people feel about it as I need to do some trimming for the next version as I expanded so much with the example code this time (good thing, but if the book grows larger so will the price.)  Every time I write a new edition, I think to myself &#8220;this is the last time&#8221; and I make my wife promise to hit me with a baseball bat if I start again, but when I find out that people are actually reading it, well it gets me interested again…and my wife wouldn&#8217;t hit me with a bat unless I did something far more…well…I digress.</p>
<p><strong>What are some of the common mistakes you see when people are designing databases?</strong></p>
<p>Well, not designing their databases would certainly be tops on the list.  So much of what I see wrong on the forums is where people are just going with what they know from writing C# or VB, often just treating tables like arrays.  The problem with this is that relational coding is NOT the same as functional coding, and the database is the central most piece of almost every system.  Screw that up and nothing is ever going to be quite right in that system.  In the end, the data is definitely all that the users care about, so getting it right it so important.</p>
<p>Part of the reason I include theory in my book is to help people understand why you need to program a relational database using relation programming concepts. Many people talk about normalization like it is some sort of ancient method for making the database more difficult to work with.  The fact is, the SQL language was and is built with normalization in mind.  It is very hard to disassemble parts of your structures, either in a row or in a column, but the opposite is very easy.  Two columns can be concatenated to form one column.  Two rows can be joined to produce a single row.  </p>
<p>I know that I often come off as a zealot, but frankly once you understand normalization, and do it a few times, everything else seems horribly wrong. The thing I find most bewildering is that people feel they can &#8220;improve&#8221; upon relational theory without even understanding it in the first place.  I am a fan of starting every chapter with a quote, and my quote I use for this situation is from C.S.Lewis: &#8220;There are no variations except for those who know a norm, and no subtleties for those who have not grasped the obvious.&#8221;  If you don&#8217;t know the current agreed upon right way, you cannot argue against it and make changes.  So understanding theory first is the first thing to do.</p>
<p><strong>Do you think every database should have a sequence table?</strong></p>
<p>Pretty much, yeah. In my new book, I dedicate quite a few pages to the concept of sequence tables and calendar tables. Both of these give you the ability to do some things using relational methods that were freaking ugly using T-SQL&#8217;s string handling and date functions.  I also included some example code that does the sum of two cubes, and finds values where a value is the sum of two cubes in 2 or 3 different ways.  Fun stuff. Not terribly practical, but workable and a good thought experiment.  One thing I love about writing (and answering forum questions) is that it allows you to break away from &#8220;normality&#8221; and just enjoy solving problems that have no tomorrow (at least not for you.)</p>
<p>I try to include a utility and a tools schema in every database I design that has dba utilities (like row count history for example) and end user tools (the sequence table and a calendar table) that can be customized to meet the needs of the users/programmers, like if you want to have string manipulation functions, including CLR objects that might get created.</p>
<p>Which brings up the question…Should T-SQL have better math/looping/string handling capabilities?  Wait, you are interviewing me, I don&#8217;t have to answer that one, whew.</p>
<p><strong>People are using triggers instead of constraints for data integrity; do you think that triggers are abused or maybe even misunderstood? </strong></p>
<p>Abused AND misunderstood. Not that triggers aren&#8217;t (in my at least somewhat humble opinion) very useful, but too often it seems that they are used in bad ways. I don’t know how many times I have seen trigger code that ignores the fact that more than one row can be modified, but it is more times than I have seen triggers written assuming sets of data could change (well, at least when I wasn&#8217;t writing them!)</p>
<p>I am also writing a section in an upcoming book that the MVP&#8217;s are producing about SQL Server that covers succinctly the different tools that SQL Server has to offer to protect data.  Triggers are near the bottom of the list, just before stored procedures and certainly after any declarative constraints like foreign keys, check constraints, and defaults. That section will be around 15 pages, while in my design book it is around 66 pages…so far less code examples, but that is the way it goes.  I wouldn&#8217;t want to take away from the other amazing authors on that project (nor would I want you to get all the good stuff from my book, he says just a little bit selfishly)</p>
<p><strong>Finally we have date and time data types, will this be of any help in designing databases and querying against those columns?</strong></p>
<p>The date data type is probably my favorite new feature in SQL Server 2008. This is the one feature that will eventually change SQL Server designs for the better.  It certainly will make working with date data easier. Never needing to store time data when you don&#8217;t need time data is going to change the world.  </p>
<p>The crazy date values and roundoff issues with all of the SQL Server 2005 and earlier types were just a pain, especially with datetime.  The fact that times of &#8217;23:59:59.999&#8242; rounded off to the next day confused everyone at one time or another. </p>
<p>The only thing I wish they had added was a time type that didn&#8217;t just hold a time of day, but held a time duration.  Time as it is will be somewhat useful, but it certainly won&#8217;t be as earth shatteringly useful as the date type. </p>
<p><strong>Why do you think people have concurrency issue, is it mostly design or bad code?</strong></p>
<p>Well, it certainly can be design, but too often it is just basically a matter of tuning.  Now here is where things can get bogged down in terminology.  A well designed database, in my opinion, doesn&#8217;t include indexes. This would even be true if SQL Server implemented unique constraints without using indexes (which could certainly be possible.) To me, the database design is complete when data is protected via design and constraint (and even triggers) from poor data.  Performance is another level of problem…implementation if you will.</p>
<p>The next thing I do is to start accessing the data (generally in a moderately controlled development environment), and this access is where you we start to tune access. During the development process we start to create data and tune access.  Then you do testing for performance and realize what paths the data is accessed in.  By this point it seems that 80-90% of the indexes have been found and any changes to the design can be made, for performance&#8217; sake.  Once real users are involved I usually find the other indexes that need to be added, as well as adjusting the concurrency level as needed.  Some change to the design can be necessary, but more often than not it seems that good code plus good indexing is all that is necessary for good concurrency.</p>
<p>My favorite new feature in SQL Server 2005 was the READ_COMMITTED_SNAPSHOT setting you could apply to the database.  Where snapshot isolation level allows the transaction to see how the data looked at the start of the transaction, READ_COMMITTED_SNAPSHOT allowed this to occur at a statement level only, giving you pretty much the same effect as read committed, but with not locking or blocking on reads.  For &#8220;canned&#8221; systems where you can&#8217;t make major changes to the structures, particularly where they use an optimistic locking method (or no concurrency control in code) that it can greatly improve concurrency.</p>
<p>So, while it certainly can be a design issue, it seems to me that concurrency is more of a tuning effort than anything. A good design can have poor concurrency, as can a bad one.  Of course, the good design is easier to tune, no doubt about it. </p>
<p><strong>What are the most important things a person can do to master SQL?</strong></p>
<p>Use it. I mean really, that is the key. My advice is to look yourself in the eye and say to yourself: &#8220;I will not use a cursor.  I will not use a temp table. I will not use a function.&#8221;  Then follow that advice until you just can&#8217;t figure out how not to.  I was at one time the king of the cursor, even before it was implemented in SQL Server as a first class citizen. (Hint, we used a temp table and set rowcount 1, get a row, delete that row, do our business, then get the next row.)  </p>
<p>Then, as I was getting decent at SQL, I went to a class on SQL taught by Dr. David Rozenshtein and he really pounded into our heads about the concepts of relational set-based programming. Paraphrasing, but he basically drilled it into our heads to do all that you can in one statement and let the engine do its thing. This isn&#8217;t always the case, but it is a good way to start.  I also loved his excellent book &#8220;The Essence of SQL : A Guide to Learning Most of SQL in the Least Amount of Time&#8221; and lots of practice and I was a fan.  Of course I was pretty much unable to do any functional programming after that (I was a VB fan in the early days…even wrote a compiler for a senior project in college in VB 1.0.  Got a good grad, but the professor thought I was nuts).</p>
<p><strong>Can you list any third party tools that you find useful to have as a SQL Server developer/admin?</strong></p>
<p>Well, first is a data modeling tool.  I use ERwin from CA, but there are several others out there.  I know some architects that do things directly via scripts, but I am very visual (I have very little memory for details, regularly looking things up in books, often even my own, one of the reasons I like writing!) and really need the overview and relationship information from the graphical part of the data model.  I like to work with the same tool to generate most of the DDL for my tables, constraints, etc, rather than maintaining a script.</p>
<p>The second important tool that I think a designer can have is a database comparison tool. The fact is, no matter how good of a process you might have, changes always seem to get made to the different environments during the development and tuning process.  Add to that that sometimes the implementer misses something in the process from dev to production (with stops along the way for testing, tuning, and qa) it certainly isn&#8217;t a bad idea.  I also highly recommend that when working with 3rd party databases that you compare the database before and after any service packs, so you know what is done.  You don&#8217;t want them to drop your customizations (like indexes) and all of the sudden your system runs like retired baseball catcher.</p>
<p>Part of my design process is to use my modeling tool to generate an &#8220;ideal&#8221; version of a database and then compare it to the last version, building a script for applying to upgrade a database, starting with the compare tool&#8217;s script, and adding in the other stuff that might need done (like loading a table.)</p>
<p>Next most important to me is a good code formatter.  People tend to format their code in really weird ways, sometimes just that I don&#8217;t like, and sometimes in ways that makes it simply obvious why their code didn&#8217;t work in the first place.</p>
<p>Since I mentioned Erwin, I will mention that I am also a big fan of the RedGate tools for sure.  (full disclosure, I am a member of their &#8220;Friends of Redgate&#8221; http://www.red-gate.com/About/community_relations/friends_of_RG.htm program,) and use them quite often. </p>
<p><strong>Name your three favorite new things in SQL Server 2008</strong></p>
<p>Date data type for sure. I mentioned that a few questions back, so I won&#8217;t go into that.</p>
<p>Table constructors are pretty nice.  Because they take up less space, I probably saved 2 or 3 pages in my book of useless UNION ALL clauses along.</p>
<p>And, even though they aren&#8217;t quite as wonderful as I would have hoped, the new dependency dynamic management views are pretty nice. It was kind of weird.  They were working pretty cool until RC0, then they changed how they worked and errors started to be raised in places that makes them awkward to use. Not impossible, but not as nice as you would hope.  Even still, you can use these views in your releases to see if all objects that are needed (less dynamic calls, of course) actually exist. </p>
<p>The problem with this question for me is that I had high hopes for SQL Server 2008, and quite often they really weren&#8217;t met (in Microsoft&#8217;s defense, I wasn&#8217;t actually led to believe things would happen, just hopes.)  For example, the table constructors. If fully implemented the horrible UPDATE syntax with JOINs could finally be retired and replaced by a syntax that protects you from updating the same row to different values in the same statement. Oh well, maybe next time?</p>
<p>I don&#8217;t want to make it sound like I am not pleased with 2008.  I am, and would suggest upgrading as soon as you could.  There are so many cool new features like Resource Governor, Auditing, Transparent Data Encryption, MERGE, etc that make it a wonderful next step in the process.  It just feels like the core T-SQL components could have progressed a little further.  I mean it is SQL Server after all.</p>
<p><strong>Where can we expect to see you in 2008/2009? Any conferences, seminars or trade shows perhaps?</strong></p>
<p>My house in front of my new HDTV, for sure. And there are two hot fried chicken places in Nashville that I just can&#8217;t get enough of…Any readers want to go have lunch with me, we will go to either of them pretty much anytime you want.  </p>
<p>To answer your actual question, I just spoke with Paul Nielsen at the devlink conference in Nashville (www.devlink.net) which is just a fabulous time. John Kellar does an amazing job.  Plan to be back there next year.</p>
<p>Next up for me is speaking at the Nashville SQL Server Users&#8217; group (http://nashville.sqlpass.org/) on September 26th of 2008.  My publisher is sponsoring and I am trying to arrange food that is non-pizza.  Following that I will be at the PASS conference (www.sqlpass.org) in November, again speaking with Paul Nielsen on database design, as well as a session on Tuning with Dynamic Management Views.</p>
<p>I am always willing to go more places, but I am just an average moderately average speaker at this point.  I am more comfortable sitting here at my desk in super media heaven (I have two computers, three monitors, my TV, an amp and a digital frame all in front of me at my desk.)  When I am writing I have myself to edit me at least a few times. As an example, I really don&#8217;t like meetings where people are throwing around ideas, especially when there is an adversarial air to things. When writing I can craft a response, do research, and not end up agreeing to whatever is said.  Too often meetings are won by the charismatic, not the most knowledgeable. No one is really charismatic on paper, it is just words.  Of course, the hardest part is getting people to actually read emails.  Or long interviews, I reckon.</p>
<p><strong> One way to make a person read the whole book is to include Easter eggs and then have a competition, any hidden things like that this time?</strong></p>
<p>I did this last time and it went over like a lead zeppelin.  In fact, I will make it easy for one of your readers.  A free copy of my Pro SQL Server 2008 Relational Database Design and Implementation (I love that title. Next title will be so big that it takes two volumes just for the title alone.)  book to the first two persons who email Louis@drsql.org telling me where the hidden message was in my 2005 book. </p>
<p>Thanks to Louis for this interview, if you wonder what to give that DBA/SQL Developer this Holiday Season then you can&#8217;t go wrong with <a href="http://www.amazon.com/gp/product/143020866X/002-3562882-4309664?ie=UTF8&amp;tag=sql08-20&amp;linkCode=xm2&amp;camp=1789&amp;creativeASIN=143020866X">Pro SQL Server 2008 Relational Database Design and Implementation</a></p>
<p>Download chapter 1 here: http://www.apress.com/book/downloadfile/4090</p>
]]></content:encoded>
			<wfw:commentRss>/index.php/datamgmt/datadesign/interview-with-louis-davidson-author-of/feed/</wfw:commentRss>
		<slash:comments>10</slash:comments>
		</item>
	</channel>
</rss>
