<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: What does &#8220;good at C#&#8221; mean?</title>
	<atom:link href="/index.php/itprofessionals/professionaldevelopment/what-does-good-at-c-mean/feed/" rel="self" type="application/rss+xml" />
	<link>/index.php/itprofessionals/professionaldevelopment/what-does-good-at-c-mean/</link>
	<description>A Technical Community for IT Professionals</description>
	<lastBuildDate>Tue, 26 Feb 2019 12:40:14 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.1</generator>
	<item>
		<title>By: Eli Weinstock-Herman (tarwn)</title>
		<link>/index.php/itprofessionals/professionaldevelopment/what-does-good-at-c-mean/#comment-1235683</link>
		<dc:creator><![CDATA[Eli Weinstock-Herman (tarwn)]]></dc:creator>
		<pubDate>Mon, 23 Jun 2014 10:44:32 +0000</pubDate>
		<guid isPermaLink="false">/?p=2751#comment-1235683</guid>
		<description><![CDATA[From Tahir via twitter:

&lt;blockquote&gt;I think the trust in a framework comes from confidence in the tech and our abilities to master it&lt;/blockquote&gt;

&lt;blockquote&gt;even a bad framework in capable hands can be used to do good (I sound like a Marvel Super Hero)&lt;/blockquote&gt;

&lt;blockquote&gt;but I see too many good frameworks, patterns and theories badly used is mishandled at best. Simplicity KISS is best&lt;/blockquote&gt;

&lt;blockquote&gt;for me it means being fluent in C# the language. Understanding the idioms...The language, not the frameworks&lt;/blockquote&gt;

I think my problem at this stage is that I haven&#039;t spent a lot of time looking for what I don&#039;t know in C#, and don&#039;t remember what those things were (beyond LINQ and the many flavors of async, maybe hiding but I still don&#039;t understand that) to be able to build a series of signposts that show how I got here.]]></description>
		<content:encoded><![CDATA[<p>From Tahir via twitter:</p>
<blockquote><p>I think the trust in a framework comes from confidence in the tech and our abilities to master it</p></blockquote>
<blockquote><p>even a bad framework in capable hands can be used to do good (I sound like a Marvel Super Hero)</p></blockquote>
<blockquote><p>but I see too many good frameworks, patterns and theories badly used is mishandled at best. Simplicity KISS is best</p></blockquote>
<blockquote><p>for me it means being fluent in C# the language. Understanding the idioms&#8230;The language, not the frameworks</p></blockquote>
<p>I think my problem at this stage is that I haven&#8217;t spent a lot of time looking for what I don&#8217;t know in C#, and don&#8217;t remember what those things were (beyond LINQ and the many flavors of async, maybe hiding but I still don&#8217;t understand that) to be able to build a series of signposts that show how I got here.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Eli Weinstock-Herman (tarwn)</title>
		<link>/index.php/itprofessionals/professionaldevelopment/what-does-good-at-c-mean/#comment-1217829</link>
		<dc:creator><![CDATA[Eli Weinstock-Herman (tarwn)]]></dc:creator>
		<pubDate>Sat, 21 Jun 2014 10:15:23 +0000</pubDate>
		<guid isPermaLink="false">/?p=2751#comment-1217829</guid>
		<description><![CDATA[In our internal product matrix, we have a very general set of transitions that starts with &quot;ability to complete small bugs without supervision&quot; all the way to &quot;ability to design and refactor the architecture, make architecture-level decision based on direct conversation with customers, ...&quot;. I think that&#039;s why it is important that we both self-evaluate and have external evaluation so we have some confirmation of our confidences and can try and find the places where we are either over-confidant or have simply not had the opportunity to really shine in yet. When we interview, we are looking at technical skills as the price of entry, but you have to have a strong desire and history of learning and improvement on top of that, ability and desire to communicate with end users, and a slew of other skills beyond the direct technical ones (did I mention I&#039;m &lt;a href=&quot;http://precisionlender.com/careers/&quot; rel=&quot;nofollow&quot;&gt;hiring?&lt;/a&gt;).

Good thought on LINQ and async too, I&#039;m going to roll them into levels in .Net. I agree with the JS frameworks, but at the same time I think you could get really good w/ JS as a language without using many frameworks or be kind of mediocre w/ JS but spread that mediocrity across 15 frameworks.

Now that I&#039;m thinking about it, maybe the JS one should have levels that include understanding patterns like revealing module and prototype, then explaining how constructors and function &#039;inheritance&#039; actually work are probably in another level. Knowing what &#039;this&#039; means is probably in there too. Defining objects at all is probably in one of the early levels, I remember that wasn&#039;t obvious early on. The beginner level is probably something like an ability to write logic in javascript, create functions that are called from event handlers, etc.]]></description>
		<content:encoded><![CDATA[<p>In our internal product matrix, we have a very general set of transitions that starts with &#8220;ability to complete small bugs without supervision&#8221; all the way to &#8220;ability to design and refactor the architecture, make architecture-level decision based on direct conversation with customers, &#8230;&#8221;. I think that&#8217;s why it is important that we both self-evaluate and have external evaluation so we have some confirmation of our confidences and can try and find the places where we are either over-confidant or have simply not had the opportunity to really shine in yet. When we interview, we are looking at technical skills as the price of entry, but you have to have a strong desire and history of learning and improvement on top of that, ability and desire to communicate with end users, and a slew of other skills beyond the direct technical ones (did I mention I&#8217;m <a href="http://precisionlender.com/careers/" rel="nofollow">hiring?</a>).</p>
<p>Good thought on LINQ and async too, I&#8217;m going to roll them into levels in .Net. I agree with the JS frameworks, but at the same time I think you could get really good w/ JS as a language without using many frameworks or be kind of mediocre w/ JS but spread that mediocrity across 15 frameworks.</p>
<p>Now that I&#8217;m thinking about it, maybe the JS one should have levels that include understanding patterns like revealing module and prototype, then explaining how constructors and function &#8216;inheritance&#8217; actually work are probably in another level. Knowing what &#8216;this&#8217; means is probably in there too. Defining objects at all is probably in one of the early levels, I remember that wasn&#8217;t obvious early on. The beginner level is probably something like an ability to write logic in javascript, create functions that are called from event handlers, etc.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Alex Ullrich</title>
		<link>/index.php/itprofessionals/professionaldevelopment/what-does-good-at-c-mean/#comment-1211875</link>
		<dc:creator><![CDATA[Alex Ullrich]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 19:25:18 +0000</pubDate>
		<guid isPermaLink="false">/?p=2751#comment-1211875</guid>
		<description><![CDATA[In general I think the transition from knowing *how* to write code to knowing *when* to write code (and the other side - when to look for something already written) is an important one.  I don&#039;t think we look for pure programming skill anymore as much as the ability to solve problems quickly, which is often at least as much about knowing your way around the open source ecosystem for your particular platform.  Or in a lot of cases whole other platforms that might offer better tooling for the problem you&#039;re trying to solve.

For javascript I think transitioning into using frameworks / patterns / testing is probably by itself a sign of progression into the more advanced stages.  Possibly for general .net also (async and linq in particular I don&#039;t think really stand up on their own - you kind of know them or you don&#039;t).

For MVC I think knowing some of the stuff beyond controllers probably marks the transition into the more advanced stages.  Action filters and route customization would probably be pretty intermediate, then once you start getting into customizing the framework itself (custom model binders, controller factories etc...) that would mark the next stage.]]></description>
		<content:encoded><![CDATA[<p>In general I think the transition from knowing *how* to write code to knowing *when* to write code (and the other side &#8211; when to look for something already written) is an important one.  I don&#8217;t think we look for pure programming skill anymore as much as the ability to solve problems quickly, which is often at least as much about knowing your way around the open source ecosystem for your particular platform.  Or in a lot of cases whole other platforms that might offer better tooling for the problem you&#8217;re trying to solve.</p>
<p>For javascript I think transitioning into using frameworks / patterns / testing is probably by itself a sign of progression into the more advanced stages.  Possibly for general .net also (async and linq in particular I don&#8217;t think really stand up on their own &#8211; you kind of know them or you don&#8217;t).</p>
<p>For MVC I think knowing some of the stuff beyond controllers probably marks the transition into the more advanced stages.  Action filters and route customization would probably be pretty intermediate, then once you start getting into customizing the framework itself (custom model binders, controller factories etc&#8230;) that would mark the next stage.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Eli Weinstock-Herman (tarwn)</title>
		<link>/index.php/itprofessionals/professionaldevelopment/what-does-good-at-c-mean/#comment-1208884</link>
		<dc:creator><![CDATA[Eli Weinstock-Herman (tarwn)]]></dc:creator>
		<pubDate>Fri, 20 Jun 2014 13:12:53 +0000</pubDate>
		<guid isPermaLink="false">/?p=2751#comment-1208884</guid>
		<description><![CDATA[I&#039;m going to prime the pump a little on some of the more obvious ones.

For the unit testing ones, I think a beginner level would be ability to use one of the testing frameworks without having to look it up on google every time. Then moving up a step would be experience with a mock/fake/spy library, then maybe the next level would be experience with multiple of these, and then finally experience with a higher-level BDD framework to drive all the rest (SpecFlow, Cucumber, etc) or UI testing framework (Selenium, hosted cross-browser testing tools, etc)

For DVCS, I think that would be something like bsic knowledge of committing, pulling, and branching in one, then advanced knowledge (reset, revert, rewrite) in one, then maybe advanced experience in more than one?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m going to prime the pump a little on some of the more obvious ones.</p>
<p>For the unit testing ones, I think a beginner level would be ability to use one of the testing frameworks without having to look it up on google every time. Then moving up a step would be experience with a mock/fake/spy library, then maybe the next level would be experience with multiple of these, and then finally experience with a higher-level BDD framework to drive all the rest (SpecFlow, Cucumber, etc) or UI testing framework (Selenium, hosted cross-browser testing tools, etc)</p>
<p>For DVCS, I think that would be something like bsic knowledge of committing, pulling, and branching in one, then advanced knowledge (reset, revert, rewrite) in one, then maybe advanced experience in more than one?</p>
]]></content:encoded>
	</item>
</channel>
</rss>
